{
  "hash": "41ab5359a9c557c8c93947ad1c252e35",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Ready, Aim, Compute!\"\ndescription: \"Physics 1 physics vs. real world physics. Sorry, the world isn't filled with spherical cows in a vacuum\"\nauthor: \"Steven Wolf\"\ndate: \"3/6/2025\"\nnumber-sections: false\ncategories:\n  - Python\n  - Modeling\n  - Classes\n  - Motion\nexecute: \n  messages: false\n  warning: false\njupyter: python3\ndraft: true\n---\n\n\nI've stalled out a bit on my heat equation modeling project because I've been thinking about ways to make it better. Also, I've been busy with the real world. So I thought I'd adapt something that I've used in class and post it here. In the standard treatment, we often make approximations that may or may not be valid, and never test these approximations. In fact, that's why we physicists often get made fun of, because we are talking about spherical cows. I like to get my students to think beyond spherical cows and give them tools to examine the limits of these approximations.\n\n[![ ](spherical-cow.png){width=25% fig-align=\"center\"}](https://www.sphericalcowblog.com/spherical-cows)\n\n## A typical Physics 1 projectile motion problem\nI've given this problem (or variations of it) in my physics class for years:\n\n> While on a vacation to Kenya, you visit the port city of Mombassa on the Indian \n> Ocean. On the coast, you find an old Portuguese fort probably built in the 16th \n> century. Large stone walls rise vertically from the shore to protect the fort \n> from cannon fire from pirate ships.  You wonder how close a pirate ship would \n> have to sail to the fort to be in range of the fort's cannon. Of course you \n> realize that the range depends on the velocity that the cannonball leaves the \n> cannon, as well as the height of the cliff.\n\nUsually, we set up a coordinate system like the picture below:\n\n![](systemFig.png){width=50% fig-align=\"center\"}\n\nUsing this coordinate system, we can determine the equations of motion as follows:\n\n$$\n\\begin{align*}\n a_x(t) = \\frac{dv_x}{dt} &= 0 \\\\\n a_y(t) = \\frac{dv_y}{dt} &= -g \\\\\n\\end{align*}\n$$\n\nThese are integrated to find the velocity with the condition: $\\vec{v}_i = (v_i\\cos\\theta, v_i\\sin\\theta) = (v_x(0),v_y(0))$:\n\n$$\n\\begin{align*}\n v_x(t) = \\frac{dx}{dt} &= v_i \\cos\\theta t \\\\\n v_y(t) = \\frac{dy}{dt} &= v_i \\sin\\theta t - gt \\\\\n\\end{align*}\n$$\n\nThese are integrated again to find the position with the condition: $\\vec{r}_i = (0,H) = (x(0),y(0))$\n\n$$\n\\begin{align*}\n x(t) &= v_i \\cos\\theta t \\\\\n y(t) &= H + v_i\\sin\\theta t - \\frac{1}{2}gt^2 \\\\\n\\end{align*}\n$$\n\nWe are also interested in the time of flight (i.e., How long the projectile is in the air):\n\n$$\ny(T) = 0 = H + v_i \\sin\\theta T - \\frac{1}{2} gT^2 \\implies T = \\frac{v_i\\sin\\theta + \\sqrt{v_i^2 \\sin^2\\theta + 2gH}}{g}\n$$\n\n(Note, since the projectile is launched at $t=0$, we expect the time of flight $T>0$, so I have thrown out the negative solution for $T$ in the equation above.)\n\nAnd the range[^1] of the projectile:\n$$\nD = x(T) = v_i\\cos\\theta T = v_i \\cos\\theta \\frac{v_i\\sin\\theta + \\sqrt{v_i^2 \\sin^2\\theta + 2gH}}{g}\n$$\n\n\n[^1]: No, that's not the \"range equation\" found in standard physics textbooks. And no, I haven't made a mistake. The \"range equation\" in the standard physics text assumes $H=0$, that is, there is no elevation change to be concerned about. We can reduce this if we set $H=0$. In this case, $T = \\frac{2 v_i \\sin\\theta}{g}$ and $D = \\frac{2 v_i^2 \\sin\\theta \\cos\\theta}{g} = \\frac{v_i^2 \\sin(2\\theta)}{g}$, which is the standard physics textbook result, or what the AI will tell you if you google \"range equation physics\".\n\nThis allows us to give physics students problems, and get them to calculate things. We also say that the motion of the cannonball is *parabolic*, and a bunch of other stuff that only works if we are talking about spherical cows flying around in vacuum. Anyone who has seen a shot tracer of a golf ball will say that these don't look like the parabolas we all drew back in High School Algebra classes. So what's going on?\n\n![](shotTracer.png){width=50% fig-align=\"center\"}\n\n### Ideal Projectile Motion: Thinking about code\nAt this point, we have fully specified the problem. Any motion is fully specified given the cliff height $H$, launch speed $v_i$, and launch angle $\\theta$. We are done. Computationally, we want to be able to calculate all the important things, and define all of the important functions. I have chosen to use a python *class* to do so. The nice thing about using classes is that you can specify all of the variables for the system, but not have them cluttering the working environment.\n\n::: {#56167dd8 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nclass idealProjectile:\n  '''\n  Does the standard Physics 1 treatment of a projectile on earth for a projectile \n  fired from an elevated position\n  Inputs:\n    vLaunchMag = launch speed in m/s\n    vLaunchDir = launch angle measured from horizontal in degrees\n    height = elevation of the position in m\n  Outputs: (All in SI units)\n    tof = time of flight in seconds\n    maxX = range of projectile in m\n    position = function that calculates vector position as a function of time\n    velocity = function that calculates vector velocity as a function of time\n    acceleration = function that calculates vector acceleration as a function of time\n  '''\n  def __init__(self, vLaunchMag, vLaunchDir, height):\n    self.v0 = vLaunchMag\n    theta = np.pi/180*float(vLaunchDir)\n    self.theta = theta\n    self.h = height\n    self.g = 9.81\n    g = self.g\n    v0x = vLaunchMag*np.cos(theta)\n    v0y = vLaunchMag*np.sin(theta)\n    self.tof = (v0y + np.sqrt(v0y**2 + 2*g*height))/g\n    self.maxX = v0x * self.tof\n\n  def position(self, t):\n    v0, theta, g, h = self.v0, self.theta, self.g, self.h\n    v0x = v0*np.cos(theta)\n    v0y = v0*np.sin(theta)\n    x = v0x * t\n    y = h + v0y*t - 1/2 * g * t**2\n    return [x,y]\n  \n  def velocity(self,t):\n    v0, theta, g = self.v0, self.theta, self.g\n    v0x = v0*np.cos(theta)\n    v0y = v0*np.sin(theta)\n    vx = v0x\n    vy = v0y - g*t\n    return [vx,vy]\n\n  def acceleration(self,t):\n    return [0,-self.g]\n```\n:::\n\n\n## Air resistance:  It's a drag.\nWhen we model motion in a fluid, for large, fast objects we can write:\n\n$$\n\\vec{F}_{\\text{air}} = -c \\left|\\vec{v}\\right|\\vec{v} = -c \\sqrt{v_x(t)^2+v_y(t)^2} (v_x(t), v_y(t))\n$$\nwhere the coefficient $c$ is a constant that depends on the size and shape of the object moving through air, as well as the density of the fluid. This model can get more complicated, and [wikipedia](https://en.wikipedia.org/wiki/Drag_(physics)) discusses it further at a reasonably intro-level. But I won't bore you here.\n\nIncluding this in our model for projectile motion allows us to generate new equations of motion, and this can be done for all levels of physics.\n\n$$\n\\begin{align*}\n a_x(t) = \\frac{dv_x}{dt} &= - \\frac{c}{m} \\sqrt{v_x^2+v_y^2} v_x\\\\\n a_y(t) = \\frac{dv_y}{dt} &= -g - \\frac{c}{m} \\sqrt{v_x^2+v_y^2} v_y\\\\\n\\end{align*}\n$$\n\nThese are integrated to find the velocity with the condition: $\\vec{v}_i = (v_i\\cos\\theta, v_i\\sin\\theta) = (v_x(0),v_y(0))$, and we get...an error.\n\n![](error404.jpg){width=30% fig-align=\"center\"}\n\nWell, we can integrate these equations if we use, well, I'll let Katherine Johnson's character from the movie _Hidden Figures_ tell you:\n\n<div style=\"text-align:center\">\n<iframe width=\"400\" height=\"315\" allowfullscreen\n  src=\"https://www.youtube.com/embed/8xPRn9weLYg?si=IgIhM9ozVqNLZxMs\"> \n</iframe> \n</div>\n\nWe won't actually use Euler's method, but instead use the default method in Python's `scipy.integrate.solve_ivp` function - [an application of the Runge-Kutta method](https://doi.org/10.1016/0771-050X(80)90013-3) which is still pretty ancient. (Well, it's older than me!) I won't be going into the details of the method here. \n\nThe level of the class that I'm teaching determines how I proceed from here. If we have an upper level class, students use the numeric integrator of their choice, be it in Mathematica, Matlab, Python, or something else. In an intro class, I walk through Euler (or Euler-Cromer) integration with them. (And they will have seen a 1D implementation of Euler's method before we tackle this 2D version.)\n\n### Thinking about code\nOnce we add the projectile mass $m$, and drag coefficient $c$ to the parameters that we had for the the ideal motion, $H$, $v_i$, and $\\theta$, we have fully specified the problem. Despite the fact that we cannot integrate the equations of motion analytically, we can do so numerically. As before, I have chosen to use a python _class_ to carry this out. Actually, I've created *two* classes to do this.  Let's go into the why for this choice in the next sections.\n\n#### A note about integrating differential equations numerically\nIn physics, we use Newton's laws to generate differential equations governing the motion of a system.  Specifically, we get the acceleration, which is the *second derivative* of position. So if we want the position as a function of time for a system, this is a *_2nd order_* differential equation. However, numerical methods are built on solving *_1st order_* differential equations.[^2]\n\n[^2]: In general, a $n$th order differential equation has a $n$th derivative of a function as the highest order derivative of a function. So the equation $f'(x) = f(x) + 3(f(x))^2$ is a 1st order differential equation in $f(x)$ because it has that function, as well as the first derivative of that function only. And $f''(x) = f(x) + 3(f'(x))^2$ is a 2nd order differential equation.\n\nLet's think about the function $u(t)$ which returns a vector comprised of the position vector combined with the velocity vector.\n\n$$\nu(t) = \\left[x(t), y(t), v_x(t), v_y(t) \\right]\n$$\n\nWe can take the time derivative of this function (I'll use a dot to signify differentiation with respect to time) and express it in terms of the velocity and acceleration\n$$\n\\dot{u}(t) = \\left[\\dot{x}(t), \\dot{y}(t), \\dot{v}_x(t), \\dot{v}_y(t) \\right] = \\left[v_x(t), v_y(t), a_x(t), a_y(t)\\right]\n$$\n\n`dragEOM` is this function $\\dot{u}(t)$ applied to our projectile system.\n\n::: {#ff45e671 .cell execution_count=2}\n``` {.python .cell-code}\nclass dragEOM:\n  '''\n  Equations of motion for projectile system with turbulent drag fired from an elevated position\n  Inputs:\n    vLaunchMag = launch speed in m/s\n    vLaunchDir = launch angle measured from horizontal in degrees\n    height = elevation of the position in m\n    mass = mass of projectile in kg\n    dragCoef = drag coefficient for system in kg/m\n  Outputs:\n    udot = [xdot, ydot, vxdot, vydot]\n    splash = function that returns y coordinate (needed for integration)\n  '''\n  def __init__(self, vLaunchMag, vLaunchDir, height, mass, dragCoef):\n      self.v0 = vLaunchMag\n      theta = np.pi/180*float(vLaunchDir)\n      self.theta = theta\n      self.h = height\n      self.g = 9.81\n      g = self.g\n      self.coef = dragCoef/mass\n      v0x = vLaunchMag*np.cos(theta)\n      v0y = vLaunchMag*np.sin(theta)\n      self.idealTof = (v0y + np.sqrt(v0y**2 + 2*g*height))/g\n      self.u0 = [0, height, v0x, v0y]\n\n  def __call__(self,t,u):\n      g, coef = self.g, self.coef\n      x, y, vx, vy = u\n      xdot, ydot = vx, vy\n      vxdot = -coef * np.sqrt(vx**2 + vy**2) * vx\n      vydot = -g - coef * np.sqrt(vx**2 + vy**2) * vy\n      udot = [xdot, ydot, vxdot, vydot]\n      return udot\n\n  def splash(self,t,u):\n      return u[1]\n\n  splash.terminal = True\n```\n:::\n\n\n#### Getting the motion\nNow that this is done, we can get the motion for this system using the following class:\n\n::: {#b960f04b .cell execution_count=3}\n``` {.python .cell-code}\nfrom scipy.integrate import solve_ivp\n\nclass dragProjectile:\n  '''\n  Equations of motion for projectile system with turbulent drag fired from an elevated position\n  Inputs:\n    vLaunchMag = launch speed in m/s\n    vLaunchDir = launch angle measured from horizontal in degrees\n    height = elevation of the position in m\n    mass = mass of projectile in kg\n    dragCoef = drag coefficient for system in kg/m\n  Outputs:\n    t = vector of time values where the system is solved\n    x, y = vectors of position values matching the time vector above\n    vx, vy = vectors of velocity values matching the time vector above\n    ax, ay = vectors of acceleration values matching the time vector above\n    tof = time of flight \n    maxX = projectile range\n  '''\n  def __init__(self, vLaunchMag, vLaunchDir, height, mass, dragCoef):\n    model = dragEOM(vLaunchMag, vLaunchDir, height, mass, dragCoef)\n    tMax = 2 * model.idealTof\n    tVals = np.linspace(0,tMax,100)\n    u0 = model.u0\n    sol = solve_ivp(model, t_span=[0,tMax], y0 = u0, t_eval=tVals, events=model.splash, dense_output=True)\n    self.tof = sol.t_events[0][0]\n    self.maxX = sol.y_events[0][0][0]\n    self.t = sol.t\n    self.x = sol.y[0, :]\n    self.y = sol.y[1, :]\n    self.vx = sol.y[2, :]\n    self.vy = sol.y[3, :]\n    udot = model(sol.t, sol.y)\n    self.ax = udot[2]\n    self.ay = udot[3]\n```\n:::\n\n\n## Comparing motion with/without air resistance\nNow that we have these tools built, we can start to visualize this motion. I'll do this using some functions in my `projectile.py` file to make graphs. I will also include the following numerical values:\n\n- $H = 100$ m\n- $v_i = 100$ m/s\n- $\\theta = 30$ deg\n- $m = 1$ kg\n- $c = 0.003$ kg/m\n\n::: {#9f3eee78 .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom projectile import *\n\nH = 100\nvi = 100\ntheta = 30\nm = 1\nc = 0.003\n```\n:::\n\n\nI will visualize this motion in two ways. First, I'll plot each quantity of the motion (position, velocity, acceleration) vs. time. \n\n::: {#571bcd64 .cell width='75%' execution_count=5}\n``` {.python .cell-code}\nplotCannonCurves(vi,theta,H,m,c)\n```\n\n::: {.cell-output .cell-output-display}\n![](projectileMotionWithDrag_files/figure-html/cell-6-output-1.png){width=674 height=674 fig-align='center'}\n:::\n:::\n\n\nNow I will plot the trajectory (y-coordinate vs x-coordinate).\n\n::: {#6c63ef01 .cell width='75%' execution_count=6}\n``` {.python .cell-code}\nmakeTrajectoryPlot(vi,theta,H,m,c)\n```\n\n::: {.cell-output .cell-output-display}\n![](projectileMotionWithDrag_files/figure-html/cell-7-output-1.png){width=805 height=488 fig-align='center'}\n:::\n:::\n\n\n### When should we consider air resistance?\nSince we are usually most concerned with where the projectile will land (have to hit the pirates storming the fort...) let's design a metric for quantifying the difference between the models with/without air resistance. Since I used $D$ to denote the range, I will write $D_1$ to denote the range for model 1 (no air resistance) and $D_2$ to denote the range for model 2 (with air resistance). Therefore the quantity below is the fractional difference between the targeting location of the models.\n\n$$\n\\delta_D = \\frac{\\left|D_1 - D_2\\right|}{D_1}\n$$\n\nI would also like to calculate a similar quantity related to the time-of-flight\n\n$$\n\\delta_T = \\frac{\\left|T_1 - T_2\\right|}{T_1}\n$$\n\nI will calculate these quantities for a range of launch velocities, masses, and launch angles keeping the cliff height $(H=100 \\,\\text{m})$ and drag coefficient $(c=0.003 \\,\\text{kg/m})$ the same as it was before.\n\n::: {#3be5fda2 .cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\nimport matplotlib.colors as mc\nimport matplotlib.cm as cm\n\nlaunchVelocities = np.linspace(0,1000,20)\nlaunchAngles = np.arange(0,89,5)\nmasses = np.linspace(0.1,100,20)\nnv = len(launchVelocities)\nna = len(launchAngles)\nnm = len(masses)\ndeltaD = np.empty(shape=(nv,na,nm))\ndeltaT = np.empty(shape=(nv,na,nm))\nfor i in range(nv):\n  for j in range(na):\n    for k in range(nm):\n      lv = launchVelocities[i]\n      la = launchAngles[j]\n      mm = masses[k]\n      m1 = idealProjectile(lv,la,H)\n      m2 = dragProjectile(lv,la,H,mm,c)\n      D1 = m1.maxX\n      D2 = m2.maxX\n      T1 = m1.tof\n      T2 = m2.tof\n      deltaT[i,j,k] = np.abs(T1 - T2)/T1\n      if D1<1 and D2 <1:\n        # For small ranges (less than 1 meter from the cliff), just set the \n        # fractional difference equal to zero\n        deltaD[i,j,k] = 0\n      else:\n        deltaD[i,j,k] = np.abs(D1 - D2)/D1\n\n# Set up properties of the color bar \ncnorm = mc.Normalize(vmin=0,vmax=1)\ncbar = cm.ScalarMappable(norm=cnorm)\n\n# Arrange the calculations into multiple grids for making a heatmap/contour plot\nX1, Y1 = np.meshgrid(launchVelocities, launchAngles)\nZ1 = deltaD[:, :, nm//2].transpose()\nZZ1 = deltaT[:, :, nm//2].transpose()\n\nX2, Y2 = np.meshgrid(launchVelocities, masses)\nZ2 = deltaD[:, na//2, :].transpose()\nZZ2 = deltaT[:, na//2, :].transpose()\n\nX3, Y3 = np.meshgrid(launchAngles, masses)\nZ3 = deltaD[nv//2, :, :].transpose()\nZZ3 = deltaT[nv//2, :, :].transpose()\n```\n:::\n\n\nNow, let's examine the range:\n\n::: {#998c5275 .cell width='90%' execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nfig1, ax1 = plt.subplots(1,3,figsize=(7,4))\nfig1.suptitle(\"Comparing predicted range with/without air resistance\")\nCS = ax1[0].contourf(X1,Y1,Z1,100)\nax1[0].set_title(f'Mass = {masses[nm//2]:.2f} kg',size=10)\nax1[0].set_xlabel('Launch velocity (m/s)')\nax1[0].set_ylabel('Launch angle (deg)')\nax1[1].contourf(X2,Y2,Z2,100)\nax1[1].set_title(f'Launch angle = {launchAngles[na//2]:.0f} deg',size=10)\nax1[1].set_xlabel('Launch velocity (m/s)')\nax1[1].set_ylabel('Mass (kg)')\nax1[2].contourf(X3,Y3,Z3,100)\nax1[2].set_title(f'Launch velocity = {launchVelocities[nv//2]:.0f} m/s',size=10)\nax1[2].set_xlabel('Launch angle (deg)')\nax1[2].set_ylabel('Mass (kg)')\nfig1.subplots_adjust(bottom=0.3,wspace=0.45,right=0.9)\ncbar_ax = fig1.add_axes([0.2, 0.15, 0.65, 0.02])\nfig1.colorbar(cbar, cax=cbar_ax,label=r'$\\delta_D$',orientation='horizontal')\nghLogo = u\"\\uf09b\"\nliLogo = u\"\\uf08c\"\ntxt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\nplt.figtext(0.6,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](projectileMotionWithDrag_files/figure-html/cell-9-output-1.png){width=650 height=395 fig-align='center'}\n:::\n:::\n\n\nAreas where the color is yellow shows a high level of disagreement between motion in vacuum vs. motion in air. Areas where the color is blue/violet shows a low level of disagreement between the models. Since air resistance is dependent on speed, we would expect that at low speeds, air resistance is less important. And this is what we see in these plots--note the deep blue color in the first 2 panels along the y axis (where the launch velocity is small). This should make sense. Also we note that with large masses, air resistance is less important as well.\n\nFinally, examine the Time of Flight:\n\n::: {#bb6433d3 .cell width='90%' execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\nfig2, ax2 = plt.subplots(1,3,figsize=(7,4))\nfig2.suptitle(\"Comparing predicted TOF with/without air resistance\")\nCS = ax2[0].contourf(X1,Y1,ZZ1,100)\nax2[0].set_title(f'Mass = {masses[nm//2]:.2f} kg',size=10)\nax2[0].set_xlabel('Launch velocity (m/s)')\nax2[0].set_ylabel('Launch angle (deg)')\nax2[1].contourf(X2,Y2,ZZ2,100)\nax2[1].set_title(f'Launch angle = {launchAngles[na//2]:.0f} deg',size=10)\nax2[1].set_xlabel('Launch velocity (m/s)')\nax2[1].set_ylabel('Mass (kg)')\nax2[2].contourf(X3,Y3,ZZ3,100)\nax2[2].set_title(f'Launch velocity = {launchVelocities[nv//2]:.0f} m/s',size=10)\nax2[2].set_xlabel('Launch angle (deg)')\nax2[2].set_ylabel('Mass (kg)')\nfig2.subplots_adjust(bottom=0.3,wspace=0.45,right=0.9)\ncbar_ax = fig2.add_axes([0.2, 0.15, 0.65, 0.02])\nfig2.colorbar(cbar, cax=cbar_ax,label=r'$\\delta_D$',orientation='horizontal')\nghLogo = u\"\\uf09b\"\nliLogo = u\"\\uf08c\"\ntxt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\nplt.figtext(0.6,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](projectileMotionWithDrag_files/figure-html/cell-10-output-1.png){width=650 height=395 fig-align='center'}\n:::\n:::\n\n\n",
    "supporting": [
      "projectileMotionWithDrag_files"
    ],
    "filters": [],
    "includes": {}
  }
}