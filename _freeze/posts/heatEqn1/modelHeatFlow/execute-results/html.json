{
  "hash": "befbb93caab1bfa95fc3507692cd26fd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Modeling Heat Flow\"\ndescription: \"Why is my house so darn hot?\"\nauthor: \"Steven Wolf\"\ndate: \"11/1/2024\"\nresources: \n  - heatboxViz.gif\ncategories:\n  - Heat Equation\n  - Python\n  - Modeling\nexecute: \n  messages: false\n  warning: false\njupyter: python3\ndraft:\n  true\n---\n\n\n## Brief background\nI have a house, and I need to improve the heating/cooling in it. As I go through this series, I'll go into more detail. Essentially, the problem is that my house is a long and narrow, and the air return is:\n\n1. Not well located.\n2. Not able to draw from one end of the house.\n\nAs a result, half of my house is really hot in the summer/extra chilly in the winter. There is some ducting in place, but it doesn't draw air and it is located in a bedroom rather than the room which has the largest temperature problem. I'm planning on installing a duct fan. Before I do that, I'm trying to figure out two things:\n\n1. Will the existing return be enough to alleviate the problem?\n2. If the answer to the previous question is no, where should I put another vent to make a difference?\n\nI figure I can use my physics brain, and a little code to figure out how to solve this problem. So I'm going to spend some time figuring out how to implement the heat equation with appropriate boundary conditions applying them to scenarios that are progressively more complex, until I feel that I can apply them to my own house.\n\n## Heat Equation\nThe heat equation is:\n\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2u\n$$\n\nwhere $u = u(x,y,z,t)$ is a function describing the temperature at every point in space and time in the region of interest and $\\alpha$ is the Thermal Diffusivity of the material (which can depend on position as well).  There are many boundary conditions that can be applied, but I will apply _Robin Conditions_ which generally apply to convection/conduction.\n\n$$\nk \\left. \\frac{\\partial u}{\\partial n}\\right|_{\\Omega} = h \\left(u(\\Omega,t) - v(\\Omega, t)\\right)\n$$\n\nHere $n$ is the direction of the outward normal of the boundary surface, $\\Omega$ indicates spatial points on the boundary surface, $k$ is the thermal conductivity, $h$ is the heat transfer coefficient, and $v$ is the temperature on the other side of the boundary.\n\n#### Aside: Convection/Conduction or Radiation?\nIt occurs to me that we should treat the box as a blackbody. We generally talk about blackbody radiation for hot things like stars. (The first time I encountered blackbody radiation was in an astronomy course.) I'll assume we can ignore it for now-- if not, the boundary condition will have to describe blackbody radiation:\n\n$$\nk \\left. \\frac{\\partial u}{\\partial n}\\right|_{\\Omega} = \\epsilon\\sigma \\left(u(\\Omega,t)^4 - v(\\Omega, t)^4\\right)\n$$\n\nwhere $\\epsilon$ is the emissivity of the blackbody (a number between 0 and 1), and $\\sigma = 5.67\\times 10^{-8} \\frac{\\text{W}}{\\text{m}^2\\text{K}^4}$ is the Stefan-Boltzmann constant.  I'll assume that I can ignore this for now, but will come back to this at a later time.\n\n## Simple system\nAs a \"simple\" 3D system, I'll model a [\"hot box\" or \"sweatbox\" used by some for torture](https://en.wikipedia.org/wiki/Box_(torture)). This is not, nor should it be construed as an endorsement of torture. It's just a simple box, and it gives me some intuitive knobs to use as I work this problem. I will model this as a box with length $L$, width $W$, and height $H$. I'll orient my coordinate system so that the origin is in a lower corner and points $(x,y,z)$ in the region of interest are bounded by the following: $0\\leq x\\leq L$, $0\\leq y \\leq W$, and $0\\leq z \\leq H$.  \n\n::: {#fddb2b03 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Length and time parameters (meters)\nL = 2\nW = 1\nH = 1\noneDay = 24*60*60 # seconds\nT = 30*oneDay # Let this run for several days\n```\n:::\n\n\n### Thermal properties of the box\nI will assume that the box is uniform. That means no windows or ventilation. So $h$ and $k$ are constant and uniform on the boundary.  According to Wikipedia, the thermal diffusivity of air is $1.9\\times 10^{-7}$ m$^2$/s. According to [this article by Jayamaha *et.al.*](https://doi.org/10.1016/0360-1323(96)00014-5), the heat transfer coefficient for walls varies from 6 to 10 W/m$^2$K.  Looking at the [greenspec.co.uk website](https://www.greenspec.co.uk/building-design/insulation-materials-thermal-properties/) it would seem that most thermal conductivities are on the order of 0.04 W/m K.\n\n::: {#95c2a148 .cell execution_count=2}\n``` {.python .cell-code}\n# Heat parameters\nalpha = 1.9e-7 # meters^2/s for air\nh = 10 # From Jayamaha\nk = 0.04 # From Greenspec\n```\n:::\n\n\n### Modeling exterior temperature\n\nI'm going to assume the air temperature is time-dependent, and takes the form:\n\n$$\nv^{\\text{air}}(t) = T_0 - \\Delta T \\cos\\left(\\Omega t\\right)\n$$\n\nwhere $T_0$ is the average temperature of the day, and $\\Delta T$ represents the range of temperature.  On the ground, I'll assume the temperature is constant at $T_G$. So $t=0$ is sunrise. Making these parameters functions is overkill for now, but will be helpful as I get more complicated.\n\n::: {#505410c6 .cell execution_count=3}\n``` {.python .cell-code}\n# Temperature parameters\nT0 = 33\nDT = 6\nTG = 30\n\ndef vair(T0,DT,t):\n  Omega = 2*np.pi/oneDay\n  vair = T0 - DT * np.cos(Omega * t)\n  return vair\n\ndef vground(TG, t):\n  return TG\n```\n:::\n\n\n## Making this model computational\nEssentially, the basis for all numerical methods involving systems that evolve in space and time is to replace continuous space and time values with a discrete mesh. For this system, we are looking for the temperature at every location in space and time. So we will do this on a reduced space/time grid. Instead of having a function of $(x,y,z,t)$ we will have a 4-dimensional matrix that I will denote as follows:\n\n$$\nu(x,y,z,t) \\rightarrow u(x_i,y_j,z_k,t_l) = u^l_{ijk}\n$$\n\nFor this I will define:\n\n$$\n\\begin{align*}\nx_i &= i \\Delta x \\\\\ny_j &= j \\Delta y \\\\\nz_k &= k \\Delta z \\\\\nt_l &= l \\Delta t \\\\\n\\end{align*}\n$$\n\nwhere $\\Delta x, \\Delta y, \\Delta z,$ and $\\Delta t$ are computational choices.  Indeed, this freedom will allow me to choose $\\Delta x = \\Delta y = \\Delta z$. I will choose $\\Delta x = 5$ cm and $\\Delta t = 15$ minutes. I'll also define the max indices for this system, and also set up values for the grid. I will also set up the $u^l_{ijk}$ grid, and fill it with a constant value\n\n::: {#18c6e22e .cell execution_count=4}\n``` {.python .cell-code}\n# Computational parameters (time step and mesh size)\nDeltat = 60*15 # 15 minutes in seconds\nDeltax = 0.05  # 5 cm in meters\n\nxmax = int(L/Deltax)\nymax = int(W/Deltax)\nzmax = int(H/Deltax)\ntmax = int(T/Deltat)\n\nxmid = xmax // 2\nymid = ymax // 2\nzmid = zmax // 2\n\nt = np.linspace(0,T,tmax)\nxgrid = np.linspace(0,L,xmax+1)\nygrid = np.linspace(0,W,ymax+1)\nzgrid = np.linspace(0,H,zmax+1)\n\n# Initialize the temperature array\nu = np.empty((tmax,xmax,ymax,zmax))\nu_init = (T0+TG)/2\nu.fill(u_init)\n```\n:::\n\n\n::: {#9e3f4cdc .cell execution_count=5}\n``` {.python .cell-code}\n# Computational parameters (time step and mesh size)\nDeltat = 60*15 # seconds\nDeltax = 0.05\n\n# Calculated parameters\ngamma = alpha*Deltat/Deltax**2\nbeta = h*Deltax/k\nbetaG = 10*beta\n\n# Initialize the array\nu = np.empty((tmax,xmax,ymax,zmax))\nu_init = (T0+TG)/2\nu.fill(u_init)\n```\n:::\n\n\n### Applying the Finite difference method to the boundary condition\n\nThe boundary condition for conduction/convection states that the gradient of the temperature function at the boundary is proportional to the temperature difference across that boundary. For example on the surface where $x=0$ (or $i=0$), the outward normal direction is in the $-x$ direction:\n$$\n\\left. k\\frac{\\partial u}{\\partial x}\\right|_{x=0} = h(u(x=0,y,z,t) - v(x=0,y,z,t))\n$$\nI will apply the [finite difference method](https://en.wikipedia.org/wiki/Finite_difference_method) to find the spatial derivatives.\n$$\n\\begin{align*}\n\\frac{\\partial u}{\\partial x} &= \\frac{u^l_{i+1 jk}-u^l_{ijk}}{\\Delta x}   \\\\\n\\frac{\\partial u}{\\partial y} &= \\frac{u^l_{ij+1 k}-u^l_{ijk}}{\\Delta y}   \\\\\n\\frac{\\partial u}{\\partial z} &= \\frac{u^l_{ijk+1}-u^l_{ijk}}{\\Delta z}   \\\\\n\\end{align*}\n$$\n\nTherefore, for $i=0$ (the $x=0$ boundary) we get:\n$$\nu^l_{1jk} - u^l_{0jk} = \\frac{h\\Delta x}{k} \\left(u^l_{0jk} - v^l_{jk}\\right)\n$$\nSolve for $u^l_{0jk}$:\n$$\nu^l_{0jk} = \\frac{u^l_{1jk} + \\beta v^l_{jk}}{1+\\beta}\n$$\n\nwhere I have defined:\n$$\n\\beta = \\frac{h \\Delta x}{k}\n$$\nNote that if $\\beta = 0$ boundary has an infinite thermal conductivity and $u^l_{0jk} = u^l_{1jk}$ or $\\frac{\\partial u}{\\partial n} = 0$.  This is the *Neumann Boundary Condition*.  If $\\beta\\rightarrow\\infty$, we find $u^l_{0jk} = v^l_{jk}$ and the temperature at the boundary is equal to the exterior temperature. This is the *Dirichelet Boundary Condition*.\n\nPlugging in some numbers, I'll assume that the proportionality constant $\\beta$ for heat exchange with the ground is 10 times larger than the same constant for heat exchange with the air.\n\nLet's put this into code and apply the boundary condition to the initial array:\n\n::: {#3176d9a1 .cell execution_count=6}\n``` {.python .cell-code}\nbeta = h*Deltax/k\nbetaG = 10*beta\n\ndef applyBC(u, l):\n  t = l*Deltat\n  u[l, 0, :, :] = (u[l, 1, :, :] + beta * vair(T0,DT,t))/(1+beta)\n  u[l, xmax-1, :, :] = (u[l, xmax-2, :, :] + beta * vair(T0,DT,t))/(1+beta)\n  u[l, :, 0, :] = (u[l, :, 1, :] + beta * vair(T0,DT,t))/(1+beta)\n  u[l, :, ymax-1, :] = (u[l, :, ymax-2, :] + beta * vair(T0,DT,t))/(1+beta)\n  u[l, :, :, 0] = (u[l, :, :, 1] + betaG * vground(TG,t))/(1+betaG)\n  u[l, :, :, zmax-1] = (u[l, :, :, zmax-2] + beta * vair(T0,DT,t))/(1+beta)\n  \n  return u\n  \nu = applyBC(u, 0)\n```\n:::\n\n\n### Applying the finite difference method to $\\dot{u} = \\alpha\\nabla^2u$\nI will again apply the [finite difference method](https://en.wikipedia.org/wiki/Finite_difference_method) to find the derivatives. The first derivative in time is:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{u^{l+1}_{ijk} - u^{l}_{ijk}}{\\Delta t} \n$$\n\nAnother aspect of this method is that the Laplacian at any point is the average of the difference between the nearest neighbors of that point and the point itself:\n$$\n\\nabla^2 u(x,y,z,t) = u^l_{i+1 jk} + u^l_{i-1 jk} + \n    u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \n$$\n\nThe heat equation becomes:\n$$\nu^{l+1}_{ijk} = u^l_{ijk} + \\frac{\\alpha \\Delta t}{\\Delta x^2}\n    \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n$$\nBasically, this equation gives us a method for finding the temperature after a time step given the temperature at the previous time step.  I will define the dimensionless constant \n\n$$\n\\gamma = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n$$\nso we finally obtain:\n$$\nu^{l+1}_{ijk} = u^l_{ijk} + \\gamma \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} + \n      u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n$$\n\nNow I will convert this to code:\n\n::: {#ee1957d5 .cell execution_count=7}\n``` {.python .cell-code}\ngamma = alpha*Deltat/Deltax**2\ndef calcHeatEqn(u):\n    tmax, xmax, ymax, zmax = u.shape\n    for l in range(0,tmax-1):\n        for i in range(1, xmax-1):\n            for j in range(1, ymax-1):\n                for k in range(1, zmax-1):\n                    u[l+1,i,j,k] = u[l,i,j,k] + gamma * (u[l,i+1,j,k] + u[l,i-1,j,k] + u[l,i,j+1,k] + u[l,i,j-1,k] + u[l,i,j,k+1] + u[l,i,j,k-1] - 6 * u[l,i,j,k])\n                    \n        # Apply BCs\n        u = applyBC(u, l+1)\n    \n    return u\n```\n:::\n\n\n### Visualizing the temperature:\nThe grid will probably be too fine to visualize well on a 3d heatmap. So I'll settle for some cross sections:\n\n::: {#f5880a80 .cell execution_count=8}\n``` {.python .cell-code}\ndef plotheatmaps(u,l,i,j,k):\n  Tmin = np.min([u.min(),T0-DT])\n  Tmax = np.max([u.max(),T0+DT])\n  \n  xSlice = u[l,i,:,:].transpose()\n  ySlice = u[l,:,j,:].transpose()\n  zSlice = u[l,:,:,k].transpose()\n  \n  time = Deltat*l\n  tMins = time // 60\n  theMinutes = tMins % 60\n  \n  tHours = tMins // 60\n  theDays = tHours // 24\n  theHours = tHours % 24\n  \n  theTime = str(theDays) + \" days \" + str(theHours) + \" hrs \"  + str(theMinutes) + \" min\"\n\n  xC, yC, zC = [Deltax*i, Deltax*j, Deltax*k]\n  \n  fig, (ax0,ax1,ax2) = plt.subplots(ncols=3,width_ratios=[ymax,xmax,xmax],\n              figsize=(8,3))\n    \n  fig.suptitle(f\"Heatbox Temp at {theTime} \\n Outdoor Temp = {vair(T0,DT,time):.2f} C \\n Ground Temp = {vground(TG,time):.0f} C\")\n    \n  im0 = ax0.pcolormesh(ygrid, zgrid, xSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax0.set_aspect(1)\n  ax0.set_title(f\"x = {xC:.3f} m\")\n  ax0.set_xlabel(\"y\")\n  ax0.set_ylabel(\"z\")\n\n  im1 = ax1.pcolormesh(xgrid, zgrid, ySlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax1.set_aspect(1)\n  ax1.set_title(f\"y = {yC:.3f} m\")\n  ax1.set_xlabel(\"x\")\n  ax1.set_ylabel(\"z\")\n  \n  im2 = ax2.pcolormesh(xgrid, ygrid, zSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax2.set_aspect(1)\n  ax2.set_title(f\"z = {zC:.3f} m\")\n  ax2.set_xlabel(\"x\")\n  ax2.set_ylabel(\"y\")\n  \n  fig.tight_layout()\n  \n  cax = fig.add_axes([ax0.get_position().x0,ax0.get_position().y0-0.2,\n                ax2.get_position().x1 - ax0.get_position().x0, 0.02])\n  fig.colorbar(im2, cax = cax, orientation='horizontal')\n```\n:::\n\n\nSo the initial condition has the following heatmap:\n\n::: {#6bd890d0 .cell execution_count=9}\n``` {.python .cell-code}\nplotheatmaps(u,0,xmid,ymid,zmid)\n```\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-10-output-1.png){width=757 height=322}\n:::\n:::\n\n\n## Computational results:\nFinally, we will compute the time evolution of the temperature for about a month.\n\n::: {#943e1305 .cell execution_count=10}\n``` {.python .cell-code}\nu = calcHeatEqn(u)\n```\n:::\n\n\n### Compare interior temperature to exterior temp\nI'm going to plot the external (air) temperature and compare it to the average temperature in the box, as well as consider the average temperature in horizontal slices as the change in time.\n\n::: {#fc89b7e0 .cell execution_count=11}\n``` {.python .cell-code}\nairTemp = np.zeros(tmax)\ngroundTemp = np.zeros(tmax)\nboxTemp = np.zeros(tmax)\nbTerr = np.zeros(tmax)\nboxTempZ = np.zeros((tmax,zmax))\nbtzErr = np.zeros((tmax,zmax))\nfor l in range(tmax):\n  airTemp[l] = vair(T0,DT,t[l])\n  groundTemp[l] = vground(TG,t[l])\n  ul = u[l, :, :, :]\n  boxTemp[l] = np.mean(ul)\n  bTerr[l] = np.std(ul)\n  for k in range(zmax):\n    ulk = ul[:,:,k]\n    boxTempZ[l,k] = np.mean(ulk)\n    btzErr[l,k] = np.std(ulk)\n\nplt.figure(figsize=(6.5,4))\nplt.plot(t,airTemp,label=\"Air Temp\",ls='dashed',linewidth=1)\nplt.errorbar(t,boxTemp,yerr=bTerr, label=\"Avg. Box Temp\",linewidth=5,\n  capsize=2, errorevery=24)\nplt.xlabel('Time (s)')\nplt.ylabel('Temperature (deg C)')\nfor k in reversed(range(0,zmax,zmax//5)):\n    zval = k*Deltax\n    labString = f\"Avg Temp at z={zval:.2f} m\"\n    plt.errorbar(t,boxTempZ[:,k],yerr=btzErr[:,k], label=labString, linewidth=0.5,\n    capsize=2, errorevery=24)\n    \nplt.plot(t,groundTemp,label=\"Ground Temp\",ls=\"dashed\",linewidth=1)\nplt.legend(loc=\"center left\", bbox_to_anchor=(1.04,0.5))\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-12-output-1.png){width=773 height=356}\n:::\n:::\n\n\nJust to see that this is stabilizing, and to get an idea of how fast this stabilizes, I'm going to find a daily average temperature as above.\n\n::: {#1d8caace .cell execution_count=12}\n``` {.python .cell-code}\nstepsInDay = int(oneDay/Deltat)\ndays = int(T/oneDay)\nday = np.arange(0,days)\n\nboxTempDay = np.zeros(days)\nbtdErr = np.zeros(days)\nboxTempDayZ = np.zeros((days,zmax))\nbtdzErr = np.zeros((days,zmax))\nfor d in range(days):\n    lmin = int(d*stepsInDay)\n    lmax = int((d+1)*stepsInDay)\n    ul = u[lmin:lmax, :, :, :]\n    boxTempDay[d] = np.mean(ul)\n    btdErr[d] = np.std(ul)\n    for k in range(zmax):\n        ulk = ul[:,:,:,k]\n        boxTempDayZ[d,k] = np.mean(ulk)\n        btdzErr[d,k] = np.std(ulk)\n\nplt.figure(figsize=(6.5,4))\nplt.errorbar(day,boxTempDay,yerr=btdErr, marker='o', label=\"Avg. Box Temp\",capsize=2)\nplt.xlabel('Time (days)')\nplt.ylabel('Temperature (deg C)')\nfor k in reversed(range(0,zmax,zmax//5)):\n    zval = k*Deltax\n    labString = f\"Avg Temp at z={zval:.2f} m\"\n    plt.errorbar(day,boxTempDayZ[:,k],yerr=btdzErr[:,k], marker='o', label=labString,\n    capsize=2)\n    \nplt.legend(loc=\"center left\", bbox_to_anchor=(1.04,0.5))\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-13-output-1.png){width=773 height=357}\n:::\n:::\n\n\n### Heatmaps\nLet's view the middle cross sections every few hours on the last day:\n\n::: {#5b7d897b .cell execution_count=13}\n``` {.python .cell-code}\nfor s in range(lmin,lmax,int(stepsInDay/12)):\n  plotheatmaps(u,s,xmid,ymid,zmid)\n```\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-1.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-2.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-3.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-4.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-5.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-6.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-7.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-8.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-9.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-10.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-11.png){width=757 height=322}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modelHeatFlow_files/figure-html/cell-14-output-12.png){width=757 height=322}\n:::\n:::\n\n\n## Summary\n\nThis is working as a proof of concept. Yay, I can model an object using the heat equation. \n\n### Not done yet\nMaybe I need to consider the blackbody radiation boundary conditions. We generally talk about blackbody radiation in Astronomy to describe the radiation from stars. However, there are terrestrial applications, and this may be one of them.\n\n### My future plans:\nI'm going to consider the questions above as I seek to make this model more complex. I plan to do things that will slowly make my boring box look more like my house.\n\n- Add a window\n- Make the ambient temperature higher on the sunny side.  (This could be a partial solution for considering the radiation BCs)\n- Make this house/hut sized and add a wall. \n- Add in heating and cooling.\n\n",
    "supporting": [
      "modelHeatFlow_files"
    ],
    "filters": [],
    "includes": {}
  }
}