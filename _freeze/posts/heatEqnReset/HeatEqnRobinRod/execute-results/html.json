{
  "hash": "107e698ab30041f2db87c2009b591899",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Using the Heat Equation to model a real-world system (Part 4)\"\ndescription: \"Bringing a nuke to a fist-fight\"\nauthor: \"Steven Wolf\"\ndate: \"07/24/2025\"\nnumber-sections: false\ncategories:\n  - Heat Equation\n  - Modeling\n  - Bringing a nuke to a fist-fight\nexecute: \n  messages: false\n  warning: false\njupyter: python3\ndraft:\n    true\n---\n\n\n\n## Modeling a 1D Unit Rod with convection \n\nI'm still getting used to the FEniCSx software, so I'm going to go through the process of modeling a 1D rod, using Robin boundary conditions, and heavily annotating my code. This is (finally?) getting closer to a \"real world\" system, as it has the correct boundary condition describing convection. But it is still a 1D rod so, your mileage may vary.\n\n### Setting up the problem\n\nFirst, I'll load in all of the dependencies required.  There are a few \"families\" of dependencies that I'm including. These are:\n\n1. `numpy` and `matplotlib` because they are standard python tools for dealing with tabular data and graphics\n2. `petsc4py` and `mpi4py` are libraries often used in FEniCSx code because they support parallelization and speed up computation.\n3. `dolfinx` is the package that I'm using to set up the Finite Element Method (part of FEniCSx)\n4. `ufl` is a package with FEniCSx that translates a more convential mathematical notation into forms required by `dolfinx`. I like it when code \"looks like\" math/physics. (That's why I teach students how to create cell names and named ranges when using Excel.)\n\n::: {#bcb941f6 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nfrom petsc4py import PETSc\nfrom mpi4py import MPI\n\nfrom dolfinx import default_scalar_type, io \nfrom dolfinx.fem import (Constant,  Function, functionspace, form)\nfrom dolfinx.fem.petsc import (LinearProblem, assemble_matrix, create_vector, \n                               assemble_vector, apply_lifting, set_bc)\nfrom dolfinx.mesh import create_interval, locate_entities, meshtags\nfrom ufl import (SpatialCoordinate, inner, ds, dx, Measure, TrialFunction, TestFunction, grad)\n```\n:::\n\n\n#### Constant Parameters:\nNone of these will have units because I'm living in a willy-nilly world without units. (For now).\n\n- $T_0 = 10$ uniform initial temperature for the rod.\n- $T_\\text{ext} = 0$ uniform and constant temperature of the surroundings.\n- $h = 0.5$ \"Heat conduction\" coefficient between rod and surroundings\n- $\\kappa = 1$ \"Thermal conductivity\" of rod\n- The simulation will run for 5 DataWolfs (my new, made up dimensionless time unit)\n- $dt = 0.1$ Time step size.\n- $L = 1$ rod \"length\"\n\n::: {#4234b8e2 .cell execution_count=2}\n``` {.python .cell-code}\nt = 0 \nfinal_time = 5.0  # Final time for the simulation\ndt = 0.1  # Time step size\nnum_steps = int((final_time - t) / dt)  \nT0 = 10.0  # Initial uniform temperature of the rod\nextTemp = 0.0  # External temperature at the boundaries (constant)\ntPlot = np.linspace(0, final_time, num_steps+1)  # Time points for plotting\n\n# Define the mesh and function space\nn_elements = 32\n# Create a 1D domain representing the rod from 0 to 1\ndomain = create_interval(\n    MPI.COMM_WORLD,  # MPI communicator\n    n_elements,  # Number of elements in the mesh\n    [0.0, 1.0]  # Interval from 0 to 1 (the length of the rod)\n)\n\nx = SpatialCoordinate(domain)  # Spatial coordinates of the domain\ntempExt = lambda x: extTemp  # External temperature function (constant in this case)\ns = tempExt(x)  # External temperature at the boundary\nf = Constant(domain, PETSc.ScalarType(0))  # Source term (zero in this case)\nh = Constant(domain, PETSc.ScalarType(0.5))  # Robin boundary condition coefficient\nkappa = Constant(domain, PETSc.ScalarType(1.0))  # Thermal conductivity\n```\n:::\n\n\n### Set up the initial condition\nWe will create a function space that assumes linear elements between the grid degrees of freedom. This is the Galerkin method I talked about previously, where the basis functions are linear functions localized near each of the mesh points:\n$$\n\\varphi_i = \n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_i\\right|}{h} \\right) &\\left|x-x_i\\right|\\leq h \\\\\n0 & \\text{else}\n\\end{cases}\n$$\n\nI will create two functions in this function space:\n\n- `uPrev` is the solution at the previous time step, representing the $u^{k-1}$ in the linear form.\n- `uWork` is the solution at the current time step, representing the $u^k$ in the bilinear form.\n\n::: {#d6617ee6 .cell execution_count=3}\n``` {.python .cell-code}\n# Create a function space for the finite element method\nV = functionspace( \n    domain, ('Lagrange',1) # Linear Lagrange elements\n)\n\n# Create a constant function for the initial condition\ndef initial_condition(x):\n  return np.full(x.shape[1], T0, dtype=np.float64)  # Initial temperature T0\n\nuPrev = Function(V)\nuPrev.name = \"uPrev\"  # Name the function for clarity\nuPrev.interpolate(initial_condition)  # Interpolate the initial condition into the function space\n\nuWork = Function(V)  # Function to hold the solution at the current time step\nuWork.name = \"uWork\"  # Name the function for clarity \nuWork.interpolate(initial_condition)  # Initialize with the same initial condition\n```\n:::\n\n\n### Define the boundary condition\nWe are using the Robin boundary condition, suitable for describing convection.\n$$\n-\\kappa \\left(\\hat{n}\\cdot\\nabla\\right) u^k = h^k(u^k - s^k) \\quad \\forall x\\in\\{0,1\\}\n$$\n\nThe code below starts with a python version of the above definition of where the boundary is, and then uses an automated process to convert that into a useful definition for `dolfinx`. I'm also defining the measures for integration based on these boundary definitions. Note that Fenics Tutorials usually have at least one surface that has an explicit Dirichlet boundary condition.\n\n::: {#f3e08950 .cell execution_count=4}\n``` {.python .cell-code}\nboundaries = [\n  (1, lambda x: np.isclose(x[0], 0.0)),  # Left boundary located at x=0\n  (2, lambda x: np.isclose(x[0], 1.0))  # Right boundary located at x=1\n]\nfacet_indices, facet_markers = [], []\ntdim = domain.topology.dim\nfdim = tdim - 1  # Dimension of the facets (1D for a rod)\n\nfor (marker, locator) in boundaries:\n    facets = locate_entities(domain, fdim, locator)\n    facet_indices.append(facets)\n    facet_markers.append(np.full_like(facets, marker))\nfacet_indices = np.hstack(facet_indices).astype(np.int32)\nfacet_markers = np.hstack(facet_markers).astype(np.int32)\nsorted_facets = np.argsort(facet_indices)\nfacet_tag = meshtags(domain, fdim, facet_indices[sorted_facets], facet_markers[sorted_facets])\n\nbcs = []  # No Dirichlet boundary conditions, so we leave this empty\ndx = Measure(\"dx\", domain=domain)  # Define the measure for the volume integral\nds = Measure(\"ds\", domain=domain, subdomain_data=facet_tag)  # Define the measure for the boundary integral\n```\n:::\n\n\n### Set up the variational formulation\nAs stated in previous posts, the variational formulation (note: $u^k \\rightarrow u$) for this problem is:\n$$\na(u,v) = L(v)\n$$\nwhere the bilinear form is:\n$$\na(u,v) = \\int_\\Omega uv dx + \\int_\\Omega \\Delta t \\kappa \\nabla u \\cdot \\nabla v dx + \\sum_l \\int_{\\Gamma^R_l} \\frac{\\Delta t}{\\kappa}  u v ds \n$$\nand the linear form (for the Robin condition only) is:\n$$\nL(v) = \\int_\\Omega u^{k-1} v dx + \\int_\\Omega f v dx + \\sum_l \\int_{\\Gamma^R_l} \\Delta t h_l s_l v ds \n$$\nLet's define the trial function `u` and the test function `v` and set up these forms:\n\n::: {#31071466 .cell execution_count=5}\n``` {.python .cell-code}\nu = TrialFunction(V)  # Trial function for the finite element method\nv = TestFunction(V)  # Test function for the finite element method\na = u * v * dx + dt * kappa * inner(grad(u), grad(v)) * dx  + dt * h / kappa * u * v * ds # Bilinear form for the RBC\nL = (uPrev + dt * f) * v * dx + dt * h / kappa * s * v * ds  # Linear form for the RBC\nbilinear_form = form(a)  # Bilinear form for the weak formulation\nlinear_form = form(L)  # Linear form for the weak formulation\n```\n:::\n\n\n### Convert into a Linear Algebra problem\nOne of the reasons that we use the Finite Element method is that computers are pretty good at doing linear algebra operations quickly. So we begin by setting up the linear algebra structures.\n\n::: {#11a8c155 .cell execution_count=6}\n``` {.python .cell-code}\nA = assemble_matrix(bilinear_form, bcs=bcs)  # Assemble the matrix A\nA.assemble()  # Finalize the assembly of the matrix A\nb = create_vector(linear_form)  # Create a vector for the right-hand side\n```\n:::\n\n\nNow let's set up a framework to solve the linear system. Note, the 3rd and 4th lines below are talking about a \"Preconditioner\". I spent some time figuring out what that was all about. It does a LU decomposition, which is a form of Gaussian Elimination (ish). Basically, its all about speeding things up knowing that this is a sparse matrix system (remember, only neighboring elements contribute due to the localization of the basis functions).\n\n::: {#85def988 .cell execution_count=7}\n``` {.python .cell-code}\nsolver = PETSc.KSP().create(domain.comm)\nsolver.setOperators(A)  # Set the matrix A for the solver\nsolver.setType(PETSc.KSP.Type.PREONLY)  # Use a preconditioner\nsolver.getPC().setType(PETSc.PC.Type.LU)  # Use LU preconditioner\n```\n:::\n\n\n### Begin a surface plot:\nI'm going to use a matplotlib surface plot to display my result rather than pyvista. I was playing around on StackExchange and came across a post that complained about why a pyvista version of a plot looked so ugly when matplotlib could do it so easily. The answer was basically, that the poster used pyvista correctly, it just contained data that was on vastly different scales. The answerer said something to the effect of, \"You have to tell PyVista to lie to you.\" My question (at least for now) is, \"How does PyVista know my units are meaningful?\" Since my units are not (yet) meaningful, I'll stick with matplotlib. Plus, I always try to learn only one thing at a time.\n\n::: {#0304cb51 .cell execution_count=8}\n``` {.python .cell-code}\nxMesh = domain.geometry.x[: ,0]\nTc, Xc = np.meshgrid(tPlot, xMesh)  # Create a mesh grid for plotting\nUc = np.zeros_like(Tc)\nUc[:, 0] = uWork.x.array  # Initial condition for plotting\n```\n:::\n\n\n### Advance in time\nNow we need to advance in time, solving the linear system at each time-step. Note that the solver assumes that you are solving the equation:\n$$\nA x = b\n$$\nat each time step, so the linear form needs to be assembled into the vector `b`.\n\n::: {#6dce22be .cell execution_count=9}\n``` {.python .cell-code}\nfor i in range(num_steps):\n    t += dt  # Current time\n\n    # Update the RHS reusing the previous solution\n    with b.localForm() as loc_b:\n        loc_b.set(0.0)\n    \n    assemble_vector(b, linear_form)\n    apply_lifting(b, [bilinear_form], [bcs])  # Apply boundary conditions\n    b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)  # Update ghost values\n    set_bc(b, bcs)  # Set the boundary conditions\n\n    # Solve linear problem\n    solver.solve(b, uWork.x.petsc_vec)\n    # Put the solution in our uWork object\n    uWork.x.scatter_forward()\n\n    # Update the solution at the current time step for plotting\n    Uc[:, i+1] = uWork.x.array\n    \n    # Update solution at previous time step (uPrev)\n    uPrev.x.array[:] = uWork.x.array\n```\n:::\n\n\n### Make a pretty picture\nMake the plot the normal matplotlib way.\n\n::: {#fa443bff .cell execution_count=10}\n``` {.python .cell-code}\nfig, ax = plt.subplots(subplot_kw={'projection': '3d'},figsize=(8,7) ) # Create a 3D plot\nax.plot_surface(Xc, Tc, Uc, cmap='viridis', edgecolor='none')  # Plot the FENICS solution\nax.set_title(rf'$\\kappa = ${kappa.value:.2f}')\nax.set_xlabel('Position along the rod (x)')  # X-axis label\nax.set_ylabel('Time (t)')  # Y-axis label\nax.set_zlabel('Temperature (u)')  # Z-axis label\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.suptitle('Robin Problem for a Unit Rod')  # Overall title for the plot\nplt.subplots_adjust(top=0.9)  # Adjust the top margin to fit\nplt.show()  # Show the plot\n```\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnRobinRod_files/figure-html/cell-11-output-1.png){}\n:::\n:::\n\n\n### Compare the behavior for different heat transfer coefficients\nLet's make this plot to compare with the one I made where I adjusted the heat transfer coefficient on my homemade version of the finite element method.\n\n::: {#b38fe11d .cell execution_count=11}\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnRobinRod_files/figure-html/cell-12-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnRobinRod_files/figure-html/cell-12-output-2.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnRobinRod_files/figure-html/cell-12-output-3.png){}\n:::\n:::\n\n\n## Next steps\nI'm going to add in more dimensions, keeping the Robin condition. Specifically, I'm going to model a 2D sheet and a 3D box that are analogous to the above system. The rationale for this is that I want to start learning how to use `pyvista`, a 3D visualization tool that is used in many FEniCSx tutorials. It seems...unproductive...to use 2D/3D modeling tools to describe 1D systems.\n\nAfter that, I'll need to do two things:\n\n- Go back to the physics and make sure I can do units correctly. This is especially important for dealing with external heat sources.\n- Figure out how to make composite boundaries. Ultimately, I want to model a house, so I need to figure out how I want to create walls, doors, and windows. \n\n",
    "supporting": [
      "HeatEqnRobinRod_files"
    ],
    "filters": [],
    "includes": {}
  }
}