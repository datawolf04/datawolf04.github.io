{
  "hash": "b00e356775847caeff8ff37ec0c26870",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Using the Heat Equation to model a real-world system (Part 2)\"\ndescription: \"Why is this so gosh-darn hard sometimes?\"\nauthor: \"Steven Wolf\"\ndate: \"07/15/2025\"\nnumber-sections: false\ncategories:\n  - Heat Equation\n  - Modeling\n  - Classroom Models vs Real models\n  - Yapping\nexecute: \n  messages: false\n  warning: false\njupyter: python3\ndraft:\n  true\n---\n\n\nIn my last post, I spoke about the issues with modeling a real-world system using the heat equation. Even the simplest 1D system promised some degree of pain. So I wanted to begin discussing numerical methods. I've been going through some materials created by the [fenics project](https://jsdokken.com/dolfinx-tutorial/index.html), and while what I'm presenting below will be somewhat based on those methods, I'm going to skip using their package (for now).\n\n## Applying the Finite Element Method to the 1D Robin problem\nIn my [last post](./HeatEquationReset.qmd), I gave myself the following challenge:\n\n> Your mission, should you choose to accept it, is to model a 1D object that has a length of 1, with a uniform initial temperature $T_0$. The exterior temperature at each end of the rod is 0. Assume no heat escapes along the length of the rod.\n\nLet's apply the Finite Element method to this problem. In general the setup is the same. We have:\n1. The (1D) Heat Equation:\n$$\n\\frac{\\partial u(x,t)}{\\partial t} - \\frac{\\partial^2 u(x,t)}{\\partial x^2} = 0\n$$\n2. The Initial Condition: $u(x,0)=T_0$.\n3. The Boundary conditions, one for each end at $x=0$ and $x=1$\n$$\nu(0,t) + b \\left. \\frac{\\partial u(x,t)}{\\partial x}\\right|_{x=0} = 0 \\qquad \\text{and} \\qquad u(1,t) - b\\left. \\frac{\\partial u(x,t)}{\\partial x}\\right|_{x=1} = 0\n$$\n\n### Step 1: Discretize the time variable.\nInstead of doing separation of variables using the usual analytic methods, we are going to define:\n\n$$\nu^k(x) = u(x,t_k)\n$$\nwhere $t_k = k \\Delta t$. The parameter $\\Delta t$ is something that can be freely chosen, and $k$ is an index $(0,1,2,\\ldots)$. Substituting this in, we can write the following:\n1. The (1D) Heat Equation:\n$$\n\\frac{u^k(x)-u^{k-1}(x)}{\\Delta t} - \\frac{d^2 u^k(x)}{dx^2} = 0\n$$\n2. The Initial condition:\n$$\nu^0(x) = T_0\n$$\n3. The boundary conditions:\n$$\nu^k(0) + b \\left. \\frac{du^k(x)}{dx}\\right|_{x=0} = 0 \\qquad \\text{and} \\qquad u^k(1) - b \\left. \\frac{du^k(x)}{dx}\\right|_{x=1} = 0\n$$\n\n### Step 2: Convert the Heat Equation to a weak formulation\nThis is done by multiplying the PDE by a *test function* $v(x)$ and integrating over the region of interest (in this case, $x\\in[0,1]$).\n$$\n\\int_0^1 v(x) u^k(x) dx - \\Delta t \\int_0^1 v(x) \\frac{d^2u^k(x)}{dx^2} dx = \\int_0^1 v(x) u^{k-1}(x) dx\n$$\n\nWe can now integrate the second term by parts:\n$$\n\\begin{align*}\n\\int_0^1 v(x) \\frac{d^2u^k(x)}{dx^2} dx  &= \\left[ v(x) \\frac{du^k(x)}{dx} \\right]_0^1 - \\int_0^1 \\frac{dv(x)}{dx} \\frac{du^k(x)}{dx} dx \\\\\n  &= \\left[ -v(1) \\frac{u^k(1)}{b}  - v(0) \\frac{u^k(0)}{b} \\right] - \\int_0^1 \\frac{dv(x)}{dx} \\frac{du^k(x)}{dx} dx \\\\\n\\end{align*}\n$$\nwhere the term in square brackets is given by applying the boundary conditions. So now we have two things to keep track of:\n\n1. The Initial condition:\n$$\nu^0(x) = T_0\n$$\n2. The weak formulation of the PDE/boundary condition\n$$\n\\begin{align*}\n\\int_0^1 v(x) u^{k-1}(x) dx = \\int_0^1 v(x) u^k(x) dx &+ \\Delta t \\int_0^1 \\frac{dv(x)}{dx} \\frac{du^k(x)}{dx} dx \\\\\n & + \\frac{\\Delta t}{b} \\left[ v(1) u^k(1) + v(0) u^k(0) \\right]\n\\end{align*}\n$$\nNotice that the LHS of this equation depends on the test function $v(x)$ and the solution of the heat equation at the *previous* time-step $u^{k-1}(x)$.\n\n### Step 3: Discretize the spatial variable\nUltimately, this step will allow us to solve this problem as a linear-algebra problem, which is something that computers have been optimized to do very well. We do this by assuming the following:\n$$\nu^k(x) = \\sum_{j=1}^N u_j^k \\varphi_j(x)\n$$\nwhere $x_j = \\frac{j-1}{N-1}$, $h=\\frac{1}{N}$ and\n$$\n\\varphi_j(x) = \n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_j\\right|}{h}\\right) &\\left|x-x_j\\right|\\leq h \\\\\n0 & \\text{else}\n\\end{cases}\n$$\nThis creates a uniform lattice of points. It should be noted that this choice of $\\varphi_j(x)$ is method dependant. Also, when working in higher dimensions, a cartesian grid is not optimal. But this is what I'll use for this problem.\n\n\n#### Simplify the Initial condition\nLet's insert this definition of $u^k(x)$ into our initial condition, multiply by $\\varphi_i(x)$, and integrate over the region of interest:\n$$\n\\int_0^1 dx \\varphi_i(x) \\sum_{j=1}^N u^0_j \\varphi_j(x) = \\int_0^1 dx \\varphi_i(x) T_0\n$$\nWe can simplify this by calculating the integrals:\n$$\n\\int_0^1 dx \\varphi_i(x) = \n\\begin{cases}\n\\frac{h}{2} &i=1 \\text{ or } i=N \\\\\nh & \\text{else}\n\\end{cases}\n$$\nand\n$$\n\\int_0^1 dx \\varphi_i(x) \\varphi_j(x) = \n\\begin{cases}\n\\frac{h}{3} & (i=j=1) \\text{ or } (i=j=N) \\\\\n\\frac{2h}{3} & (i=j) \\text{ and } (i\\neq 1 \\text{ or } i\\neq N) \\\\\n\\frac{h}{6} & j=i\\pm 1 \\\\\n0 &\\text{else}\n\\end{cases}\n$$\n\nRe-arranging terms, we can find $N$ equations:\n$$\n\\begin{align*}\n2 u_1^0 + u_2^0 = 3 T_0 &\\qquad i=1 \\\\\nu_{i-1}^0 + 4 u_i^0 + u_{i+1}^0 = 6 T_0 &\\qquad i\\neq 1, i\\neq N \\\\\nu_{N-1}^0 + 2u_N^0 = 3 T_0 &\\qquad i=N\n\\end{align*}\n$$\n\nSince the initial temperature is uniform, this (quite sensibly) can be solved as:\n$$\nu_i^0 = T_0\n$$\n\n\n\n#### Simplify the weak formulation\nNext we will simplify the weak formulation describing the PDE and Boundary conditions assuming\n$$\nu^k(x) = \\sum_{j=1}^N u_j^k \\varphi_j(x)\n$$\nand \n$$\nv(x) = \\varphi_i(x)\n$$\n\nPlugging this in we get:\n$$\n\\begin{align*}\n\\sum_{j=1}^N u_j^{k-1} \\int_0^1 dx \\varphi_i(x) \\varphi_j(x) = &\\sum_{j=1}^N u_j^k \\int_0^1 dx \\varphi_i(x) \\varphi_j(x) \\\\\n &+ \\sum_{j=1}^N \\Delta t u_j^k \\int_0^1 dx \\frac{d\\varphi_i(x)}{dx} \\frac{d\\varphi_j(x)}{dx} \\\\\n &+ \\frac{\\Delta t}{b} \\sum_{j=1}^N \\left[ \\varphi_i(1) u^k_j \\varphi_j(1) + \\varphi_i(0) u^k_j \\varphi_j(0) \\right]\n\\end{align*}\n$$\n\nWe can simplify this again, but we will need to consider the integral below in addition to other integrals we have calculated previously.\n$$\n\\int_0^1 dx \\frac{d\\varphi_i(x)}{dx} \\frac{d\\varphi_j(x)}{dx} = \n\\begin{cases}\n\\frac{1}{h} & (i=j=1) \\text{ or } (i=j=N) \\\\\n\\frac{2}{h} & (i=j) \\text{ and } (i\\neq 1 \\text{ or } i\\neq N) \\\\\n-\\frac{1}{h} & j=i\\pm 1 \\\\\n0 &\\text{else}\n\\end{cases}\n$$\n\n\nFinally, we will note that by the definition of our $\\varphi_i(x)$ function, we can simplify the values on the boundary as follows:\n$$\n\\varphi_i(0) = \\delta_{i1} \\qquad \\text{and} \\qquad \\varphi_i(1) = \\delta_{iN}\n$$\n\nThis leaves us with the following system of $N$ equations to solve:\n$$\n\\begin{align*}\n2\\left(1+\\frac{3(b+h)\\Delta t}{bh^2}\\right) u_0^k + \\left(1-\\frac{6\\Delta t}{h^2}\\right)u_1^k &= 2u_0^{k-1} + u_1^{k-1} \\quad i=1 \\\\\n\\left(1-\\frac{6\\Delta t}{h^2}\\right)u_{N-1}^k + 2\\left(1+\\frac{3(b+h)\\Delta t}{bh^2}\\right) u_N^k &= u_{N-1}^{k-1} + 2u_N^{k-1} \\quad i=N \\\\\n\\left(1-\\frac{6\\Delta t}{h^2}\\right)u_{i-1}^k + 4\\left(1+\\frac{3\\Delta t}{h^2}\\right) u_i^k + \\left(1-\\frac{6\\Delta t}{h^2}\\right)u_{i+1}^k &= u_{i-1}^{k-1} + 4u_i^{k-1} + u_{i+1}^{k-1}  \\\\\n &\\qquad i\\neq 1 \\text{ and } i\\neq N \\\\\n\\end{align*}\n$$\n\nThis looks somewhat intimidating, but if we define:\n$$\nA = 2\\left(1+\\frac{3(b+h)\\Delta t}{bh^2}\\right) \\quad B=4\\left(1+\\frac{3\\Delta t}{h^2}\\right) \\quad C=\\left(1-\\frac{6\\Delta t}{h^2}\\right)\n$$\nwe get\n$$\n\\begin{align*}\nA u_0^k + C u_1^k &= 2u_0^{k-1} + u_1^{k-1} &\\quad i=1 \\\\\nC u_{N-1}^k + A u_N^k &= u_{N-1}^{k-1} + 2u_N^{k-1} &\\quad i=N \\\\\nCu_{i-1}^k + B u_i^k + Cu_{i+1}^k &= u_{i-1}^{k-1} + 4u_i^{k-1}  + u_{i+1}^{k-1}&\\quad i\\neq 1 \\text{ and } i\\neq N \\\\\n\\end{align*}\n$$\nWe can turn this into a matrix equation:\n$$\nK U = G\n$$\nwhere $U$ is a $(N\\times 1)$ matrix made up of the $u_i^k$'s, $K$ is (assuming $N=5$)\n\n$$\nK =\n\\begin{bmatrix}\nA & C & 0 & 0 & 0 \\\\\nC & B & C & 0 & 0 \\\\\n0 & C & B & C & 0 \\\\\n0 & 0 & C & B & C \\\\\n0 & 0 & 0 & C & A \n\\end{bmatrix}\n$$\nand $G = G_s u^{k-1}$ is made from the right hand side of the above equation:\n\n$$\nG_s = \n\\begin{bmatrix}\n2 & 1 & 0 & 0 & 0 \\\\\n1 & 4 & 1 & 0 & 0 \\\\\n0 & 1 & 4 & 1 & 0 \\\\\n0 & 0 & 1 & 4 & 1 \\\\\n0 & 0 & 0 & 1 & 2 \n\\end{bmatrix}\n$$\nand\n$$\nu^{k-1} = \n\\begin{bmatrix}\nu^{k-1}_1 \\\\\nu^{k-1}_2 \\\\\nu^{k-1}_3 \\\\\nu^{k-1}_4 \\\\\nu^{k-1}_5 \n\\end{bmatrix}\n$$\n\n## Let's make code!\nLet's make some computational choices and code this up. First, I'll begin by setting up the initial condition.\n\n::: {#4fee5810 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nN = 101\nh = 1/(N-1)\ninitTemp = 10\nxi = np.linspace(0,1,N)\nu0 = initTemp * np.ones(N)\n```\n:::\n\n\nNext, I'll define the matrices on the LHS and RHS of the equation above, as well as a few parameters.\n\n::: {#a83fdbf5 .cell execution_count=2}\n``` {.python .cell-code}\nb = 1\nDt = 0.1\ntMax = 3\ntVals = np.arange(0,tMax, Dt)\n\nA = 2*(1 + 3*Dt*(b+h)/(b*h**2))\nB = 4*(1 + 3*Dt/h**2)\nC = 1 - 6*Dt/h**2\n\n## Left hand side\nK = np.zeros([N,N])\nGsq = np.zeros([N,N])\nfor i in range(1,N-1):\n  K[i,i] = B\n  K[i, i-1] = C\n  K[i, i+1] = C\n  Gsq[i,i] = 4\n  Gsq[i,i-1] = 1\n  Gsq[i,i+1] = 1\n\nK[0, 0:2] = [A, C]\nK[N-1, N-2:] = [C, A]\nGsq[0, 0:2] = [2,1]\nGsq[N-1, N-2:] = [1,2]\n```\n:::\n\n\nPython can find the new u-matrix in terms of the old u matrix in one line:\n\n::: {#913556ef .cell execution_count=3}\n``` {.python .cell-code}\nnewU = np.linalg.solve(K,G)\n```\n:::\n\n\nSo let's build our solution:\n\n::: {#f2070e76 .cell execution_count=4}\n``` {.python .cell-code}\nnSteps = int(tMax/Dt)\nU = np.zeros([N,nSteps])\nfor k in range(nSteps):\n  if(k==0):\n    newU = np.ones(N) * initTemp\n  else:\n    G = np.matmul(Gsq,oldU)\n    newU = np.linalg.solve(K,G)\n  U[:, k] = newU    \n  oldU = newU\n```\n:::\n\n\nAnd let's make a nice 3D plot of the solution:\n\n::: {#c7c87f6f .cell execution_count=5}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nT, X = np.meshgrid(tVals, xi)\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(T,X,U,cmap='magma')\nax.set_xlabel(r'$t$')\nax.set_ylabel(r'$x$')\nax.set_zlabel(r'$u$')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnReset2_files/figure-html/cell-6-output-1.png){}\n:::\n:::\n\n\n## View some solutions:\nNote, that we have a property that can change the dynamics of this system, namely $b$, which is related to the (inverse of the) heat transfer coefficient. For the previous plot $b=1$. Compare to these, where $b=5$ and $b=0.5$:\n\n::: {#38246029 .cell layout-ncol='2' execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnReset2_files/figure-html/cell-7-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnReset2_files/figure-html/cell-7-output-2.png){}\n:::\n:::\n\n\nLet's compare this to the Dirichelet solution from the previous post.\n$$\nu(x,t) = \\sum_{n=1}^{\\infty} \\frac{4T_0}{(2n-1)\\pi}\\sin\\left((2n-1)\\pi x\\right) e^{-(2n-1)^2\\pi^2t}\n$$\nFirst, let's note that the only free parameter here is the initial temperature $T_0$. There is no equivalent to the \"inverse heat transfer coefficient\" $b$ that I defined for the Robin problem.\n\n::: {#e3fd3487 .cell execution_count=7}\n``` {.python .cell-code}\ndef uDirichelet(t,x,T0):\n  uD = 0\n  for n in range(100):\n    term = 4*T0/((2*n-1)*np.pi) * np.sin((2*n-1)*np.pi*x) * np.exp(-(2*n-1)**2 * np.pi**2 * t)\n    uD += term\n  return uD\n\nuD = np.zeros(U.shape)\nfor i in range(len(tVals)):\n  for j in range(len(xi)):\n    uD[j,i] = uDirichelet(tVals[i],xi[j],initTemp)\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(T,X,uD,cmap='magma')\nax.set_xlabel(r'$t$')\nax.set_ylabel(r'$x$')\nax.set_zlabel(r'$u$')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnReset2_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\nThis is similar to the Robin plot for a very small $b$ value\n\n::: {#5b87d923 .cell execution_count=8}\n``` {.python .cell-code}\nuRobin(10,101,5,0.02,0.005).plotTemp()\n```\n\n::: {.cell-output .cell-output-display}\n![](HeatEqnReset2_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "HeatEqnReset2_files"
    ],
    "filters": [],
    "includes": {}
  }
}