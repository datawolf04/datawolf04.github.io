[
  {
    "objectID": "posts/olympic240805/olympicMedalData.html",
    "href": "posts/olympic240805/olympicMedalData.html",
    "title": "Olympic countries: Fun facts and visualizations",
    "section": "",
    "text": "This week we’re exploring Olympics data!\nThe data this week comes from the RGriffin Kaggle dataset: 120 years of Olympic history: athletes and results, basic bio data on athletes and medal results from Athens 1896 to Rio 2016.\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(showtext)\nlibrary(janitor)\nlibrary(ggdist)\nlibrary(ggrepel)\nlibrary(scales)\nlibrary(paletteer)\nlibrary(gt)\n\n\nload('olympicMedalResults.RData')"
  },
  {
    "objectID": "posts/olympic240805/olympicMedalData.html#data-in-this-dataset",
    "href": "posts/olympic240805/olympicMedalData.html#data-in-this-dataset",
    "title": "Olympic countries: Fun facts and visualizations",
    "section": "Data in this dataset:",
    "text": "Data in this dataset:\nFirst, I am planning on analyzing the summer and winter olympics separately. Furthermore, it occurs to me that the year in this dataset should be treated as a factor variable, rather than a numeric variable. This will help if (for example) the olympics were skipped or postponed, and it will definitely help when the winter games were shifted by 2 years so that the intervals between games are uniform.\n\ncountryParticipation &lt;- olympics |&gt; count(noc) |&gt;\n  arrange(desc(n)) \n\nMy plan is to plot out participation, medal count, and gold medal count by country NOC region. The reason for this due to the fact that there are an obnoxious number of “teams” (1184) already in this dataset. Also, I don’t think that we want to track the results of “Osborne Swimming Club, Manchester” or “Phalainis ton Thorichtou ‘Psara’-3” on the same level as Spain, China, Brazil, USA, etc. As it stands, there are plenty of countries to keep track of! As it is, there are 230 national olympic committeees. For fun, let’s look at the least frequent participants.\n\n\n\n\n\n\n\n\n\n\n\n\nOlympic participant breakdown\n\n\n10 lowest participating countries\n\n\nCountry code\nParticipant #\n\n\n\n\nYAR\n11\n\n\nBRU\n10\n\n\nTLS\n9\n\n\nKOS\n8\n\n\nTUV\n7\n\n\nYMD\n5\n\n\nSSD\n3\n\n\nNBO\n2\n\n\nUNK\n2\n\n\nNFL\n1\n\n\n\n#TidyTuesday • Source: RGriffin Kaggle dataset\n\n\n\n\n\n\n\n\n\nAside: Ummm…\nWhat is NFL and who is the lone participant from there?\n\nolympics |&gt; filter(noc==\"NFL\") |&gt; glimpse()\n\nRows: 1\nColumns: 15\n$ id     &lt;dbl&gt; 36547\n$ name   &lt;chr&gt; \"Robert Arthur \\\"Bob\\\" Fowler\"\n$ sex    &lt;chr&gt; \"M\"\n$ age    &lt;dbl&gt; 21\n$ height &lt;dbl&gt; 170\n$ weight &lt;dbl&gt; 57\n$ team   &lt;chr&gt; \"Newfoundland\"\n$ noc    &lt;chr&gt; \"NFL\"\n$ games  &lt;chr&gt; \"1904 Summer\"\n$ year   &lt;dbl&gt; 1904\n$ season &lt;chr&gt; \"Summer\"\n$ city   &lt;chr&gt; \"St. Louis\"\n$ sport  &lt;chr&gt; \"Athletics\"\n$ event  &lt;chr&gt; \"Athletics Men's Marathon\"\n$ medal  &lt;chr&gt; NA\n\n\nOk, wait a minute. So the Canadians don’t want to accept this guy? Was Newfoundland it’s own country back then?\n(Feverish googling occurs)\nWell, I’ll be darned, it was! According to Wikipedia:\n\nUntil 1949, the Dominion of Newfoundland was a separate dominion in the British Empire. In 1933, the House of Assembly of the self-governing dominion voted to dissolve itself and to hand over administration of Newfoundland and Labrador to the British-appointed Commission of Government. This followed the suffering caused by the Great Depression and Newfoundland’s participation in the First World War. On March 31, 1949, it became the 10th and most recent province to join the Canadian Confederation as “Newfoundland”. On December 6, 2001, the Constitution of Canada was amended to change the province’s name from “Newfoundland” to “Newfoundland and Labrador”.\n\nHuh…I learn something new every day! And here I thought it was because most Canadians think (insert Newfie joke here)."
  },
  {
    "objectID": "posts/olympic240805/olympicMedalData.html#back-to-the-show",
    "href": "posts/olympic240805/olympicMedalData.html#back-to-the-show",
    "title": "Olympic countries: Fun facts and visualizations",
    "section": "Back to the show",
    "text": "Back to the show\nI think that I should create a function that sorts the participation data (and later, the medalist data) by country and year. Also, since 230 lines would make the graph look like messy spaghetti, I think it would be best to limit the results to the top 10 countries by the metric being plotted (participation, number medalists, number gold medalists).\n\ncountByCountryYearSzn = function(dat,top=TRUE){\n  cbcys &lt;- dat |&gt; group_by(across(all_of(c(\"season\",\"noc\",\"year\")))) |&gt;\n      summarize(\n        pcount = n()\n      ) |&gt;\n    mutate(\n      cumCount = cumsum(pcount)\n    )\n  \n  countryTotal &lt;- dat |&gt; count(noc) |&gt;\n    arrange(desc(n))\n  \n  nC = nrow(countryTotal)\n  \n  if(top){\n    cKeep = countryTotal[1:10, ]\n  }else{\n    cKeep = countryTotal[(nC-10):nC, ]\n  }\n  \n  out &lt;- cbcys |&gt; inner_join(cKeep,join_by(noc))\n  \n  out$noc = factor(out$noc, levels = cKeep$noc)\n\n  return(out)\n}\n\nNow, let’s make a graph of olympic participation:\n\npart = countByCountryYearSzn(olympics,top=TRUE)\n\n`summarise()` has grouped output by 'season', 'noc'. You can override using the\n`.groups` argument.\n\nggplot(part, aes(x=year, y=cumCount, color=noc)) +\n  geom_step() + facet_wrap(~ season, ncol=1, scales=\"free_y\") + \n  theme_simple() + theme(\n    plot.background = element_rect(fill=grn,color=grn),\n    panel.background = element_rect(fill=ltGrn,color=ltGrn),\n    legend.key = element_rect(fill=ltGrn,color=ltGrn),\n    legend.background = element_rect(fill=ltGrn,color=ltGrn)\n  ) +\n  labs(\n    title = \"Olympic participation by country (top 10)\",\n    x = \"Year of Olympic Games\",\n    y = \"Cumulative participant count\",\n    caption = caption_text,\n    color = \"Nation\"\n  ) +\n  scale_color_paletteer_d(col_pal_dis_long)\n\n\n\n\n\n\n\n\nThe medal breakdown\n\nolyMedal &lt;- olympics |&gt; filter(!is.na(medal))\n\nmedalists = countByCountryYearSzn(olyMedal,top=TRUE)\n\n`summarise()` has grouped output by 'season', 'noc'. You can override using the\n`.groups` argument.\n\nggplot(medalists, aes(x=year,y=cumCount,color=noc)) +\n  geom_step() + facet_wrap(~ season, ncol=1, scales=\"free_y\") + \n  theme_simple() + theme(\n    plot.background = element_rect(fill=silver,color=silver),\n    panel.background = element_rect(fill=ltSilver,color=ltSilver),\n    legend.key = element_rect(fill=ltSilver,color=ltSilver),\n    legend.background = element_rect(fill=ltSilver,color=ltSilver)\n  ) +\n  labs(\n    title=\"Olympic medalists by country (top 10)\",\n    x = \"Year of Olympic Games\",\n    y = \"Cumulative medal count\",\n    caption = caption_text,\n    color = \"Nation\"\n  ) +\n  scale_color_paletteer_d(col_pal_dis_long)\n\n\n\n\n\n\n\n\nI will note that URS is the Soviet Union, and RUS is Russia. Clearly that country’s 20th century history means that it is not treated as continuous by the Olympic Federation. It reminds me of when I was a kid watching Where in the World is Carmen Sandiego and all of a sudden there were new countries on the European maps. &lt;/nostalgia trip&gt;\nBut you can totally see the rivalry fueled by the Cold War when you look at the “slope” of the summer olympic medal accumulation graph and compare the Soviets (and later, the Russians) to the Americans.\n\nolyGold &lt;- olympics |&gt; filter(medal==\"Gold\")\n\ngoldMetals = countByCountryYearSzn(olyGold,top=TRUE)\n\n`summarise()` has grouped output by 'season', 'noc'. You can override using the\n`.groups` argument.\n\nggplot(goldMetals, aes(x=year,y=cumCount,color=noc)) +\n  geom_step() + facet_wrap(~ season, ncol = 1, scales=\"free_y\") + \n  theme_simple() + theme(\n    plot.background = element_rect(fill=gold,color=gold),\n    panel.background = element_rect(fill=ltGold,color=ltGold),\n    legend.key = element_rect(fill=ltGold,color=ltGold),\n    legend.background = element_rect(fill=ltGold,color=ltGold)\n  ) +\n  labs(\n    title=\"Olympic Golds by country (top 10)\",\n    x = \"Year of Olympic Games\",\n    y = \"Cumulative gold metal count\",\n    caption = caption_text,\n    color = \"Nation\"\n  ) +\n  scale_color_paletteer_d(col_pal_dis_long)"
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html",
    "href": "posts/tt20240903/stackOverflow.html",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "",
    "text": "This week’s dataset is derived from the 2024 Stack Overflow Annual Developer Survey. Conducted in May 2024, the survey gathered responses from over 65,000 developers.\nGiven that one of the big trends being discussed in the world right now is working from home vs. going back to the office, I was wondering if there were any trends in this data as to who is working at home. Note, that this dataset did not include gender or race data. In particular, I’m considering 3 questions:\nload(\"soSurvey.RData\")\nsource('helperFunctions.R')\nlibrary(tidyverse)\nlibrary(paletteer)\n\npersonalDataCats = c('main_branch','age','remote_work','ed_level','years_code',\n                     'years_code_pro','dev_type','org_size','country','currency',\n                     'comp_total')\n\npersonData &lt;- stackoverflow_survey_single_response |&gt;\n  select(all_of(personalDataCats)) |&gt;\n  filter(!is.na(remote_work))\n\ncwRemote = qname_levels_single_response_crosswalk |&gt;\n  filter(qname=='remote_work')\n\ncwRemote$label = c(\"Hybrid\",\"In-person\",\"Remote\")\nremoteLevels = c(\"In-person\",\"Hybrid\",\"Remote\")\n\npersonData &lt;- left_join(personData,cwRemote,by=join_by(remote_work == level)) |&gt;\n  mutate(remote_work = factor(label,levels=remoteLevels)) |&gt; \n  select(!qname & !label)"
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html#work-type-and-education-level",
    "href": "posts/tt20240903/stackOverflow.html#work-type-and-education-level",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "Work type and education level",
    "text": "Work type and education level\n\n\n\n\n\n\n\n\n\nThis graph shows the number of responses as well as the level of education that each user has. We can see that most users of Stack Overflow have at least 4-year college degree. This would seem to be in line with the general profile of someone working in a STEM field. It is somewhat difficult to glean what, if any, role there is between work location and education level.\n\n\n\n\n\n\n\n\n\nNext, we consider the same data, but we are highlighting the counts based on work location. This plot shows that a large fraction of Stack Overflow users are working in hybrid or remote locations.\nIn the following two plots, I’ll show the same information as above, except as percentages rather than raw counts.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNeither of these suggests that education level would predict work location for stack overflow users."
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html#work-type-and-age",
    "href": "posts/tt20240903/stackOverflow.html#work-type-and-age",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "Work type and age",
    "text": "Work type and age\n\n\n\n\n\n\n\n\n\nThe above plot looks at the number of responses by age. We can see clearly that most users are between ages 25 and 44.\n\n\n\n\n\n\n\n\n\nHere we see that the age group from 18-24 is working in-person much more than they work hybrid/remote. As this group is college-aged, and most colleges and universities are back to in-person instruction, this could suggest that students who are learning to code at university are using Stack Overflow for help (as this college professor hopes they would). As users age, they tend to find more hybrid/remote roles."
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html#work-type-and-experience-coding",
    "href": "posts/tt20240903/stackOverflow.html#work-type-and-experience-coding",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "Work type and Experience coding",
    "text": "Work type and Experience coding\n\n\n\n\n\n\n\n\n\nHere we see a possible echo of the college idea that I raised above. However, I see a few other things as well.\n\nThere seems to be a significant shift that as people gain experience coding, they move from in-person roles to hybrid/remote roles.\nAs you do something for a longer time, you tend to estimate more. All of the responses seem to favor numbers ending in 0 or 5, especially once you get past 10 years. So if someone has 22 years of experience, they will probably round down to 20, or up to 25, rather than stating 20 exactly."
  },
  {
    "objectID": "posts/tt20240813/worldFairs.html",
    "href": "posts/tt20240813/worldFairs.html",
    "title": "World’s Fairs",
    "section": "",
    "text": "This week’s #TidyTuesday is all about World’s Fairs, and I have always wanted to figure out how to make a visualization with a map. So this is the week that I try that out. In addition to the data from Wikipedia in the given dataset, I have also downloaded S. Altan’s Kaggle Dataset: Countries by Continent.\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(rworldmap)\nlibrary(paletteer)\nlibrary(RColorBrewer)\n\nload('worldsFairs.Rdata')\nsource('helperFunctions.R')"
  },
  {
    "objectID": "posts/tt20240813/worldFairs.html#plan-and-data-cleaning",
    "href": "posts/tt20240813/worldFairs.html#plan-and-data-cleaning",
    "title": "World’s Fairs",
    "section": "Plan and data cleaning",
    "text": "Plan and data cleaning\nMy plan is to create visualizations that look at different world’s fair properties by continent and country. I will clean the data a bit, and then generate some tables.\n\nContinental breakdown of World’s fair\n\nfairData = left_join(worlds_fairs,countryContinent, by='country')\n\n# Replace missing continents by hand\nmissing = c(\"Europe\",\"Oceania\",\"Europe\",\"Europe\",\"Asia\")\nfairData$continent[is.na(fairData$continent)] = missing\n\nfairDataByContinent = fairData |&gt;\n  mutate(\n    duration = calcFLMV(start_month, start_year, end_month, end_year) \n  ) |&gt; group_by(continent) |&gt; \n  summarize(\n    N = n(),\n    across(where(is.numeric), ~ mean(.x,na.rm=TRUE))\n  ) |&gt;\n  select(-c('start_month','start_year','end_month','end_year'))\n\n\n\n\n\n\n  \n    \n      World's Fair by the numbers\n    \n    \n      Average properties by host continent\n    \n    \n      Continent\n      Number Hosted\n      Visitors (M)\n      Avg. cost (M$)\n      Land area (hectares)\n      Number of attending countries\n      Fair duration (mo)\n    \n  \n  \n    Asia\n11\n26.0\n1,999.7\n169.4\n103.5\n5.1\n    Europe\n43\n12.7\n547.8\n77.1\n42.7\n5.2\n    North America\n14\n20.9\n281.4\n144.2\n29.8\n8.9\n    Oceania\n2\n9.9\n320.5\n32.5\n34.5\n7.0\n  \n  \n    \n      #TidyTuesday • Sources: Wikipedia and S. Altan Kaggle dataset\n\n    \n  \n  \n    \n       Missing data was ignored from averages taken.\n    \n  \n\n\n\n\n\n\nCountry breakdown of world’s fair\n\nfairDataByCountry = fairData |&gt;\n  mutate(\n    duration = calcFLMV(start_month, start_year, end_month, end_year) \n  ) |&gt; group_by(country) |&gt; \n  summarize(\n    N = n(),\n    across(where(is.numeric), ~ mean(.x,na.rm=TRUE))\n  ) |&gt;\n  select(-c('start_month','start_year','end_month','end_year'))\n\n\n\n\n\n\n  \n    \n      World's Fair by the numbers\n    \n    \n      Average properties by host country\n    \n    \n      Country\n      Number Hosted\n      Visitors (M)\n      Fair cost (M$)\n      Land area (hectares)\n      Number of attending countries\n      Fair duration (mo)\n    \n  \n  \n    Australia\n1\n18.5\n625.0\n40.0\n36.0\n7.0\n    Austria-Hungary\n1\n7.2\n95.0\n233.0\n35.0\n6.0\n    Belgium\n7\n16.4\n558.8\n117.7\n26.9\n6.7\n    Bulgaria\n3\n1.0\n—\n5.8\n40.5\n1.7\n    Canada\n2\n36.2\n371.0\n217.5\n58.5\n6.5\n    Colony of Victoria\n1\n1.3\n16.0\n25.0\n33.0\n7.0\n    Finland\n1\n—\n—\n0.1\n25.0\n1.0\n    France\n9\n21.6\n556.0\n67.9\n34.5\n5.4\n    Germany\n1\n18.1\n3,400.0\n160.0\n155.0\n5.0\n    Haiti\n1\n—\n—\n24.0\n15.0\n7.0\n    Hungary\n1\n1.9\n—\n35.0\n52.0\n2.0\n    Israel\n2\n—\n—\n29.8\n13.0\n2.0\n    Italy\n8\n7.7\n26.0\n68.3\n44.1\n5.5\n    Japan\n4\n27.5\n30.0\n175.7\n69.8\n7.0\n    Kazakhstan\n1\n4.1\n—\n25.0\n115.0\n4.0\n    People's Republic of China\n1\n73.1\n4,200.0\n523.0\n192.0\n6.0\n    Portugal\n1\n10.1\n—\n50.0\n143.0\n5.0\n    South Korea\n2\n11.3\n1,769.0\n57.5\n122.0\n4.0\n    Spain\n4\n13.9\n21.0\n101.2\n68.8\n7.2\n    Sweden\n3\n—\n—\n0.5\n18.3\n2.3\n    United Arab Emirates\n1\n24.1\n—\n438.0\n192.0\n6.0\n    United Kingdom\n2\n6.0\n83.5\n12.5\n32.0\n7.0\n    United States\n11\n18.2\n265.1\n141.8\n25.6\n9.5\n    West Germany\n2\n2.1\n—\n51.6\n24.5\n4.0\n  \n  \n    \n      #TidyTuesday • Sources: Wikipedia and S. Altan Kaggle dataset\n\n    \n  \n  \n    \n       Missing data was ignored from averages taken. Blank values imply no data exists for that country and quantity."
  },
  {
    "objectID": "posts/tt20240813/worldFairs.html#putting-this-on-a-map",
    "href": "posts/tt20240813/worldFairs.html#putting-this-on-a-map",
    "title": "World’s Fairs",
    "section": "Putting this on a map",
    "text": "Putting this on a map\n\nworldFairMap &lt;- joinCountryData2Map(fairDataByCountry, joinCode = 'NAME',\n                                    nameJoinColumn = \"country\")\n\n21 codes from your data successfully matched countries in the map\n3 codes from your data failed to match with a country code in the map\n222 codes from the map weren't represented in your data\n\npar(mar=c(0,0.1,2,0.1),xaxs=\"i\",yaxs=\"i\",cex.main=2)\nattendMap = mapCountryData(worldFairMap, addLegend=FALSE,\n                           nameColumnToPlot = 'attending_countries',\n                           catMethod = \"pretty\",\n                           colourPalette = brewer.pal(10,\"Purples\"),\n                           oceanCol='lightblue',missingCountryCol = 'white',\n                           mapTitle=\"Country attendance\")\n\nYou asked for 7 categories, 10 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"Purples\"): n too large, allowed maximum for palette Purples is 9\nReturning the palette you asked for with that many colors\n\n\nWarning in rwmGetColours(colourPalette, numColours): 9 colours specified and 10\nrequired, using interpolation to calculate colours\n\ndo.call(addMapLegend, c(attendMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\ncostMap = mapCountryData(worldFairMap, nameColumnToPlot = 'cost',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"Greens\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Cost in Millions\")\n\nYou asked for 7 categories, 9 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"Greens\"): n too large, allowed maximum for palette Greens is 9\nReturning the palette you asked for with that many colors\n\ndo.call(addMapLegend, c(costMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\nareaMap = mapCountryData(worldFairMap, nameColumnToPlot = 'area',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"PuBuGn\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Size of fairgrounds\")\n\nYou asked for 7 categories, 6 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"PuBuGn\"): n too large, allowed maximum for palette PuBuGn is 9\nReturning the palette you asked for with that many colors\n\n\nWarning in rwmGetColours(colourPalette, numColours): 9 colours specified and 6\nrequired, using interpolation to calculate colours\n\ndo.call(addMapLegend, c(areaMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\nvisitMap = mapCountryData(worldFairMap, nameColumnToPlot = 'visitors',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"OrRd\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Fair Visitors by the Million\")\n\nYou asked for 7 categories, 8 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\n\nWarning in rwmGetColours(colourPalette, numColours): 9 colours specified and 8\nrequired, using interpolation to calculate colours\n\ndo.call(addMapLegend, c(visitMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\ntimeMap = mapCountryData(worldFairMap, nameColumnToPlot = 'duration',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"OrRd\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Length of the World's Fair\")\n\nYou asked for 7 categories, 9 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\ndo.call(addMapLegend, c(timeMap, legendWidth=0.5, legendMar=5))"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html",
    "href": "posts/tt20240819/englishMonarchy.html",
    "title": "English Monarchy",
    "section": "",
    "text": "This week’s #TidyTuesday is all about exploring English Monarchs and Marriages!\nThe data was scraped from Ian Visits by f. hull, who also curated this week’s post!"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#data-cleaning",
    "href": "posts/tt20240819/englishMonarchy.html#data-cleaning",
    "title": "English Monarchy",
    "section": "Data cleaning",
    "text": "Data cleaning\nAs one might expect from a dataset that has been scraped from a webpage written by a London history/culture type, there is some inconsistency in how the data has been cataloged. And as the prompt for the week says, some of the early data is “fuzzy”. So I want to clean it up. Here is a quick look at the data:\n\n\nRows: 84\nColumns: 5\n$ sovereign_name   &lt;chr&gt; \"Æthelwulf\", \"Æthelwulf\", \"Æthelbald\", \"Æthelberht\", …\n$ sovereign_age    &lt;chr&gt; \"?\", \"50(?)\", \"24\", \"–\", \"?\", \"19\", \"19\", \"28\", \"31\",…\n$ consort_name     &lt;chr&gt; \"Osburh\", \"Judith of Flanders\", \"Judith of Flanders\",…\n$ consort_age      &lt;chr&gt; \"?\", \"12\", \"14\", \"–\", \"?\", \"16\", \"?\", \"?\", \"?\", \"–\", …\n$ year_of_marriage &lt;chr&gt; \"851(?)\", \"856\", \"858\", \"–\", \"?\", \"868\", \"893\", \"902\"…\n\n\nAs you can see above, uncertainty in the dataset is often indicated with ? or - being included in the string. Ultimately I want to work with numeric variables, for things like age and year, so I’m going to need to clean them up. I also want to track whether a date or age is uncertain, so I am going to create columns tracking that information. All of the queens in the dataset are named Mary, Elizabeth, Anne, or Victoria. Using str_detect and some OR logic, I believe that I have caught all of them.\n\n\nRows: 84\nColumns: 14\n$ sovereign_name       &lt;chr&gt; \"Æthelwulf\", \"Æthelwulf\", \"Æthelbald\", \"Æthelberh…\n$ sovereign_age        &lt;dbl&gt; NA, 50, 24, NA, NA, 19, 19, 28, 31, NA, NA, 22, N…\n$ consort_name         &lt;chr&gt; \"Osburh\", \"Judith of Flanders\", \"Judith of Flande…\n$ consort_age          &lt;dbl&gt; NA, 12, 14, NA, NA, 16, NA, NA, NA, NA, NA, NA, N…\n$ year_of_marriage     &lt;dbl&gt; 851, 856, 858, NA, NA, 868, 893, 902, 905, NA, NA…\n$ sovereign_age_unc    &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FAL…\n$ consort_age_unc      &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, TRU…\n$ year_of_marriage_unc &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FA…\n$ any_unc              &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE…\n$ sovereign_type       &lt;fct&gt; King, King, King, King, King, King, King, King, K…\n$ age_diff_pos         &lt;lgl&gt; NA, TRUE, TRUE, NA, NA, TRUE, NA, NA, NA, NA, NA,…\n$ age_diff             &lt;dbl&gt; NA, 38, 10, NA, NA, 3, NA, NA, NA, NA, NA, NA, NA…\n$ min_age              &lt;dbl&gt; NA, 12, 14, NA, NA, 16, NA, NA, NA, NA, NA, NA, N…\n$ max_age              &lt;dbl&gt; NA, 50, 24, NA, NA, 19, NA, NA, NA, NA, NA, NA, N…"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#plan",
    "href": "posts/tt20240819/englishMonarchy.html#plan",
    "title": "English Monarchy",
    "section": "Plan",
    "text": "Plan\nMake a plot with sovereign age and consort age vs. the year of marriage. On this plot I’m going to highlight:\n\nThe age gap. If both sovereign and consort have the age recorded in the data, there will be a vertical line drawn from the younger to the elder.\nThe gender of the sovereign. Kings are light blue and queens are pink.\nMarriages with uncertain data (either in the year or the ages of those involved) are more transparent so that they stand out less."
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#one-more-visualization",
    "href": "posts/tt20240819/englishMonarchy.html#one-more-visualization",
    "title": "English Monarchy",
    "section": "One more visualization",
    "text": "One more visualization\nPairs plots are fun, and the ggpairs function will automatically calculate some correlation values and put them on the plot as well. I’ve always done these using old school pairs and I thought it would be fun to look at one using the ggplot version. One big advantage is how it automatically uses the facet_grid framework to make the plots and include special plots along the diagonal. You could do the same thing with pairs, but it was more work.\nA few notes about this plot:\n\nThe density plots for the sovereign queens are “spikey” (for lack of a better term). There are just so few sovereign queens. Furthermore the age range at marriage is broad enough that this distribution is just not smooth. Until recently, the succession rules heavily favored male heirs. With the new rules recently adapted, maybe in another millenium or two, there will be enough sovereign queens that we can start approaching gender parity in this area.\nAlso, even though the sovereign queens were the monarch, they also were (in general) younger than their consort, while the opposite is true for the kings."
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#the-model-that-wasnt-quite-there",
    "href": "posts/tt20240819/englishMonarchy.html#the-model-that-wasnt-quite-there",
    "title": "English Monarchy",
    "section": "The model that wasn’t quite there",
    "text": "The model that wasn’t quite there\n\nI like making different kinds of models. I’m wondering if we can build a model for sovereign age at marriage given inputs like gender and year. I didn’t do it here, in part, because I think that there is other work to be done. In particular, how long a sovereign has been in power would be useful data to gather, as well as figuring out how to deal with multiple marriages such as the case of Henry VIII.\n\n\n\n# A tibble: 6 × 5\n  sovereign_name sovereign_age consort_name        consort_age year_of_marriage\n  &lt;chr&gt;          &lt;chr&gt;         &lt;chr&gt;               &lt;chr&gt;       &lt;chr&gt;           \n1 Henry VIII     18            Catherine of Aragon 24          1509            \n2 Henry VIII     42            Anne Boleyn         32          1533            \n3 Henry VIII     45            Jane Seymour        28          1536            \n4 Henry VIII     49            Anne of Cleves      25          1540            \n5 Henry VIII     49            Catherine Howard    19          1540            \n6 Henry VIII     52            Catherine Parr      31          1543"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#ew",
    "href": "posts/tt20240819/englishMonarchy.html#ew",
    "title": "English Monarchy",
    "section": "Ew",
    "text": "Ew\nI thought about ignoring this, but 2024 me simply cannot. I know it was a different time. I am simply upset that a society allowed this sort of predatory behavior under the guise of a self-proclaimed and self-serving monarch declaring his divine right as well as the nobility that enabled and enforced this behavior in service of the accumulation of power. So I’m creating a table and calling it my “Hall of Shame.” I’m not sure that age difference in a relationship is the single best way for building this group, but that’s the data that I have in front of me to use.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHall of Shame\n\n\nPerpetraitor\nVictim\nΔ\nYear\n\n\nName\nAge\nName\nAge\n\n\n\n\nEdward I\n60\nMargaret of France\n20\n40\n1299\n\n\nÆthelwulf\n50\nJudith of Flanders\n12\n38\n856\n\n\nHenry I\n53\nAdeliza of Louvain\n18\n35\n1121\n\n\nHenry VIII\n49\nCatherine Howard\n19\n30\n1540\n\n\nWilliam IV\n53\nAdelaide of Saxe-Meiningen\n26\n27\n1818\n\n\nJames II\n40\nMary of Modena\n15\n25\n1673\n\n\n\n#TidyTuesday • Sources: Ian Visits and f. hull dataset"
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html",
    "href": "posts/heatEqn2/heatEqn2.html",
    "title": "Modeling Heat Flow - Part 2",
    "section": "",
    "text": "Previously, I modeled a “hot box”, but ignored the effects of the sun. As anyone who has had to get into a car that has sat outside for a while on a hot summer day, the inside of the car is warmer than the outside air temperature, and my previous model didn’t allow that. So the sun is important. Consider the following information from The Humane Society.\n\nIt doesn’t have to be that warm outside for a car to become dangerously hot inside.\n\nWhen it’s 72 degrees Fahrenheit outside, the temperature inside your car can heat up to 116 degrees Fahrenheit within an hour.\nWhen it’s 80 degrees Fahrenheit outside, the temperature inside your car can heat up to 99 degrees Fahrenheit within 10 minutes.\nRolling down the windows has been shown to have little effect on the temperature inside a car.\n\n\nLet’s translate these temperatures to Celsius and Kelvin\n\nWhen it’s 22 degrees Celsius outside, the temperature inside your car can heat up to 47 degrees Celsius within an hour.\nWhen it’s 27 degrees Celsius outside, the temperature inside your car can heat up to 37 degrees Celsius within 10 minutes.\n\nMy plan for this post is to assume that my heat box will heat up similarly to the above generic car, and see what sort of parameters I need to make that work."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#background",
    "href": "posts/heatEqn2/heatEqn2.html#background",
    "title": "Modeling Heat Flow - Part 2",
    "section": "",
    "text": "Previously, I modeled a “hot box”, but ignored the effects of the sun. As anyone who has had to get into a car that has sat outside for a while on a hot summer day, the inside of the car is warmer than the outside air temperature, and my previous model didn’t allow that. So the sun is important. Consider the following information from The Humane Society.\n\nIt doesn’t have to be that warm outside for a car to become dangerously hot inside.\n\nWhen it’s 72 degrees Fahrenheit outside, the temperature inside your car can heat up to 116 degrees Fahrenheit within an hour.\nWhen it’s 80 degrees Fahrenheit outside, the temperature inside your car can heat up to 99 degrees Fahrenheit within 10 minutes.\nRolling down the windows has been shown to have little effect on the temperature inside a car.\n\n\nLet’s translate these temperatures to Celsius and Kelvin\n\nWhen it’s 22 degrees Celsius outside, the temperature inside your car can heat up to 47 degrees Celsius within an hour.\nWhen it’s 27 degrees Celsius outside, the temperature inside your car can heat up to 37 degrees Celsius within 10 minutes.\n\nMy plan for this post is to assume that my heat box will heat up similarly to the above generic car, and see what sort of parameters I need to make that work."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#previous-work",
    "href": "posts/heatEqn2/heatEqn2.html#previous-work",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Previous work",
    "text": "Previous work\nAs before, I’ll model the system as a simple box, however, this time it will be car-sized, and I’ll use thermal properties that are common for metals like aluminum, rather than parameters used for building materials.\n\n\nCode\nimport numpy as np\n\n# Heat parameters\nthermalDiffusivity = 22.39e-6 # meters^2/s for air\nheatTransferCoef = 1 # For a typical metal to air W/m^2K\nthermalConductivity = 50 # For a typical metal W/mK\nspecificHeat = 1000 # for aluminum J/kg K\nwallDensity = 3000 # kg/m^3 for aluminum\nsolarIntensity = 1000 # W/m^2\n\n# Length parameters (meters)\nL = 3\nW = 2\nH = 1.5\n\nDeltax = 0.05\nxmax = int(L/Deltax)\nymax = int(W/Deltax)\nzmax = int(H/Deltax)\n\nxmid = xmax // 2\nymid = ymax // 2\nzmid = zmax // 2\n\nxgrid = np.linspace(0,L,xmax+1)\nygrid = np.linspace(0,W,ymax+1)\nzgrid = np.linspace(0,H,zmax+1)\n\nu0 = np.empty((xmax,ymax,zmax))"
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#heat-equation",
    "href": "posts/heatEqn2/heatEqn2.html#heat-equation",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Heat Equation",
    "text": "Heat Equation\nThe heat equation is:\n\\[\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2u + \\text{Internal Power Generation Term} + \\text{Convection on the boundary}\n\\]\nWhere \\(\\alpha=\\frac{k}{c\\rho}\\) is the thermal diffusivity of the material, and \\(k\\) is the thermal conductivity, \\(c\\) is the specific heat, and \\(\\rho\\) is the density. The internal power generation term is going to be related to heat generation due to the absorption of sunlight, and will only be important on surfaces exposed to sunlight. The Boundary convection term will be, again only important on the exterior of the object being modeled. I’ll describe these terms in more detail later in this post.\nWhen working numerically, it is common to employ a finite mesh of points and determine the system temperature at each of these points in space as follows: \\[\nu(x,y,z,t) \\rightarrow u(x_i,y_j,z_k,t) = u_{i,j,k}(t)\n\\]\nI will create this 3D array of functions in time, rather than a 4D array, with one of the dimensions being the evolution in time because when solving differential equations, it is often important to adjust the time step to suit the numerical needs of the system. This way, I will be able to use numerical differential equation solvers as I tackle this problem.\n\nInternal Power Generation\nThis should be proportional to the solar intensity. At the surface of the earth, the intensity of sunlight on a clear day is about 1000 \\(\\text{W}/\\text{m}^2\\). For now, I will model it as:\n\\[\nA I_{\\text{sun}} f(x,y,z)\n\\]\nwhere \\(A\\) is a constant that I will determine empirically. For this model, I will assume:\n\\[\nf(x,y,z) =\n\\begin{cases}\n1 &z=H \\\\\n0 &\\text{else}\n\\end{cases}\n\\]\nThis has the meaning that for this model, the sun is directly overhead, and sunlight is only incident on the top of the box. The constant \\(A\\) should depend on material properties like specific heat and density as follows:\n\\[\nA = \\frac{1}{c\\rho\\delta_{\\text{eff}}}\n\\]\nwhere \\(\\delta_{\\text{eff}}\\) is an effective depth that the sunlight penetrates.\n\n\nCode\ndef powerGen(umat, t, intensity, A):\n    powerGen = np.zeros_like(umat)\n\n    powerDensity = A*intensity\n    powerGen[:,:,-1].fill(powerDensity)\n\n    return powerGen\n\n\n\n\nBoundary convection\nThe power exchange per unit volume due to convection is proportional to the difference in temperature of air and the temperature at the boundary:\n\\[\nB \\left(T_{\\text{air}}-u(x_S,y_S,z_S,t)\\right)\n\\]\nfor points \\((x_S,y_S,z_S)\\) on the boundary of the object (assuming a uniform air temperature). Again, \\(B\\) is a constant that I will determine empirically. However, the constant \\(B\\) should depend on material properties like specific heat, density, and the heat transfer coefficient as follows:\n\\[\nB = \\frac{h}{c\\rho\\Delta_{\\text{eff}}}\n\\]\nwhere \\(\\Delta_{\\text{eff}}\\) is an effective thickness of the convection surface.\n\n\nCode\ndef bdryConv(umat, t, Tair, B):\n\n    bdryTemp = np.zeros_like(umat)\n    uSurf = np.zeros_like(umat)\n\n    bdryTemp[0,:,:].fill(Tair)\n    bdryTemp[:,0,:].fill(Tair)\n    bdryTemp[:,:,0].fill(Tair)\n    bdryTemp[-1,:,:].fill(Tair)\n    bdryTemp[:,-1,:].fill(Tair)\n    bdryTemp[:,:,-1].fill(Tair)\n\n    uSurf[0,:,:] = umat[0,:,:]\n    uSurf[:,0,:] = umat[:,0,:]\n    uSurf[:,:,0] = umat[:,:,0]\n    uSurf[-1,:,:] = umat[-1,:,:]\n    uSurf[:,-1,:] = umat[:,-1,:]\n    uSurf[:,:,-1] = umat[:,:,-1]\n\n    duConvdt = B*(bdryTemp - uSurf)\n    return duConvdt  \n\n\n\n\nLaplacian\nLastly I have to deal with the Laplacian in the following cases:\n\nInterior points\nBoundary surfaces\nBoundary edges\nBoundary corners\n\nIn the finite difference method, the Laplacian is proportional to the average deviation of the current point from the nearest neighbors. I’ll show how this is calculated in later sections for surfaces, edges and corners. All in all this is quite tedious, and if you want to skip the math, navigate to the Analysis Plan section through the menu at the right.\n\nHeat Equation on the interior of the box\nThe heat equation on the interior of the box has none of the contributions from the boundary terms: \\[\n\\frac{\\partial u(x,y,z,t)}{\\partial t} = \\alpha\\nabla^2 u(x,y,z,t)\n\\]\nWhen we apply the finite element approximation, we get the following:\n\\[\\begin{align*}\n  \\nabla^2 u(x,y,z,t) \\rightarrow \\frac{1}{\\Delta x\\Delta y\\Delta z}\n                        &\\left(\\Delta y \\Delta z \\frac{u_{i-1,j,k}(t) + u_{i+1,j,k}(t) -\n                        2 u_{i,j,k}(t)}{\\Delta x} \\right.\\\\\n                       &\\quad + \\Delta x \\Delta z \\frac{u_{i,j-1,k}(t) + u_{i,j+1,k}(t) - 2\n                        u_{i,j,k}(t)}{\\Delta y} \\\\\n                       &\\qquad \\left. + \\Delta x \\Delta y \\frac{u_{i,j,k-1}(t) + u_{i,j,k+1}(t)\n                         - 2 u_{i,j,k}(t)}{\\Delta z}\\right) \\\\\n\\end{align*}\\]\nThis simplifies to: \\[\\begin{align*}\n  \\nabla^2 u(x,y,z,t)\n       &\\rightarrow \\frac{u_{i-1,j,k}(t) + u_{i+1,j,k}(t) - 2 u_{i,j,k}(t)}{\\Delta x^2} \\\\\n       &\\quad +\\frac{u_{i,j-1,k}(t) + u_{i,j+1,k}(t) - 2 u_{i,j,k}(t)}{\\Delta y^2} \\\\\n       & \\qquad + \\frac{u_{i,j,k-1}(t) + u_{i,j,k+1}(t) - 2 u_{i,j,k}(t)}{\\Delta z^2}\n\\end{align*}\\]\nIf we generate our grid with \\(\\Delta x = \\Delta y = \\Delta z\\), we obtain:\n\\[\n\\nabla^2 u_{i,j,k} =  \\frac{u_{i-1,j,k} + u_{i+1,j,k} + u_{i,j-1,k} + u_{i,j+1,k} + u_{i,j,k-1} + u_{i,j,k+1} - 6 u_{i,j,k}}{\\Delta x^2} \\\\\n\\]\n\n\nHeat Equation on a boundary surface\nSo if we are considering the \\(x=0, i=0\\) surface: \\[\n\\frac{du_{0,j,k}(t)}{\\partial t} = \\alpha \\nabla^2 u_{0,j,k}(t) + f_{0jk}(t) + \\frac{h}{c\\rho}(T_{\\text{air}}-u_{0,j,k})\n\\] where\n\\[\\begin{align*}\n\\nabla^2 u_{0,j,k}(t) &= \\frac{1}{\\Delta x\\Delta y\\Delta z} \\left(\\Delta y \\Delta z\n                        \\frac{u_{1,j,k}(t) - u_{0,j,k}(t)}{\\Delta x} \\right. \\\\\n            &\\qquad + \\frac{\\Delta x}{2} \\Delta z \\frac{u_{0,j-1,k}(t) + u_{0,j+1,k}(t) - 2 u_{0,j,k}(t)}{\\Delta y} \\\\\n            &\\qquad \\left. + \\frac{\\Delta x}{2} \\Delta y \\frac{u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 2\n              u_{0,j,k}(t)}{\\Delta z}\\right)\n\\end{align*}\\]\nThis simplifies to:\n\\[\\begin{align*}\n  \\nabla^2 u_{0,j,k}(t) = \\frac{1}{2} &\\left(\\frac{2 u_{1,j,k}(t) - 2 u_{0,j,k}(t)}{\\Delta x^2}\\right. \\\\\n            &\\qquad + \\frac{u_{0,j-1,k}(t) + u_{0,j+1,k}(t) - 2 u_{0,j,k}(t)}{\\Delta y^2} \\\\\n            &\\qquad + \\left. \\frac{u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 2 u_{0,j,k}(t)}{\\Delta\n              z^2} \\right) \\\\\n\\end{align*}\\]\nAgain, with a uniform grid, this becomes: \\[\n\\nabla^2 u_{0,j,k}(t) = \\frac{2 u_{1,j,k}(t) + u_{0,j-1,k}(t) + u_{0,j+1,k}(t) + u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 6 u_{0,j,k}(t)}{2 \\Delta x^2}\n\\]\nFollowing a similar method we can find for all 6 surfaces:\n\\[\\begin{align*}\n\\nabla^2 u_{0,j,k}(t) &= \\frac{2 u_{1,j,k}(t) + u_{0,j-1,k}(t) + u_{0,j+1,k}(t) + u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 6 u_{0,j,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{I,j,k}(t) &= \\frac{2 u_{I-1,j,k}(t) + u_{I,j-1,k}(t) + u_{I,j+1,k}(t) + u_{I,j,k-1}(t) + u_{I,j,k+1}(t) - 6 u_{I,j,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,0,k}(t) &= \\frac{2 u_{i,1,k}(t) + u_{i-1,0,k}(t) + u_{i+1,0,k}(t) + u_{i,0,k-1}(t) + u_{i,0,k+1}(t) - 6 u_{i,0,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,J,k}(t) &= \\frac{2 u_{i,J-1,k}(t) + u_{i-1,J,k}(t) + u_{i+1,J,k}(t) + u_{i,J,k-1}(t) + u_{i,J,k+1}(t) - 6 u_{i,J,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,j,0}(t) &= \\frac{2 u_{i,j,1}(t) + u_{i-1,j,0}(t) + u_{i+1,j,0}(t) + u_{i,j-1,0}(t) + u_{i,j+1,0}(t) - 6 u_{i,j,0}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,j,K}(t) &= \\frac{2 u_{i,j,K-1}(t) + u_{i,j-1,K}(t) + u_{i,j+1,K}(t) + u_{i,j,K}(t) + u_{i,j,k+1}(t) - 6 u_{i,j,K}(t)}{2 \\Delta x^2} \\\\\n\\end{align*}\\]\n\n\nHeat equation on a boundary edge\nSo if we are considering the \\(x=0, i=0\\), \\(y=0, j=0\\) edge: \\[\n\\frac{du_{0,0,k}(t)}{\\partial t} = \\alpha \\nabla^2 u_{0,0,k}(t) + f_{0,0,k}(t) + \\frac{h}{c\\rho}(T_{\\text{air}}-u_{0,0,k})\n\\] where\n\\[\\begin{align*}\n\\nabla^2 u_{0,0,k}(t) &= \\frac{1}{\\Delta x\\Delta y\\Delta z} \\left(\\frac{\\Delta y}{2} \\Delta z\n                        \\frac{u_{1,0,k}(t) - u_{0,0,k}(t)}{\\Delta x} \\right. \\\\\n            &\\qquad + \\frac{\\Delta x}{2} \\Delta z \\frac{u_{0,1,k}(t) - u_{0,0,k}(t)}{\\Delta y} \\\\\n            &\\qquad \\left. + \\frac{\\Delta x}{2} \\frac{\\Delta y}{2} \\frac{u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 2 u_{0,0,k}(t)}{\\Delta z}\\right) \\\\\n\\end{align*}\\]\nThis simplifies to:\n\\[\\begin{align*}\n  \\nabla^2 u_{0,0,k}(t) &= \\frac{1}{4} \\left(\\frac{2u_{1,0,k}(t) - 2u_{0,0,k}(t)}{\\Delta x^2} \\right. \\\\\n            &\\qquad + \\frac{2u_{0,1,k}(t) - 2u_{0,0,k}(t)}{\\Delta y^2} \\\\\n            &\\qquad \\left. + \\frac{u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 2 u_{0,0,k}(t)}{\\Delta z^2}\\right) \\\\\n\\end{align*}\\]\nAgain, with a uniform grid, this becomes: \\[\n\\nabla^2 u_{0,0,k}(t) = \\frac{2 u_{1,0,k}(t) +  2 u_{0,1,k}(t) + u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 6 u_{0,0,k}(t)}{4 \\Delta x^2}\n\\]\nFollowing a similar method we can find for all 12 edges:\n\\[\\begin{align*}\n    \\nabla^2 u_{0,0,k}(t) &= \\frac{2 u_{1,0,k}(t) +  2 u_{0,1,k}(t) + u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 6 u_{0,0,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,J,k}(t) &= \\frac{2 u_{1,J,k}(t) +  2 u_{0,J-1,k}(t) + u_{0,J,k-1}(t) + u_{0,J,k+1}(t) - 6 u_{0,J,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,j,0}(t) &= \\frac{2 u_{1,j,0}(t) +  2 u_{0,j,1}(t) + u_{0,j-1,0}(t) + u_{0,j+1,0}(t) - 6 u_{0,j,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,j,K}(t) &= \\frac{2 u_{1,j,K}(t) +  2 u_{0,j,K-1}(t) + u_{0,j-1,K}(t) + u_{0,j+1,0}(t) - 6 u_{0,j,K}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,0,k}(t) &= \\frac{2 u_{I-1,0,k}(t) +  2 u_{I,1,k}(t) + u_{I,0,k-1}(t) + u_{I,0,k+1}(t) - 6 u_{I,0,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,J,k}(t) &= \\frac{2 u_{I-1,J,k}(t) +  2 u_{I,J-1,k}(t) + u_{I,J,k-1}(t) + u_{I,J,k+1}(t) - 6 u_{I,J,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,j,0}(t) &= \\frac{2 u_{I-1,j,0}(t) +  2 u_{I,j,1}(t) + u_{I,j-1,0}(t) + u_{I,j+1,0}(t) - 6 u_{I,j,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,j,K}(t) &= \\frac{2 u_{I-1,j,K}(t) +  2 u_{I,j,K-1}(t) + u_{I,j-1,K}(t) + u_{I,j+1,K}(t) - 6 u_{I,j,K}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,0,0}(t) &= \\frac{2 u_{i,0,1}(t) +  2 u_{i,1,0}(t) + u_{i-1,0,0}(t) + u_{i+1,0,0}(t) - 6 u_{i,0,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,0,K}(t) &= \\frac{2 u_{i,0,K-1}(t) +  2 u_{i,1,K}(t) + u_{i-1,0,K}(t) + u_{i+1,0,K}(t) - 6 u_{i,0,K}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,J,0}(t) &= \\frac{2 u_{i,J,1}(t) +  2 u_{i,J-1,0}(t) + u_{i-1,J,0}(t) + u_{i+1,J,0}(t) - 6 u_{i,J,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,J,K}(t) &= \\frac{2 u_{i,J,K-1}(t) +  2 u_{i,J-1,K}(t) + u_{i-1,J,K}(t) + u_{i+1,J,K}(t) - 6 u_{i,J,K}(t)}{4 \\Delta x^2} \\\\\n\\end{align*}\\]\n\n\nHeat equation on a boundary corner\nSo if we are considering the \\(x=0, i=0\\), \\(y=0, j=0\\), \\(z=0, k=0\\) corner: \\[\n\\frac{du_{0,0,0}(t)}{\\partial t} = \\alpha \\nabla^2 u_{0,0,0}(t) + f_{0,0,0}(t) + \\frac{h}{c\\rho}(T_{\\text{air}}-u_{0,0,0})\n\\] where\n\\[\\begin{align*}\n  \\nabla^2 u_{0,0,0}(t) &= \\frac{1}{\\Delta x\\Delta y\\Delta z} \\left(\\frac{\\Delta y}{2} \\frac{\\Delta z}{2} \\frac{u_{1,0,0}(t) - u_{0,0,0}(t)}{\\Delta x} \\right.\\\\\n                        &\\qquad + \\frac{\\Delta x}{2} \\frac{\\Delta z}{2} \\frac{u_{0,1,0}(t) - u_{0,0,0}(t)}{\\Delta y} \\\\\n                        &\\qquad \\left. + \\frac{\\Delta x}{2} \\frac{\\Delta y}{2} \\frac{u_{0,0,1}(t) - 2 u_{0,0,0}(t)}{\\Delta z}\\right) \\\\\n\\end{align*}\\]\nThis simplifies to:\n\\[\n  \\nabla^2 u_{0,0,0}(t) = \\frac{1}{4} \\left(\\frac{u_{1,0,0}(t) - u_{0,0,0}(t)}{\\Delta x^2}\n            + \\frac{u_{0,1,0}(t) - u_{0,0,0}(t)}{\\Delta y^2}\n            + \\frac{u_{0,0,1}(t) - u_{0,0,0}(t)}{\\Delta z^2}\\right)\n\\]\nAgain, with a uniform grid, this becomes: \\[\n\\nabla^2 u_{0,0,0}(t) = \\frac{u_{1,0,0}(t) +  u_{0,1,0}(t) + u_{0,0,1}(t) - 3 u_{0,0,0}(t)}{2 \\Delta x^2}\n\\]\nFollowing a similar method we can find for all 8 corners:\n\\[\\begin{align*}\n    \\nabla^2 u_{0,0,0}(t) &= \\frac{u_{1,0,0}(t) +  u_{0,1,0}(t) + u_{0,0,1}(t) - 3 u_{0,0,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,0,0}(t) &= \\frac{u_{I-1,0,0}(t) +  u_{I,1,0}(t) + u_{I,0,1}(t) - 3 u_{I,0,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,J,0}(t) &= \\frac{u_{1,J,0}(t) +  u_{0,J-1,0}(t) + u_{0,J,1}(t) - 3 u_{0,J,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,0,K}(t) &= \\frac{u_{1,0,K}(t) +  u_{0,1,K}(t) + u_{0,0,K-1}(t) - 3 u_{0,0,K}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,J,0}(t) &= \\frac{u_{I-1,J,0}(t) +  u_{I,J-1,0}(t) + u_{I,J,1}(t) - 3 u_{I,J,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,0,K}(t) &= \\frac{u_{I-1,0,K}(t) +  u_{I,1,K}(t) + u_{I,0,K-1}(t) - 3 u_{I,0,K}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,J,K}(t) &= \\frac{u_{1,J,K}(t) +  u_{0,J-1,K}(t) + u_{0,J,K-1}(t) - 3 u_{0,J,K}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,J,K}(t) &= \\frac{u_{I-1,J,K}(t) +  u_{I,J-1,K}(t) + u_{I,J,K-1}(t) - 3 u_{I,J,K}(t)}{2 \\Delta x^2} \\\\\n\\end{align*}\\]\nThese are all coded into the function below.\n\n\nCode\ndef lap3DFE(umat,dx):\n    lap = np.empty_like(umat)\n\n    # Interior elements:\n    lap[1:-1,1:-1,1:-1] = (umat[:-2, 1:-1, 1:-1] + umat[2:, 1:-1, 1:-1] + umat[1:-1, :-2, 1:-1] + \n                           umat[1:-1, 2:, 1:-1] + umat[1:-1,1:-1,:-2] + umat[1:-1,1:-1,2:] - 6*umat[1:-1,1:-1,1:-1]) / dx**2\n\n    # Surface elements:\n    lap[0,1:-1,1:-1] = (2*umat[1, 1:-1, 1:-1] + umat[0, :-2, 1:-1] + umat[0, 2:, 1:-1] + umat[0, 1:-1, :-2] + umat[0, 1:-1, 2:] - \n        6*umat[0, 1:-1, 1:-1]) / (2*dx**2)\n    lap[-1,1:-1,1:-1] = (2* umat[-2, 1:-1, 1:-1] + umat[-1, :-2, 1:-1] + umat[-1, 2:, 1:-1] + umat[-1, 1:-1, :-2] + umat[-1, 1:-1, 2:] -\n        6*umat[-1, 1:-1, 1:-1]) / (2*dx**2)\n    lap[1:-1,0,1:-1] = (2* umat[1:-1, 1, 1:-1] + umat[:-2, 0, 1:-1] + umat[2:, 0, 1:-1] + umat[1:-1, 0, :-2] + umat[1:-1, 0, 2:] - \n        6*umat[1:-1, 0, 1:-1]) / (2*dx**2)\n    lap[1:-1,-1,1:-1] = (2* umat[1:-1, -2, 1:-1] + umat[:-2, -1, 1:-1] + umat[2:, -1, 1:-1] + umat[1:-1, -1, :-2] + umat[1:-1, -1, 2:] - \n        6*umat[1:-1, -1, 1:-1]) / (2*dx**2)\n    lap[1:-1,1:-1,0] = (2* umat[1:-1, 1:-1, 1] + umat[:-2, 1:-1, 0] + umat[2:, 1:-1, 0] + umat[1:-1, :-2, 0] + umat[1:-1, 2:, 0] - \n        6*umat[1:-1, 1:-1, 0]) / (2*dx**2)\n    lap[1:-1,1:-1,-1] = (2* umat[1:-1, 1:-1, -2] + umat[:-2, 1:-1, -1] + umat[2:, 1:-1, -1] + umat[1:-1, :-2, -1] + umat[1:-1, 2:, -1] - \n        6*umat[1:-1, 1:-1, -1]) / (2*dx**2)\n\n    # Edge Elements:\n    lap[0,0,1:-1] = (2 * umat[1, 0, 1:-1] + 2 * umat[0, 1, 1:-1] + umat[0, 0, :-2] + umat[0, 0, 2:] - 6*umat[0, 0, 1:-1]) / (4*dx**2)\n    lap[0,-1,1:-1] = (2 * umat[1, -1, 1:-1] + 2 * umat[0, -2, 1:-1] + umat[0, -1, :-2] + umat[0, -1, 2:] - 6*umat[0, -1, 1:-1]) / (4*dx**2)\n    lap[-1,0,1:-1] = (2 * umat[-2, 0, 1:-1] + 2 * umat[-1, 1, 1:-1] + umat[-1, 0, :-2] + umat[-1, 0, 2:] - 6*umat[-1, 0, 1:-1]) / (4*dx**2)\n    lap[-1,-1,1:-1] = (2 * umat[-2, -1, 1:-1] + 2 * umat[-1, -2, 1:-1] + umat[-1, -1, :-2] + umat[-1, -1, 2:] - 6*umat[-1, -1, 1:-1]) / (4*dx**2)\n    lap[0,1:-1,0] = (2 * umat[1, 1:-1, 0] + 2 * umat[0, 1:-1, 1] + umat[0, 2:, 0] + umat[0, :-2, 0] - 6*umat[0, 1:-1, 0]) / (4*dx**2)\n    lap[0,1:-1,-1] = (2 * umat[1, 1:-1, -1] + 2 * umat[0, 1:-1, -2] + umat[0, 2:, -1] + umat[0, :-2, -1] - 6*umat[0, 1:-1, -1]) / (4*dx**2)\n    lap[-1,1:-1,0] = (2 * umat[-2, 1:-1, 0] + 2 * umat[-1, 1:-1, 1] + umat[-1, 2:, 0] + umat[-1, :-2, 0] - 6*umat[-1, 1:-1, 0]) / (4*dx**2)\n    lap[-1,1:-1,-1] = (2 * umat[-2, 1:-1, -1] + 2 * umat[-1, 1:-1, -2] + umat[-1, 2:, -1] + umat[-1, :-2, -1] - 6*umat[-1, 1:-1, -1]) / (4*dx**2)\n    lap[1:-1,0,0] = (2 * umat[1:-1, 1, 0] + 2 * umat[1:-1, 0, 1] + umat[:-2, 0, 0] + umat[2:, 0, 0] - 6*umat[1:-1, 0, 0]) / (4*dx**2)\n    lap[1:-1,0,-1] = (2 * umat[1:-1, 1, -1] + 2 * umat[1:-1, 0, -2] + umat[:-2, 0, -1] + umat[2:, 0, -1] - 6*umat[1:-1, 0, -1]) / (4*dx**2)\n    lap[1:-1,-1,0] = (2 * umat[1:-1, -2, 0] + 2 * umat[1:-1, -1, 1] + umat[:-2, -1, 0] + umat[2:, -1, 0] - 6*umat[1:-1, -1, 0]) / (4*dx**2)\n    lap[1:-1,-1,-1] = (2 * umat[1:-1, 2, -1] + 2 * umat[1:-1, -1, -2] + umat[:-2, -1, -1] + umat[2:, -1, -1] - 6*umat[1:-1, -1, -1]) / (4*dx**2)    \n    \n    # Corner Elements:\n    lap[0,0,0] = (umat[1, 0, 0] + umat[0, 1, 0] + umat[0, 0, 1] - 3*umat[0, 0, 0]) / (2*dx**2)\n    lap[-1,0,0] = (umat[-2, 0, 0] + umat[-1, 1, 0] + umat[-1, 0, 1] - 3*umat[-1, 0, 0]) / (2*dx**2)\n    lap[0,-1,0] = (umat[1, -1, 0] + umat[0, -2, 0] + umat[0, -1, 1] - 3*umat[0, -1, 0]) / (2*dx**2)\n    lap[0,0,-1] = (umat[1, 0, -1] + umat[0, 1, -1] + umat[0, 0, -2] - 3*umat[0, 0, -1]) / (2*dx**2)\n    lap[0,-1,-1] = (umat[1, -1, -1] + umat[0, -2, -1] + umat[0, -1, -2] - 3*umat[0, -1, -1]) / (2*dx**2)\n    lap[-1,0,-1] = (umat[-2, 0, -1] + umat[-1, 1, -1] + umat[-1, 0, -2] - 3*umat[-1, 0, -1]) / (2*dx**2)\n    lap[-1,-1,0] = (umat[2, -1, 0] + umat[-1, -2, 0] + umat[-1, -1, 1] - 3*umat[-1, -1, 0]) / (2*dx**2)\n    lap[-1,-1,-1] = (umat[-2, -1, -1] + umat[-1, -2, -1] + umat[-1, -1, -2] - 3*umat[-1, -1, -1]) / (2*dx**2)\n\n    return lap\n\n\n\n\n\nFinal Heat equation function\n\ndef dudt(t,u, alpha, intensity, dx, Tair, A, B):\n    dudt = alpha*lap3DFE(u,dx) + powerGen(u, t, intensity, A) + bdryConv(u, t, Tair, B)\n    return dudt\n\nI will have to flatten things as solve_ivp only solves a vector system of differential equations rather than the higher dimenionality matrix system that I’ve created.\n\ndef dudtFlat(t,uflat, alpha, intensity, dx, Tair, A, B):\n    u = uflat.reshape(xmax,ymax,zmax)\n    return dudt(t,u, alpha, intensity, dx, Tair, A, B).flatten()"
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#analysis-plan",
    "href": "posts/heatEqn2/heatEqn2.html#analysis-plan",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Analysis plan",
    "text": "Analysis plan\nI will begin by choosing parameters \\(A\\) and \\(B\\) based on an initial guess, and then I will adjust those parameters to minimize the absolute difference between the result that I obtain and the target temperatures noted in these statements\n\nWhen it’s 22 degrees Celsius outside, the temperature inside your car can heat up to 47 degrees Celsius within an hour.\nWhen it’s 27 degrees Celsius outside, the temperature inside your car can heat up to 37 degrees Celsius within 10 minutes.\n\n\nCalculation 1:\nFor parameters \\(A\\) and \\(B\\) (described above) find the difference between the average box temperature after an hour and 47 deg C, assuming an air temperature of 22 deg C.\n\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\ndef calc1(A,B):\n    oneHour = 3600\n    airTemp = 22\n    hotCarTemp = 47\n    u0.fill(airTemp)\n    time = np.arange(0,oneHour,10)\n    \n    oneHourCalc = solve_ivp(dudtFlat, t_span=[0,oneHour], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(oneHourCalc.y,axis=0)\n\n    finalAvgTemp = avgBoxTempCalc[-1]\n    tempDiff = finalAvgTemp - hotCarTemp\n\n    return tempDiff\n\n\n\nCalculation 2:\nFor parameters \\(A\\) and \\(B\\) (described above) find the difference between the average box temperature after 10 minutes and 37 deg C, assuming an air temperature of 27 deg C.\n\ndef calc2(A,B):\n    tenMin = 60*10\n    airTemp = 27\n    hotCarTemp = 37\n    u0.fill(airTemp)\n    time = np.arange(0,tenMin,10)\n    \n    tenMinCalc = solve_ivp(dudtFlat, t_span=[0,tenMin], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(tenMinCalc.y,axis=0)\n\n    finalAvgTemp = avgBoxTempCalc[-1]\n    tempDiff = finalAvgTemp - hotCarTemp\n\n    return tempDiff\n\n\n\nOptimization\nNow I will find the parameters \\(A\\) and \\(B\\) that correctly model the statements given in the opening section of this post.\n\nfrom scipy.optimize import minimize\nfrom scipy.optimize import Bounds\n\nbounds = ((0, None), (0, None))\n\ndef totalTempDiff(x):\n    A, B = x\n    diff1 = np.abs(calc1(A,B))\n    diff2 = np.abs(calc2(A,B))\n    diff = diff1+diff2\n    return diff\n\nestA = 1/(specificHeat*wallDensity*(Deltax/10))\nestB = heatTransferCoef/(specificHeat*wallDensity*(Deltax/1000))\nx0 = np.array([estA,estB])\n\nres = minimize(totalTempDiff,x0,bounds=bounds)\n\nA,B = res.x\ndiff1 = np.abs(calc1(A,B))\ndiff2 = np.abs(calc2(A,B))\n\nprint(f'The temperature differences are {diff1:.3f} deg C for calculation 1 and {diff2:.3f} deg C for calculation 2')\n\nThe temperature differences are 0.000 deg C for calculation 1 and 0.030 deg C for calculation 2\n\n\nSince we can interpret the parameters \\(A\\) and \\(B\\) through the properties of materials, as described above, we find:\n\nprint(f'A = {res.x[0]:2e} m^2K/Ws and B= {res.x[1]:2e} 1/s')\n\nD = 1/(specificHeat*wallDensity*res.x[0])\nDelta = heatTransferCoef/(specificHeat*wallDensity*res.x[1])\nprint(f'δ = {D:.5f} m and Δ = {Delta:.5f} m.')\n\nA = 1.117617e-03 m^2K/Ws and B= 6.666691e-03 1/s\nδ = 0.00030 m and Δ = 0.00005 m.\n\n\n\n\nPlot the time evolution of the temperature\nFinally, I’ll plot the time evolution of the average temperature for these systems.\n\n\nCode\ndef plot1(A,B):\n    oneHour = 3600\n    airTemp = 22\n    hotCarTemp = 47\n    u0.fill(airTemp)\n    time = np.arange(0,oneHour,10)\n    \n    oneHourCalc = solve_ivp(dudtFlat, t_span=[0,oneHour], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(oneHourCalc.y,axis=0)\n\n    plt.plot(time,avgBoxTempCalc,label='Avg Car Temp')\n    plt.axhline(y=airTemp,label='Air Temp',ls='--',color='green')\n    plt.axhline(y=hotCarTemp,label='Danger Temp',ls='--',color='red')\n    plt.title(f'Average car temperature when air temp is {airTemp:.0f} C.') \n    plt.xlabel('Time (s)')\n    plt.ylabel('Temperature (C)')\n    plt.legend()\n    plt.show()\n\ndef plot2(A,B):\n    tenMin = 60*10\n    airTemp = 27\n    hotCarTemp = 37\n    u0.fill(airTemp)\n    time = np.arange(0,tenMin,10)\n    \n    tenMinCalc = solve_ivp(dudtFlat, t_span=[0,tenMin], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(tenMinCalc.y,axis=0)\n\n    plt.plot(time,avgBoxTempCalc,label='Avg Car Temp')\n    plt.axhline(y=airTemp,label='Air Temp',ls='--',color='green')\n    plt.axhline(y=hotCarTemp,label='Danger Temp',ls='--',color='red')\n    plt.title(f'Average car temperature when air temp is {airTemp:.0f} C.') \n    plt.xlabel('Time (s)')\n    plt.ylabel('Temperature (C)')\n    plt.legend()\n    plt.show()\n\nA,B = res.x\nplot1(A,B)\nplot2(A,B)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis makes sense. In both systems the rate of heating decreases with time, suggesting that there is an upper limit to the temperature that the box will approach. Note that we need to put the ratio of the area of the top surface to the total surface area of the box in front of the solar generation term as the box is only gaining area through the top surface in this model, while convection is occurring everywhere on the surface of the box.\n\\[\n\\frac{du}{dt} = \\alpha\\nabla^2u + AI_s + B(T_{\\text{air}}-u) \\longrightarrow 0 = 0 + \\frac{A_{\\text{top}}}{A_{\\text{box}}} AI_s + B(T_{\\text{air}}-u_0)\n\\] Solving for the equilibrium temperature, we find: \\[\n\\implies u_0 = T_{\\text{air}} + \\left(\\frac{A_{\\text{top}}}{A_{\\text{box}}}\\right) \\frac{AI_s}{B}\n\\]\nGiven the system that I’m modeling, and values for \\(A\\) and \\(B\\) that I have found, we can calculate the difference between air temperature and the steady-state box temperature.\n\ntopArea = L*W\nboxArea = 2*(L*W + L*H + W*H)\nsolarBoost = A * solarIntensity/B * topArea/boxArea\nprint(f'The temperature after a long time should approach a value that is {solarBoost:.2f} deg C warmer than the air temperature.')\n\nThe temperature after a long time should approach a value that is 37.25 deg C warmer than the air temperature.\n\n\nLet’s verify this calculation by simulating this system for 10 hours.\n\ndef simSystem(A,B):\n    oneHour = 3600\n    airTemp = 27\n    eqTemp = airTemp + A*solarIntensity/B * L*W/(2*(L*W + L*H + W*H))\n    u0.fill(airTemp)\n    time = np.arange(0,10*oneHour,100)\n    \n    oneHourCalc = solve_ivp(dudtFlat, t_span=[0,10*oneHour], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    return oneHourCalc\n\nlongCalc = simSystem(A,B)    \n\nAnd then I will plot the average temperature as a function of time, as well as the average temperature at a range of heights.\n\ndef plotTemperature(uflat):\n    oneHour = 3600\n    airTemp = 27\n    eqTemp = airTemp + A*solarIntensity/B * L*W/(2*(L*W + L*H + W*H))\n    time = np.arange(0,10*oneHour,100)\n    avgBoxTempCalc = np.mean(uflat,axis=0)\n    avgBoxTempZ = np.empty((len(time),zmax))\n    \n    for l in range(len(time)):\n      umat = uflat[:, l].reshape((xmax,ymax,zmax))\n      for k in range(zmax):\n        avgBoxTempZ[l,k] = np.mean(umat[:,:,k])\n      \n\n    plt.plot(time,avgBoxTempCalc,label='Avg Car Temp')\n    for k in reversed(range(0, zmax, 5)):\n      zdim = k * Deltax\n      labText = f'z = {zdim:.3f} m'\n      plt.plot(time, avgBoxTempZ[:,k],label=labText,ls='dotted')\n    plt.axhline(y=airTemp,label='Air Temp',ls='--',color='green')\n    plt.axhline(y=eqTemp,label='Equilibrium Temp',ls='--',color='red')\n    plt.title(f'Average car temperature when air temp is {airTemp:.0f} C.') \n    plt.xlabel('Time (s)')\n    plt.ylabel('Temperature (C)')\n    plt.legend(bbox_to_anchor=(1.05,0.75))\n    plt.show()\n    \nplotTemperature(longCalc.y)\n\n\n\n\n\n\n\n\nAs we see that the temperature is not uniform at every point in the hot box, it becomes clear that assumption of uniform temperature is not appropriate. Since we see there is still a temperature gradient along the z-direction, conduction is still important in this system, and contributes to the equilibrium. Still this rough approximation gave a good intuition about the dynamics of the system even if it wasn’t numerically accurate.\nNote, this assumes that the sun stays at “high noon” for at least 10 hours, so it isn’t representative of a real car on the surface of the earth. As such, it’s not worth exploring this further, except for the purposes of developing better visualizations."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#coming-soon",
    "href": "posts/heatEqn2/heatEqn2.html#coming-soon",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Coming soon",
    "text": "Coming soon\nSo far, this has been lots of equations, and not enough pictures. But this is a complex system, and I need to add one feature at a time to ensure that it is working correctly. My first order of business will be to make a surface heat map of what is going on so that it is easier to talk about and show everyone what is going on.\nI also need to develop code which allows for the sun to change it’s position. And I’ll deal with other issues such as seasonal changes/the varying length of day/night. As well as deal with latitude. I’ve been fiddling with the math on the back of napkins, and that should work nicely with some pretty pictures. Then we can compare hot boxes in higher latitudes to those with lower latitudes."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Steven Wolf - Data World",
    "section": "",
    "text": "Modeling Heat Flow - Part 2\n\n\n\n\n\n\nHeat Equation\n\n\nPython\n\n\nModeling\n\n\n3D system\n\n\nFinite Difference Method\n\n\nBlackbody Radiation\n\n\n\nTurning up the heat on the Heatbox\n\n\n\n\n\nDec 9, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nModeling Heat Flow\n\n\n\n\n\n\nHeat Equation\n\n\nPython\n\n\nModeling\n\n\n3D system\n\n\nFinite Difference Method\n\n\n\nTorture is bad. Also, half of my house gets too warm/cold, and that’s not my favorite.\n\n\n\n\n\nNov 3, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nStack Overflow Annual Developer Survey\n\n\n\n\n\n\ntidyTuesday\n\n\nR\n\n\n\nWhere are Stack Overflow users working from? Let’s find out.\n\n\n\n\n\nSep 5, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nEnglish Monarchy\n\n\n\n\n\n\ntidyTuesday\n\n\nR\n\n\n\n\n\n\n\n\n\nAug 20, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nWorld’s Fairs\n\n\n\n\n\n\ntidyTuesday\n\n\nR\n\n\nmaps\n\n\n\nI’ve always wanted to play with making a map-based visualization\n\n\n\n\n\nAug 14, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nScraping Weather Data-Proof of concept\n\n\n\n\n\n\nweather\n\n\npython\n\n\nweb-scraping\n\n\n\nScraping weather data near Zebulon, NC\n\n\n\n\n\nAug 8, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nOlympic countries: Fun facts and visualizations\n\n\n\n\n\n\ntidyTuesday\n\n\nR\n\n\n\nCountries by participation and medal count\n\n\n\n\n\nAug 7, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nSummer Movies\n\n\n\n\n\n\ntidyTuesday\n\n\nR\n\n\n\nAnalyzing the IMDB for movies with ‘summer’ in the title\n\n\n\n\n\nAug 2, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a physicist by training, but a Data Scientist by practice. I’ve been coding things in R and Python for several years, and I created this website as a place to put my fun projects, organize my thoughts, and do other data science related things. You can find me on LinkedIn, Github, and Google Scholar (links below). You can find me active within different Data Science spheres including #TidyTuesday and the Data Science Learning Community. When I’m not at work, or playing with data, you can find me outside, I love to go hiking and kayaking."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\nMichigan State University | East Lansing, MI  Ph.D. in Physics 2006-2012\nDartmouth College | Hanover, NH  M.S. in Physics 2003-2005\nValparaiso University | Valparaiso, IN  B.S. in Physics and Mathematics 1999-2003"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About",
    "section": "Experience",
    "text": "Experience\n\nEast Carolina University | Assistant Professor of Physics | August 2015 -present\nTexas State University | Physics Lecturer | August 2014 - August 2015\nMichigan State University | Research Associate | August 2012 - August 2014"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "Steven Wolf - Data World",
    "section": "",
    "text": "This is the weblog so I can do some #TidyTuesday activities and play with Quarto.\nGo to the webpage here: datawolf04.github.io"
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html",
    "href": "posts/summerMovies/summerMovies.html",
    "title": "Summer Movies",
    "section": "",
    "text": "This week we’re exploring “summer” movies: movies with summer in their title!\nThe data this week comes from the Internet Movie Database.\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(showtext)\nlibrary(janitor)\nlibrary(ggdist)\nlibrary(ggrepel)\nlibrary(scales)\nlibrary(paletteer)\n\nload('summerMovie.RData')"
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html#popularity-of-movie-by-year",
    "href": "posts/summerMovies/summerMovies.html#popularity-of-movie-by-year",
    "title": "Summer Movies",
    "section": "Popularity of movie by year",
    "text": "Popularity of movie by year\nIn some sense how well-known or popular a movie is should depend on the year. I’m guessing that very old movies may not have as many votes in the IMDB system. This could also bias the ratings\n\nggplot(summer_movies, aes(x=year,y=num_votes)) +\n  geom_point(color=oneCol) + \n  labs(\n    x = \"Year movie released\",\n    y = \"Number of ratings\",\n    caption = caption_text\n  ) + theme_simple()\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nI can definitely see that there is a volume bias towards newer movies. Let’s explore if this shows up in the ratings.\n\nggplot(summer_movies, aes(x=num_votes, y=average_rating, color=year)) +\n  geom_point() + \n  scale_x_log10(breaks = trans_breaks(\"log10\", function(x) 10^x),\n                labels = trans_format(\"log10\", math_format(10^.x))) +\n  scale_y_continuous(limits = c(0,10)) + \n  scale_color_paletteer_c(col_pal_cont) +\n  labs(\n    x = \"Number of ratings\",\n    y = \"Average rating\",\n    color = \"Year\",\n    caption = caption_text\n  ) + theme_simple()\n\n\n\n\n\n\n\n\nI’d say that there are no truly universally bad summer movies (for example with everyone scoring it a 0 or 1 out of 10). Despite the recency bias in the rating volume, it would seem that movies can be rated poorly or highly regardless of the year the movie was released. It also seems like there is a “reversion to the mean” effect for movies that have more votes, although this could simply be the result of sparse data. By “reversion to the mean” I am referring to the vaguely triangular shape of the blob of points, suggesting that as a movie is rated more and more, the diversity of opinion forces the mean rating to tend away from extreme values."
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html#re-imagining-other-work",
    "href": "posts/summerMovies/summerMovies.html#re-imagining-other-work",
    "title": "Summer Movies",
    "section": "Re-imagining other work",
    "text": "Re-imagining other work\nAs I’m doing this a bit late in the game, I can take advantage of the work some others have done. I saw this plot, and thought it would be good to replicate here, with a subtle twist.\n\nRather than plotting mean values for each genre, I thought I’d make a box plot instead of plotting the average rating. So I will tidy up the data. Furthermore, since I’m creating a box plot, I’m going to remove genres with fewer than \\(N=5\\) ratings.\n\nglobalMedian = median(summer_movies$average_rating, na.rm = TRUE)\ngDat &lt;- summer_movies |&gt; separate_longer_delim(cols = genres, delim = \",\") |&gt;\n  group_by(genres) \n\nnewGenre &lt;-  gDat |&gt;\n  summarise(\n    count = n(),\n    rating = median(average_rating, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\ndata4plot = full_join(newGenre,gDat,by=\"genres\") |&gt;\n  mutate(\n      genre_count = str_glue(\"{genres} ({count})\"),\n      genre_count = fct_reorder(genre_count, rating, .desc = FALSE),\n      highlight = ifelse(rating &gt;= globalMedian, \"yes\",\"no\")\n      ) |&gt;\n  filter(count&gt;=5)\n\nAnd finally, the plot.\n\nggplot(data4plot, aes(x=average_rating, y=genre_count, fill=highlight)) +\n  geom_vline(\n    xintercept = globalMedian,\n    linewidth = .5,\n    color = 'gray'\n    ) +\n  geom_boxplot() +\n  labs(\n    x = \"Rating\",\n    y = \"Movie Genre (count)\",\n    caption = caption_text\n  ) +\n  scale_x_continuous(breaks = seq(2,10,by=1), limits=c(2,10)) +\n  scale_y_discrete() +\n  scale_fill_paletteer_d(col_pal_dis) +\n  coord_cartesian(clip='off') + theme_catY()"
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html#final-notes",
    "href": "posts/summerMovies/summerMovies.html#final-notes",
    "title": "Summer Movies",
    "section": "Final notes",
    "text": "Final notes\nI just found out about #TidyTuesday, just this week, and I want to participate. So the purpose of this post is mostly to get a blog going, and I hope to update approximately monthly. Now that this post is written, we’ll see if I can get this onto Github Pages. 😄\n[Edit: Phew! That worked!]"
  },
  {
    "objectID": "posts/weatherScrape240808/weatherScrape.html",
    "href": "posts/weatherScrape240808/weatherScrape.html",
    "title": "Scraping Weather Data-Proof of concept",
    "section": "",
    "text": "My friend, Ben Leese, was telling me about his most recent project. He has a passion for going through old naturalist’s notebooks and pulling out data from the depths of that analog mess and bringing it into the digital world. He was talking to me about how weather could impact different bird behaviors. But he only had binary weather data (Yes, it rained/No, it didn’t rain). Furthermore, it was from Raleigh, NC rather than Zebulon, NC. While these places are close on the map, weather is even more local than politics. So I said that I’d try to find some better weather data for him.\nI found this helpful python script for scraping the weather data from Weather Underground, which I will adapt to my purpose.\n\nimport time\nimport sys\n\nimport numpy as np\nimport pandas as pd\nfrom bs4 import BeautifulSoup as BS\nfrom selenium import webdriver\nfrom great_tables import GT\nfrom scrape_wunderground import *\n\nI will scrape weather from the BreakingWind station with code KNCZEBUL74 on 8/1/2024, as I am pretty sure this is the closest station to the desired location.\n\nstation_id = \"KNCZEBUL74\"\ndate_id = \"2024-08-01\"\n\n(\n  GT(scrape_wunderground(station_id,date_id).head(20))\n    .tab_options(\n      column_labels_background_color = \"#3B3A3EFF\",\n  )\n)\n\n\n\n\n\n\n\ntimestamps\nTemperature\nDew Point\nHumidity\nWind Speed\nWind Gust\nPressure\nPrecip. Rate\nPrecip. Accum.\n\n\n\n\n2024-08-01 12:04 AM\n75.0\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:09 AM\n75.0\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:14 AM\n75.0\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:19 AM\n74.8\n72.0\n91.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:24 AM\n74.8\n72.0\n91.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:29 AM\n74.8\n72.0\n91.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:34 AM\n74.7\n72.0\n92.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:39 AM\n74.7\n72.0\n92.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:44 AM\n74.6\n72.0\n92.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:49 AM\n74.5\n72.6\n93.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:54 AM\n74.5\n73.0\n93.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:59 AM\n74.7\n73.0\n93.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 1:04 AM\n74.7\n73.0\n93.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:09 AM\n74.7\n72.3\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:14 AM\n74.7\n72.2\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:19 AM\n74.6\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:24 AM\n74.5\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:29 AM\n74.5\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:34 AM\n74.5\n72.9\n93.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:39 AM\n74.5\n73.0\n93.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n\n\n\n\n        \n\n\nAnd it works! That being said, I’ll have to find a different weather station because this one seems somewhat new. There is only partial data for 5/29/2024.\n\ndate_id = \"2024-05-29\"\n(\n  GT(scrape_wunderground(station_id,date_id).head(20))\n    .tab_options(\n      column_labels_background_color = \"#3B3A3EFF\",\n  )\n)\n\n\n\n\n\n\n\ntimestamps\nTemperature\nDew Point\nHumidity\nWind Speed\nWind Gust\nPressure\nPrecip. Rate\nPrecip. Accum.\n\n\n\n\n2024-05-29 10:34 PM\n71.2\n51.2\n50.0\n0.2\n0.2\n29.93\n0.0\n0.0\n\n\n2024-05-29 10:39 PM\n71.7\n53.9\n54.0\n1.4\n9.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:44 PM\n73.1\n55.1\n53.0\n0.8\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:49 PM\n72.8\n54.9\n53.0\n0.0\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:54 PM\n72.4\n53.5\n52.0\n0.0\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:59 PM\n72.2\n53.0\n52.0\n0.0\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 11:04 PM\n72.1\n53.0\n52.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:09 PM\n72.0\n53.0\n52.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:14 PM\n71.9\n52.1\n51.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:19 PM\n71.8\n51.8\n51.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:24 PM\n71.6\n51.6\n51.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:29 PM\n71.6\n51.0\n50.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:34 PM\n71.4\n51.0\n49.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:39 PM\n71.3\n51.0\n49.0\n0.0\n8.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:44 PM\n71.2\n50.1\n48.0\n0.0\n2.0\n29.95\n0.0\n0.1\n\n\n2024-05-29 11:49 PM\n71.1\n50.0\n47.0\n0.0\n1.3\n29.95\n0.0\n0.1\n\n\n2024-05-29 11:54 PM\n71.1\n50.0\n47.0\n0.0\n0.0\n29.94\n0.0\n0.1\n\n\n2024-05-29 11:59 PM\n70.9\n50.0\n47.0\n0.0\n0.0\n29.94\n0.0\n0.1\n\n\n\n\n\n\n        \n\n\nAnd 5/28/2024 has no data.\n\ndate_id = \"2024-05-28\"\n(\n  GT(scrape_wunderground(station_id,date_id).head(20))\n    .tab_options(\n      column_labels_background_color = \"#3B3A3EFF\",\n  )\n)\n\n\n\n\n\n\n\ntimestamps\nTemperature\nDew Point\nHumidity\nWind Speed\nWind Gust\nPressure\nPrecip. Rate\nPrecip. Accum.\n\n\n\n\n\n\n\n\n        \n\n\nI will have to find a different nearby weather station for this purpose of finding Ben some weather data for the time period he is interested in (mid 1970s). And, once I succeed at that, I will have to aggregate the 5-minute data to daily data. But once that’s done, my friend should have more than enough weather data to help him with his model."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html",
    "href": "posts/heatEqn1/modelHeatFlow.html",
    "title": "Modeling Heat Flow",
    "section": "",
    "text": "I have a house, and I need to improve the heating/cooling in it. Essentially, the problem is that my house is a long and narrow, and the air return is not able to sufficiently draw the cold/hot air from rooms on the far side of the house. Essentially, the air return/exchange system is not sufficient. As a result, half of my house is really hot in the summer/extra chilly in the winter.\nThere is some ducting in place intended to aid circulation, but it is ineffective as it doesn’t draw any air from the hot/cold room, relying on diffusion only to drive circulation. Furthermore, it is located in a bedroom rather than the living room which is significantly larger, more distant from the return, and–as a result–has the largest temperature problem. I am planning on installing a duct fan, which will help solve this problem. But that leaves these questions:\n\nHow strong should my duct fan be?\nWill the existing return be enough to alleviate the problem by simply adding in a duct fan?\nIf the answer to the previous question is no, where should I put another vent to make the biggest impact?\n\nI figure I can use my physics brain, and a little code to analyze this problem. So I’m going to spend some time figuring out how to implement the heat equation with appropriate boundary conditions applying them to scenarios that are progressively more complex, until I feel that I can apply them to my own house."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#personal-motivation-for-this-post",
    "href": "posts/heatEqn1/modelHeatFlow.html#personal-motivation-for-this-post",
    "title": "Modeling Heat Flow",
    "section": "",
    "text": "I have a house, and I need to improve the heating/cooling in it. Essentially, the problem is that my house is a long and narrow, and the air return is not able to sufficiently draw the cold/hot air from rooms on the far side of the house. Essentially, the air return/exchange system is not sufficient. As a result, half of my house is really hot in the summer/extra chilly in the winter.\nThere is some ducting in place intended to aid circulation, but it is ineffective as it doesn’t draw any air from the hot/cold room, relying on diffusion only to drive circulation. Furthermore, it is located in a bedroom rather than the living room which is significantly larger, more distant from the return, and–as a result–has the largest temperature problem. I am planning on installing a duct fan, which will help solve this problem. But that leaves these questions:\n\nHow strong should my duct fan be?\nWill the existing return be enough to alleviate the problem by simply adding in a duct fan?\nIf the answer to the previous question is no, where should I put another vent to make the biggest impact?\n\nI figure I can use my physics brain, and a little code to analyze this problem. So I’m going to spend some time figuring out how to implement the heat equation with appropriate boundary conditions applying them to scenarios that are progressively more complex, until I feel that I can apply them to my own house."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#heat-equation",
    "href": "posts/heatEqn1/modelHeatFlow.html#heat-equation",
    "title": "Modeling Heat Flow",
    "section": "Heat Equation",
    "text": "Heat Equation\nAll of this starts by understanding heat flow. The heat equation is:\n\\[\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2u\n\\]\nwhere \\(u = u(x,y,z,t)\\) is a function describing the temperature at every point in space and time in the region of interest and \\(\\alpha\\) is the Thermal Diffusivity of the material (which can depend on position as well). There are many boundary conditions that can be applied, but I will apply Robin Conditions which generally apply to convection/conduction.\n\\[\nk \\left. \\frac{\\partial u}{\\partial n}\\right|_{S} = h \\left(u(S,t) - v(S, t)\\right)\n\\]\nHere \\(n\\) is the direction of the outward normal of the boundary surface, \\(S\\) indicates a spatial point on the boundary surface, \\(k\\) is the thermal conductivity, \\(h\\) is the heat transfer coefficient, and \\(v\\) is the temperature on the other side of the boundary. This is the “Newton’s law of cooling” that you may have heard about in an introductory calculus class, although, it is usually presented as:\n\\[\n\\frac{dT}{dt} = -a(T-T_0)\n\\] where \\(a\\) is some sort of constant, and \\(T_0\\) is the temperature of the surroundings. What this means is that the steady-state behavior of this system is that it tends towards the temperature of the surroundings. This has limitations which I will discuss later."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#simple-system",
    "href": "posts/heatEqn1/modelHeatFlow.html#simple-system",
    "title": "Modeling Heat Flow",
    "section": "Simple system",
    "text": "Simple system\nAs a “simple” 3D system, I’ll model a “hot box” or “sweatbox” used by some for torture. This is not, nor should it be construed as an endorsement of torture. It’s just a simple box, and it gives me some intuitive knobs to use as I work this problem. Also, given the boundary condition that I previously mentioned, this means that the box can never be warmer than the surroundings. This isn’t fully realistic yet, as anyone who has seen a PSA about leaving kids/pets in a hot car even on a “cool” day. But there’s enough here to get me to start writing code.\n\nBox dimensions\nI will model this as a box with length \\(L\\), width \\(W\\), and height \\(H\\). I’ll orient my coordinate system so that the origin is in a lower corner and points \\((x,y,z)\\) in the region of interest are bounded by the following: \\(0\\leq x\\leq L\\), \\(0\\leq y \\leq W\\), and \\(0\\leq z \\leq H\\).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Length and time parameters (meters)\nL = 2\nW = 1\nH = 1\noneDay = 24*60*60 # seconds\nT = 10*oneDay # Let this run for several days\n\n\n\nThermal properties of the box\nI will assume that the box is uniform. That means no windows or ventilation. So \\(h\\) and \\(k\\) are constant and uniform on the boundary. According to Wikipedia, the thermal diffusivity of air is \\(1.9\\times 10^{-7}\\) m\\(^2\\)/s. According to this article by Jayamaha et.al., the heat transfer coefficient for walls varies from 6 to 10 \\(\\frac{\\text{W}}{\\text{m}^2 \\text{K}}\\). Looking at the greenspec.co.uk website it would seem that the thermal conductivity of most building materials is on the order of 0.02-0.04 \\(\\frac{\\text{W}}{\\text{m K}}\\).\n\n# Heat parameters\nalpha = 1.9e-7 # meters^2/s for air\nh = 10 # From Jayamaha\nk = 0.04 # From Greenspec\n\n\n\nModeling exterior temperature\nI’m going to assume the air temperature is time-dependent, and takes the form:\n\\[\nv^{\\text{air}}(t) = T_0 - \\Delta T \\cos\\left(\\Omega t\\right)\n\\]\nwhere \\(T_0\\) is the average temperature of the day, and \\(\\Delta T\\) represents the range of temperature. On the ground, I’ll assume the temperature is constant at \\(T_G\\). So \\(t=0\\) is sunrise. Making these parameters functions is overkill for now, but will be helpful as I get more complicated.\n\n# Temperature parameters\nT0 = 33\nDT = 6\nTG = 35\n\ndef vair(T0,DT,t):\n  Omega = 2*np.pi/oneDay\n  vair = T0 - DT * np.cos(Omega * t)\n  return vair\n\ndef vground(TG, t):\n  return TG"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#going-from-differential-equations-to-matrix-equations",
    "href": "posts/heatEqn1/modelHeatFlow.html#going-from-differential-equations-to-matrix-equations",
    "title": "Modeling Heat Flow",
    "section": "Going from differential equations to matrix equations",
    "text": "Going from differential equations to matrix equations\nThis is going to get a bit technical, and if you want to skip the details of the math behind the algorithm you can skip to the results in Section 5.\nEssentially, the basis for all numerical methods involving systems that evolve in space and time is to replace continuous space and time values with a discrete mesh of space and time values. For this system, we are looking for the temperature at every location in space and time. So we will do this on a reduced space/time grid. Instead of having a function of \\((x,y,z,t)\\) we will have a 4-dimensional matrix that I will denote as follows:\n\\[\nu(x,y,z,t) \\rightarrow u(x_i,y_j,z_k,t_l) = u^l_{ijk}\n\\]\nFor this I will define:\n\\[\n\\begin{align*}\nx_i &= i \\Delta x \\\\\ny_j &= j \\Delta y \\\\\nz_k &= k \\Delta z \\\\\nt_l &= l \\Delta t \\\\\n\\end{align*}\n\\]\nwhere \\(\\Delta x, \\Delta y, \\Delta z,\\) and \\(\\Delta t\\) are computational choices. Indeed, this freedom will allow me to choose \\(\\Delta x = \\Delta y = \\Delta z\\). I will choose \\(\\Delta x = 5\\) cm and \\(\\Delta t = 15\\) minutes. I’ll also define the max indices for this system, and also set up values for the grid. I will also set up the \\(u^l_{ijk}\\) grid, and fill it with a constant value. Actually, I will do this for two different initial temperatures. If my code is working correctly, the initial temperature of the box should not matter if we let the simulation run for long enough. Think about it this way: Imagine that you have two identical coolers, one filled with ice and the other empty. Now, let the coolers sit for a year in your yard. After that year, the coolers will no longer have a different temperature.\n\n# Computational parameters (time step and mesh size)\nDeltat = 60*15 # 15 minutes in seconds\nDeltax = 0.05  # 5 cm in meters\n\nxmax = int(L/Deltax)\nymax = int(W/Deltax)\nzmax = int(H/Deltax)\ntmax = int(T/Deltat)\n\nxmid = xmax // 2\nymid = ymax // 2\nzmid = zmax // 2\n\nt = np.linspace(0,T,tmax)\nxgrid = np.linspace(0,L,xmax+1)\nygrid = np.linspace(0,W,ymax+1)\nzgrid = np.linspace(0,H,zmax+1)\n\n# Initialize the array(s) with a few different initial temperatures.\nu = np.empty((tmax,xmax,ymax,zmax))\nuAlt = np.empty((tmax,xmax,ymax,zmax))\nu_init = T0-DT\nu.fill(u_init)\nuAlt_init = (T0+TG)/2\nuAlt.fill(uAlt_init)\n\n\nApplying the Finite difference method to the boundary condition\nThe boundary condition for conduction/convection states that the gradient of the temperature function at the boundary is proportional to the temperature difference across that boundary. For example on the surface where \\(x=0\\) (or \\(i=0\\)), the outward normal direction is in the \\(-x\\) direction: \\[\n\\left. k\\frac{\\partial u}{\\partial x}\\right|_{x=0} = h(u(x=0,y,z,t) - v(x=0,y,z,t))\n\\] I will apply the finite difference method to find the spatial derivatives. \\[\n\\begin{align*}\n\\frac{\\partial u}{\\partial x} &= \\frac{u^l_{i+1 jk}-u^l_{ijk}}{\\Delta x}   \\\\\n\\frac{\\partial u}{\\partial y} &= \\frac{u^l_{ij+1 k}-u^l_{ijk}}{\\Delta y}   \\\\\n\\frac{\\partial u}{\\partial z} &= \\frac{u^l_{ijk+1}-u^l_{ijk}}{\\Delta z}   \\\\\n\\end{align*}\n\\]\nTherefore, for \\(i=0\\) (the \\(x=0\\) boundary) we get: \\[\nu^l_{1jk} - u^l_{0jk} = \\frac{h\\Delta x}{k} \\left(u^l_{0jk} - v^l_{jk}\\right)\n\\] Solve for \\(u^l_{0jk}\\): \\[\nu^l_{0jk} = \\frac{u^l_{1jk} + \\beta v^l_{jk}}{1+\\beta}\n\\]\nwhere I have defined: \\[\n\\beta = \\frac{h \\Delta x}{k}\n\\] Note that if \\(\\beta = 0\\) boundary has an infinite thermal conductivity and \\(u^l_{0jk} = u^l_{1jk}\\) or \\(\\frac{\\partial u}{\\partial n} = 0\\). This is the Neumann Boundary Condition. If \\(\\beta\\rightarrow\\infty\\), we find \\(u^l_{0jk} = v^l_{jk}\\) and the temperature at the boundary is equal to the exterior temperature. This is the Dirichelet Boundary Condition.\nPlugging in some numbers, I’ll assume that the proportionality constant \\(\\beta\\) for heat exchange with the ground is 10 times larger than the same constant for heat exchange with the air.\nLet’s put this into code and apply the boundary condition to the initial array:\n\nbeta = h*Deltax/k\nbetaG = 5*beta\n\ndef applyBC(umat, tl):\n  t = tl*Deltat\n  umat[tl, 0, :, :] = (umat[tl, 1, :, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, xmax-1, :, :] = (umat[tl, xmax-2, :, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, :, 0, :] = (umat[tl, :, 1, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, :, ymax-1, :] = (umat[tl, :, ymax-2, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, :, :, 0] = (umat[tl, :, :, 1] + betaG * vground(TG,t))/(1+betaG)\n  umat[tl, :, :, zmax-1] = (umat[tl, :, :, zmax-2] + beta * vair(T0,DT,t))/(1+beta)\n  \n  return umat\n## Apply BCs at t=0 to finish initializing array\nu = applyBC(u, 0)\nuAlt = applyBC(uAlt,0)\n\n\n\nApplying the finite difference method to the heat equation: \\(\\dot{u} = \\alpha\\nabla^2u\\)\nI will again apply the finite difference method to find the derivatives. The first derivative in time is: \\[\n\\frac{\\partial u}{\\partial t} = \\frac{u^{l+1}_{ijk} - u^{l}_{ijk}}{\\Delta t}\n\\]\nAnother aspect of this method is that the Laplacian at any point can be calculated through the average of the difference between the nearest neighbors of that point and the point itself: \\[\n\\nabla^2 u(x,y,z,t) = \\frac{u^l_{i+1 jk} + u^l_{i-1 jk} +\n    u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk}}{(\\Delta x)^2}\n\\]\nThe heat equation becomes: \\[\nu^{l+1}_{ijk} = u^l_{ijk} + \\frac{\\alpha \\Delta t}{\\Delta x^2}\n    \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n\\] Basically, this equation gives us a method for finding the temperature after a time step given the temperature at the previous time step. I will define the dimensionless constant \\(\\gamma\\) as follows:\n\\[\n\\gamma = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n\\]\nso we finally obtain: \\[\nu^{l+1}_{ijk} = u^l_{ijk} + \\gamma \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} +\n      u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n\\]\nNow I will convert this to code:\n\ngamma = alpha*Deltat/Deltax**2\ndef calcHeatEqn(umat):\n    tm, xm, ym, zm = umat.shape\n    # Apply BCs\n    umat = applyBC(umat, 0)\n    for l in range(0,tm-1):\n      for i in range(1, xm-1):\n        for j in range(1, ym-1):\n          for k in range(1, zm-1):\n            umat[l+1,i,j,k] = umat[l,i,j,k] + gamma * (umat[l,i+1,j,k] + \n                  umat[l,i-1,j,k] + umat[l,i,j+1,k] + umat[l,i,j-1,k] + \n                  umat[l,i,j,k+1] + umat[l,i,j,k-1] - 6 * umat[l,i,j,k])\n      umat = applyBC(umat, l+1)\n    return umat\n\n\n\nVisualizing the temperature:\nThe grid will probably be too fine to visualize well on a 3d heatmap. So I’ll settle for some cross sections. The function plotheatmaps will plot heat maps inside the box for a given time in 3 perpendicular planes.\n\n\nCode\ndef plotheatmaps(umat,l,i,j,k):\n  Tmin = np.min([u.min(),T0-DT])\n  Tmax = np.max([u.max(),T0+DT])\n  \n  xSlice = umat[l,i,:,:].transpose()\n  ySlice = umat[l,:,j,:].transpose()\n  zSlice = umat[l,:,:,k].transpose()\n  \n  time = Deltat*l\n  tMins = time // 60\n  theMinutes = tMins % 60\n  \n  tHours = tMins // 60\n  theDays = tHours // 24\n  theHours = tHours % 24\n  \n  theTime = str(theDays) + \" days \" + str(theHours) + \" hrs \"  + str(theMinutes) + \" min\"\n\n  xC, yC, zC = [Deltax*i, Deltax*j, Deltax*k]\n  \n  fig, (ax0,ax1,ax2) = plt.subplots(ncols=3,width_ratios=[ymax,xmax,xmax],\n              figsize=(8,3))\n    \n  fig.suptitle(f\"Heatbox Temp at {theTime} \\n Outdoor Temp = {vair(T0,DT,time):.2f} C \\n Ground Temp = {vground(TG,time):.0f} C\")\n    \n  im0 = ax0.pcolormesh(ygrid, zgrid, xSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax0.set_aspect(1)\n  ax0.set_title(f\"x = {xC:.3f} m\")\n  ax0.set_xlabel(\"y\")\n  ax0.set_ylabel(\"z\")\n\n  im1 = ax1.pcolormesh(xgrid, zgrid, ySlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax1.set_aspect(1)\n  ax1.set_title(f\"y = {yC:.3f} m\")\n  ax1.set_xlabel(\"x\")\n  ax1.set_ylabel(\"z\")\n  \n  im2 = ax2.pcolormesh(xgrid, ygrid, zSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax2.set_aspect(1)\n  ax2.set_title(f\"z = {zC:.3f} m\")\n  ax2.set_xlabel(\"x\")\n  ax2.set_ylabel(\"y\")\n  \n  fig.tight_layout()\n  \n  cax = fig.add_axes([ax0.get_position().x0,ax0.get_position().y0-0.2,\n                ax2.get_position().x1 - ax0.get_position().x0, 0.02])\n  fig.colorbar(im2, cax = cax, orientation='horizontal')\n\n\nSo the initial condition has the following heatmap:\n\nplotheatmaps(u,0,xmid,ymid,zmid)\nplotheatmaps(uAlt,0,xmid,ymid,zmid)"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#sec-results",
    "href": "posts/heatEqn1/modelHeatFlow.html#sec-results",
    "title": "Modeling Heat Flow",
    "section": "Results",
    "text": "Results\nFinally, we will compute the time evolution of the temperature for the two scenarios.\n\nu = calcHeatEqn(u)\nuAlt = calcHeatEqn(uAlt)\n\n\nDifferent initial condition comparison\nI’m going to start by comparing the behavior of the system given different initial conditions for the starting temperature within the box. The hidden code below crunches the average temperatures for the plots in this and the following sections.\n\n\nCode\n## Calculate averages at every time step\nairTemp = np.zeros(tmax)\ngroundTemp = np.zeros(tmax)\nboxTemp = np.zeros(tmax)\nbtErr = np.zeros(tmax)\nboxTempAlt = np.zeros(tmax)\nbtaErr = np.zeros(tmax)\nboxTempZ = np.zeros((tmax,zmax))\nbtzErr = np.zeros((tmax,zmax))\nfor l in range(tmax):\n  airTemp[l] = vair(T0,DT,t[l])\n  groundTemp[l] = vground(TG,t[l])\n  ul = u[l, :, :, :]\n  ulAlt = uAlt[l, :, :, :]\n  boxTemp[l] = np.mean(ul)\n  boxTempAlt[l] = np.mean(ulAlt)\n  btErr[l] = np.std(ul)\n  btaErr[l] = np.std(ulAlt)\n  for k in range(zmax):\n    ulk = ul[:,:,k]\n    boxTempZ[l,k] = np.mean(ulk)\n    btzErr[l,k] = np.std(ulk)\n\n## Calcs for temp in the day\nstepsInDay = int(oneDay/Deltat)\ndays = int(T/oneDay)\nday = np.arange(0,days)\n\nboxTempDay = np.zeros(days)\nbtdErr = np.zeros(days)\nboxTempDayAlt = np.zeros(days)\nbtdaErr = np.zeros(days)\nboxTempDayZ = np.zeros((days,zmax))\nbtdzErr = np.zeros((days,zmax))\nfor d in range(days):\n    lmin = int(d*stepsInDay)\n    lmax = int((d+1)*stepsInDay)\n    ul = u[lmin:lmax, :, :, :]\n    boxTempDay[d] = np.mean(u[lmin:lmax, :, :, :])\n    boxTempDayAlt[d] = np.mean(uAlt[lmin:lmax, :, :, :])\n    btdErr[d] = np.std(u[lmin:lmax, :, :, :])\n    btdaErr[d] = np.std(uAlt[lmin:lmax, :, :, :])\n    for k in range(zmax):\n        boxTempDayZ[d,k] = np.mean(ul[:,:,:,k])\n        btdzErr[d,k] = np.std(ul[:,:,:,k])\n\n\nAs noted previously, after a long enough time, I expect two identical boxes to exhibit the same behavior regardless of their initial conditions–much in the way that the long-term behavior of a Damped-Driven Oscillator is independent of the initial conditions. Let’s check that out here:\n\nfig, (ax0, ax1) = plt.subplots(1,2,figsize=(8,4),sharey=True)\nax0.plot(t,boxTemp, '-', label=rf\"$T_i=${u_init:.0f}\")\nax0.plot(t,boxTempAlt, '--', label=rf\"$T_i=${uAlt_init:.0f}\")\nax0.set_xlabel('Time (s)')\nax0.set_ylabel('Temperature (deg C)')\nax0.legend()\n\nax1.plot(day,boxTempDay, 'o', label=rf\"$T_i=${u_init:.0f}\")\nax1.plot(day,boxTempDayAlt, 's', label=rf\"$T_i=${uAlt_init:.0f}\")\nax1.set_xlabel('Time (days)')\nax1.set_ylabel('Temperature (deg C)')\nax1.legend()\nplt.show()\n\n\n\n\n\n\n\n\nIt would seem that the 10 days that I have simulated is long enough for these systems to reach this “steady state” solution.\n\n\nCompare interior temperature to exterior temp\nI’m going to plot the external (air) temperature and compare it to the average temperature in the box, as well as consider the average temperature in horizontal slices as the change in time.\n\nplt.figure(figsize=(6.5,4))\nplt.plot(t,airTemp,label=\"Air Temp\",ls='dashed',linewidth=0.5)\nplt.errorbar(t,boxTemp,yerr=btErr, label=\"Avg. Box Temp\",linewidth=2, capsize=2, errorevery=24)\nplt.xlabel('Time (s)')\nplt.ylabel('Temperature (deg C)')\nfor k in reversed(range(0,zmax,zmax//5)):\n    zval = k*Deltax\n    labString = f\"Avg Temp at z={zval:.2f} m\"\n    plt.plot(t,boxTempZ[:,k],label=labString, linewidth=1)\n    \nplt.plot(t,groundTemp,label=\"Ground Temp\",ls=\"dashed\",linewidth=0.5)\nplt.legend(loc=\"center left\", bbox_to_anchor=(1.04,0.5))\nplt.show()\n\n\n\n\n\n\n\n\nJust to see that this is stabilizing, and to get an idea of how fast this stabilizes, I’m going to find a daily average temperature as above.\n\nplt.figure(figsize=(8,4))\nplt.errorbar(day,boxTempDay,yerr=btdErr, marker='o', label=\"Avg. Box Temp\",capsize=2,linewidth=2)\nplt.xlabel('Time (days)')\nplt.ylabel('Temperature (deg C)')\nfor k in reversed(range(0,zmax,zmax//5)):\n    zval = k*Deltax\n    labString = f\"Avg Temp at z={zval:.2f} m\"\n    plt.plot(day,boxTempDayZ[:,k], marker='o', label=labString) \n    \nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nHeatmaps\nLet’s view the middle cross sections every few hours on the last day:\n\nfor s in range(lmin,lmax,int(stepsInDay/12)):\n  plotheatmaps(u,s,xmid,ymid,zmid)"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#summary",
    "href": "posts/heatEqn1/modelHeatFlow.html#summary",
    "title": "Modeling Heat Flow",
    "section": "Summary",
    "text": "Summary\nThis is working as a proof of concept. Job 1: Done. But there’s more to be done.\n\nNext step\nAs a torture device, this leaves much to be desired. Right now, it’s no more effective than a chain-link fence from a temperature perspective. I’ll be working on adding in solar radiation in the next post.\n\n\nMy future plans:\nAs I seek to make this model more complex. I plan to do things that will slowly make my boring box look more like a house. Things like:\n\nMaking the box house sized and adding an appropriate number of windows.\nAdd in interior walls.\nAdd in heating and cooling."
  }
]