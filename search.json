[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a physicist by training, but a Data Scientist by practice. I’ve been coding things in R and Python for several years, and I created this website as a place to put my fun projects, organize my thoughts, and do other data science related things. You can find me on LinkedIn, Github, and Google Scholar (links below). You can find me active within different Data Science spheres including #TidyTuesday and the Data Science Learning Community. When I’m not at work, or playing with data, you can find me outside, I love to go hiking and kayaking."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\nMichigan State University | East Lansing, MI  Ph.D. in Physics 2006-2012\nDartmouth College | Hanover, NH  M.S. in Physics 2003-2005\nValparaiso University | Valparaiso, IN  B.S. in Physics and Mathematics 1999-2003"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About",
    "section": "Experience",
    "text": "Experience\n\nEast Carolina University | Assistant Professor of Physics | August 2015 -present\nTexas State University | Physics Lecturer | August 2014 - August 2015\nMichigan State University | Research Associate | August 2012 - August 2014"
  },
  {
    "objectID": "posts/ccPage/crossCountry.html",
    "href": "posts/ccPage/crossCountry.html",
    "title": "A new project: Cross Country Data Viz",
    "section": "",
    "text": "It’s been a while since I’ve posted on this portion of my blog. I’ve been getting geared up for my sons’ upcoming Cross Country seasons. As a former NCAA athlete in this sport (not good enough for a scholarship), I get very fired up this time of year. So I’ve been scraping some results from Milesplit and visualizing the team results."
  },
  {
    "objectID": "posts/ccPage/crossCountry.html#cross-country-scoring-primer",
    "href": "posts/ccPage/crossCountry.html#cross-country-scoring-primer",
    "title": "A new project: Cross Country Data Viz",
    "section": "Cross Country Scoring Primer",
    "text": "Cross Country Scoring Primer\nCross country races are scored as follows. Each team can have up to 7 athletes for scoring purposes. The team score is found by adding up the places of the top 5 athletes from each team. Low score wins. Teams that have 5 or 6 athletes will also receive scores.\n\nThe best possible Cross Country score is \\(1+2+3+4+5=15\\) points. A shut-out is when all 7 athletes from one team finish before the first athlete from the second team. In a dual meet (where there are only two teams) this results in a 15-50 score.\nIf two teams are tied, the tie is broken by the 6th and 7th athletes. (Fun fact, my senior year of high school, the team that won did so on this tie breaker. The 3rd place team was one point behind them. It was an incredibly tight race!)\n\nThis is the team score from the Fightertown Invitational where my son set a new PR!\n\n\n\n\n\n\nSource: nc.milesplit.com\n datawolf04  wolf-253b6625a\n\n\nFightertown XC Invitational Boys Varsity\n\n\nTeams\nAthlete Placements\nTeam Score\n\n\n\n\nCroatan\n1, 4, 8, 23, 59, 60, 62\n95\n\n\nWest Carteret\n15, 17, 21, 22, 31, 34, 39\n106\n\n\nLejeune\n2, 5, 12, 33, 57, 66, 79\n109\n\n\nSwansboro\n3, 7, 9, 29, 73\n121\n\n\nTerra Ceia Christian School\n16, 19, 20, 44, 47, 50, 93\n146\n\n\nPamlico County\n11, 18, 41, 49, 52, 54, 77\n171\n\n\nWhite Oak\n14, 30, 32, 45, 72, 89, 91\n193\n\n\nHavelock\n6, 35, 38, 53, 71, 85, 95\n203\n\n\nSouth Lenoir\n36, 40, 42, 48, 58, 68, 70\n224\n\n\nWilson Christian Academy\n10, 28, 46, 63, 84, 94\n231\n\n\nJacksonville\n24, 25, 51, 64, 75, 76\n239\n\n\nD.H. Conley\n27, 55, 56, 61, 67, 82, 83\n266\n\n\nHeide Trask\n26, 43, 74, 88, 92, 98\n323\n\n\nRocky Mount High School\n13, 69, 78, 81, 96, 101, 104\n337\n\n\nRichlands\n37, 80, 97, 99, 100, 105\n413\n\n\nLiving Water Christian School\n65, 86, 87, 90, 102, 103, 106\n430\n\n\n\n\n\n\n\nThis is all well and good, and there are some string formatting things I could probably do. But this isn’t very visual."
  },
  {
    "objectID": "posts/ccPage/crossCountry.html#some-visualizations-that-ive-been-testing-out.",
    "href": "posts/ccPage/crossCountry.html#some-visualizations-that-ive-been-testing-out.",
    "title": "A new project: Cross Country Data Viz",
    "section": "Some visualizations that I’ve been testing out.",
    "text": "Some visualizations that I’ve been testing out.\nIt’s neat to see how the teams stack up. So the first visualization represents each athlete with a dot and each team with a color/row."
  },
  {
    "objectID": "posts/heatEqn2/hotBoxViz.html",
    "href": "posts/heatEqn2/hotBoxViz.html",
    "title": "Modeling Heat Flow - Part 2b",
    "section": "",
    "text": "I’ve been recently modeling a simple system using the heat equation. That last post was full of math, and finally got to making a nice looking visualization. But it was a long time to get there, and I wanted a post that got to the “pretty pictures” part much faster. Plus, I needed to spend time figuring out how to make them look nice. When the “do math” part of my brain fights with the “make it look good” part of my brain, the math part wins because if the math part loses, the looking good part doesn’t matter (because it’s probably wrong). But the “make it look good” part is equally important for good scientific communication. Therefore, this post is important too, and hopefully, more readable that the previous post.\n\n\nAs I wanted to get solar heat generation working, I started by making it simple. The premise was this. Consider the following information from The Humane Society.\n\n\nWhen it’s 72 degrees Fahrenheit outside, the temperature inside your car can heat up to 116 degrees Fahrenheit within an hour.\nWhen it’s 80 degrees Fahrenheit outside, the temperature inside your car can heat up to 99 degrees Fahrenheit within 10 minutes.\nRolling down the windows has been shown to have little effect on the temperature inside a car.\n\n\nAssume the above information is correct, and find appropriate parameters to make it so. I did that by assuming the sun is at solar noon (directly overhead) and we are getting direct sunlight at our particular latitude (so it is solar noon on the equinox/first day of spring/fall).\nBut that previous post was full of math, and I wanted to make some visualizations to show how the temperature changed. So I decided to simulate for a longer time and build some cool visuals. Since the time window is 10 hours, this is a bit of a “toy model.” (In physics, we call something a toy model when it has a feature that is clearly unrealistic, but helps us develop our intuition for a system, better understand how a key aspect effects a system, and/or develop tools for visualizing or analyzing a system.) But it should give me something to visualize. Later (not in this post) I will do some astrophysics to get the sun moving properly, and handle the latitude correctly so I can come back to earth."
  },
  {
    "objectID": "posts/heatEqn2/hotBoxViz.html#visualizing-a-hot-box",
    "href": "posts/heatEqn2/hotBoxViz.html#visualizing-a-hot-box",
    "title": "Modeling Heat Flow - Part 2b",
    "section": "",
    "text": "I’ve been recently modeling a simple system using the heat equation. That last post was full of math, and finally got to making a nice looking visualization. But it was a long time to get there, and I wanted a post that got to the “pretty pictures” part much faster. Plus, I needed to spend time figuring out how to make them look nice. When the “do math” part of my brain fights with the “make it look good” part of my brain, the math part wins because if the math part loses, the looking good part doesn’t matter (because it’s probably wrong). But the “make it look good” part is equally important for good scientific communication. Therefore, this post is important too, and hopefully, more readable that the previous post.\n\n\nAs I wanted to get solar heat generation working, I started by making it simple. The premise was this. Consider the following information from The Humane Society.\n\n\nWhen it’s 72 degrees Fahrenheit outside, the temperature inside your car can heat up to 116 degrees Fahrenheit within an hour.\nWhen it’s 80 degrees Fahrenheit outside, the temperature inside your car can heat up to 99 degrees Fahrenheit within 10 minutes.\nRolling down the windows has been shown to have little effect on the temperature inside a car.\n\n\nAssume the above information is correct, and find appropriate parameters to make it so. I did that by assuming the sun is at solar noon (directly overhead) and we are getting direct sunlight at our particular latitude (so it is solar noon on the equinox/first day of spring/fall).\nBut that previous post was full of math, and I wanted to make some visualizations to show how the temperature changed. So I decided to simulate for a longer time and build some cool visuals. Since the time window is 10 hours, this is a bit of a “toy model.” (In physics, we call something a toy model when it has a feature that is clearly unrealistic, but helps us develop our intuition for a system, better understand how a key aspect effects a system, and/or develop tools for visualizing or analyzing a system.) But it should give me something to visualize. Later (not in this post) I will do some astrophysics to get the sun moving properly, and handle the latitude correctly so I can come back to earth."
  },
  {
    "objectID": "posts/heatEqn2/hotBoxViz.html#code",
    "href": "posts/heatEqn2/hotBoxViz.html#code",
    "title": "Modeling Heat Flow - Part 2b",
    "section": "Code",
    "text": "Code\nImport block:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mc\nimport matplotlib.cm as cm\nfrom scipy.integrate import solve_ivp\n# The functions in `hotBoxToy` were developed in the previous post\nfrom hotBoxToy import *\n\n\nParameters are input in the code below, and the simulation runs based on the fit parameters from the previous analysis\n\n\nCode\n# Heat parameters\nthermalDiffusivity = 22.39e-6 # meters^2/s for air\nheatTransferCoef = 1 # For a typical metal to air W/m^2K\nthermalConductivity = 50 # For a typical metal W/mK\nspecificHeat = 1000 # for aluminum J/kg K\nwallDensity = 3000 # kg/m^3 for aluminum\nwallThickness = 0.002 # m\nsolarIntensity = 1000 # W/m^2\n\n# Length parameters (meters)\nL = 3\nW = 2\nH = 1.5\n\nDeltax = 0.05\nxmax = int(L/Deltax)\nymax = int(W/Deltax)\nzmax = int(H/Deltax)\n\nxmid = xmax // 2\nymid = ymax // 2\nzmid = zmax // 2\n\nxgrid = np.linspace(0,L,xmax+1)\nygrid = np.linspace(0,W,ymax+1)\nzgrid = np.linspace(0,H,zmax+1)\n\nu0 = np.empty((xmax,ymax,zmax))\n\noneHour = 3600\n# Best parameters from previous simulation\nA = 1.1176e-3\nB = 6.6667e-3\nlongCalc = simToyHotBox(A,B,oneHour*10, 100)"
  },
  {
    "objectID": "posts/heatEqn2/hotBoxViz.html#visualizations",
    "href": "posts/heatEqn2/hotBoxViz.html#visualizations",
    "title": "Modeling Heat Flow - Part 2b",
    "section": "Visualizations",
    "text": "Visualizations\nAnd now we have the pretty pictures. First we can observe how the heat changes in time.\n Many of the changes in this animation happens fast. As the Humane society stated, the car gets very hot, very fast. Please don’t leave your pets/kids/anything alive in a car baking in the sunlight. In fact, fellow Valparaiso University Beacon, Matthew Standridge used his van for baking cookies and cinnamon buns. I hope they were tasty!\nBack to this system–Below is a figure with 4 heatmaps on it showing the system at four times that are during this change in behavior.\n\n\nCode\ntimeIdx = [10, 20, 40, 80]\nxm, ym, zm = u0.shape\nY,X,Z = np.meshgrid(np.linspace(0,W,ym),np.linspace(0,L,xm),np.linspace(0,H,zm))\n \nkw = {\n    'vmin': longCalc.y.min(),\n    'vmax': longCalc.y.max(),\n    'levels': np.linspace(longCalc.y.min(),longCalc.y.max(), 10),\n}\n\ncnorm = mc.Normalize(vmin=longCalc.y.min(),vmax=longCalc.y.max())\ncbar = cm.ScalarMappable(norm=cnorm)\n\n# Set limits of the plot from coord limits\nxmin, xmax = 0, L\nymin, ymax = 0, W\nzmin, zmax = 0, H\nxt = np.arange(0,L+0.5,0.5)\nyt = np.arange(0,W+0.5,0.5)\nzt = np.arange(0,H+0.5,0.5)\n\ni = 0\nfig = plt.figure(figsize=(8,7))\ncellList = [221,222,223,224]\nfor cell in cellList:\n    l = timeIdx[i]\n    theTime = longCalc.t[l]\n    theTitle = f'Hot Box at t = {theTime:.0f} s'\n    umatFlat = longCalc.y[:,l]\n    umat = umatFlat.reshape((xm,ym,zm))\n    ax = fig.add_subplot(cell, projection='3d')\n    # Set title, limits, and labels\n    ax.set_title(theTitle)\n    ax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax],xlabel='X [m]',ylabel='Y [m]',zlabel='Z [m]',\n          xticks=xt,yticks=yt,zticks=zt)\n    # Set zoom and angle view\n    ax.view_init(40, -45, 0)\n    ax.set_box_aspect((xm,ym,zm), zoom=0.85)\n    ax.contourf(X[:, :, -1], Y[:, :, -1], umat[:, :, -1],\n                    zdir='z', offset=H, **kw)\n    ax.contourf(X[:, 0, :], umat[:, 0, :], Z[:, 0, :],\n                    zdir='y', offset=0, **kw)\n    ax.contourf(umat[-1, :, :], Y[-1, :, :], Z[-1, :, :],\n                    zdir='x', offset=L, **kw)\n    i += 1\n\nghLogo = u\"\\uf09b\"\nliLogo = u\"\\uf08c\"\ntxt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\nfig.subplots_adjust(bottom=0.05,right=0.8)\nplt.figtext(0.7,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\ncbar_ax = fig.add_axes([0.9, 0.05, 0.02, 0.7])\nfig.colorbar(cbar, cax=cbar_ax,label='Temperature [deg C]')\nplt.show()\n\n\n\n\n\n\n\n\n\nThese show a few features of importance:\n\nSymmetry in several ways. For example, if consider a point on the left side surface \\((x,0,z)\\), you should get the same temperature at the point \\((L-x,0,z)\\). Similar statements can be made for the front surface and the top surface. That is why I did not show the right, rear and bottom surfaces in this visualization.\nThe top gets hot – plenty hot. Like fry an egg on it, hot. Note that 180 deg C is about 350 deg F. That’s plenty hot to cook eggs. Based on the plot from the previous post, you can see that the top of the box gets to about 100 deg C at the hour mark–appropriate for boiling water.\nThe sides stay cool – as discussed previously, there is still going to be conduction going on, so the box doesn’t reach a uniform temperature.\n\n\nAmimation generation code\nFiguring out how to do the animation was an interesting task, especially since most of the examples in the documentation animate things like a position vs. time graph, showing where the object appears later in the motion, and dealing with 3d plots is different in matplotlib. The key to using this method for animating a figure is to name all of the features of the graph that are changing, and creating a function to update each of these features.\n\nimport matplotlib.animation as animation\n\ndef makeAni(fname,res,L,W,H,dx):\n    print(\"Building the animation\")\n    # Create figure with 3D axes\n    fig = plt.figure(figsize=(6,4))\n    ax = fig.add_subplot(111, projection='3d')\n    # Fill in the plot\n    theTime = res.t[0]\n    tmax = len(res.t)\n    theTitle = f'Hot Box at t = {theTime:.0f} s'\n    figTitle = fig.suptitle(theTitle)\n\n    xm, ym, zm = int(L/dx), int(W/dx), int(H/dx)\n    uflat = res.y[:,0]\n    umat = uflat.reshape((xm,ym,zm))\n    Y,X,Z = np.meshgrid(np.linspace(0,W,ym),np.linspace(0,L,xm),np.linspace(0,H,zm))\n\n    kw = {\n        'vmin': res.y.min(),\n        'vmax': res.y.max(),\n        'levels': np.linspace(res.y.min(),res.y.max(), 10),\n    }\n    cnorm = mc.Normalize(vmin=res.y.min(),vmax=res.y.max())\n    cbar = cm.ScalarMappable(norm=cnorm)\n    \n    # Plot contour surfaces\n    topSurf = ax.contourf(X[:, :, -1], Y[:, :, -1], umat[:, :, -1], zdir='z', offset=H, **kw)\n    frontSurf = ax.contourf(X[:, 0, :], umat[:, 0, :], Z[:, 0, :], zdir='y', offset=0, **kw)\n    leftSurf = ax.contourf(umat[-1, :, :], Y[-1, :, :], Z[-1, :, :], zdir='x', offset=L, **kw)\n    # --\n\n    # Set limits of the plot from coord limits\n    xmin, xmax = 0, L\n    ymin, ymax = 0, W\n    zmin, zmax = 0, H\n    ax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax])\n\n    # Set labels \n    ax.set(\n        xlabel='X [m]',\n        ylabel='Y [m]',\n        zlabel='Z [m]',\n        xticks = np.arange(0,L+0.5,0.5),\n        yticks = np.arange(0,W+0.5,0.5),\n        zticks = np.arange(0,H+0.5,0.5),\n    )\n\n    # Set zoom and angle view\n    ax.view_init(40, -45, 0)\n    ax.set_box_aspect((xm,ym,zm), zoom=1)\n\n    # Colorbar\n    fig.subplots_adjust(left=-1.75,bottom=0.2,right=0.9)\n    fig.colorbar(cbar, ax=ax, fraction=0.02, pad=0.075, \n      label='Temperature [deg C]')\n    ghLogo = u\"\\uf09b\"\n    liLogo = u\"\\uf08c\"\n    txt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\n    plt.figtext(0.5,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\n\n    def update(l):\n        if (l+1)%10==0:\n            print(f\"Working on frame {l+1} out of {tmax}.\")\n        uflat = res.y[:,l]\n        umat = uflat.reshape((xm,ym,zm))\n        theTime = res.t[l]\n        theTitle = f'Hot Box at t = {theTime:.0f} s'\n        figTitle = fig.suptitle(theTitle)\n        topSurf = ax.contourf(X[:, :, -1], Y[:, :, -1], umat[:, :, -1], zdir='z', \n          offset=H, **kw)\n        frontSurf = ax.contourf(X[:, 0, :], umat[:, 0, :], Z[:, 0, :], zdir='y', \n          offset=0, **kw)\n        leftSurf = ax.contourf(umat[-1, :, :], Y[-1, :, :], Z[-1, :, :], \n          zdir='x', offset=L, **kw)\n\n        return topSurf, frontSurf, leftSurf, figTitle\n\n    ani = animation.FuncAnimation(fig=fig, func=update, frames=tmax, \n      interval=50, repeat=False)\n    ani.save(fname,writer='pillow')    \n\n# Builds the animation\nmakeAni('hotboxLong.gif',longCalc,L,W,H,Deltax)"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html",
    "href": "posts/tt20240819/englishMonarchy.html",
    "title": "English Monarchy",
    "section": "",
    "text": "This week’s #TidyTuesday is all about exploring English Monarchs and Marriages!\nThe data was scraped from Ian Visits by f. hull, who also curated this week’s post!"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#data-cleaning",
    "href": "posts/tt20240819/englishMonarchy.html#data-cleaning",
    "title": "English Monarchy",
    "section": "Data cleaning",
    "text": "Data cleaning\nAs one might expect from a dataset that has been scraped from a webpage written by a London history/culture type, there is some inconsistency in how the data has been cataloged. And as the prompt for the week says, some of the early data is “fuzzy”. So I want to clean it up. Here is a quick look at the data:\n\n\nRows: 84\nColumns: 5\n$ sovereign_name   &lt;chr&gt; \"Æthelwulf\", \"Æthelwulf\", \"Æthelbald\", \"Æthelberht\", …\n$ sovereign_age    &lt;chr&gt; \"?\", \"50(?)\", \"24\", \"–\", \"?\", \"19\", \"19\", \"28\", \"31\",…\n$ consort_name     &lt;chr&gt; \"Osburh\", \"Judith of Flanders\", \"Judith of Flanders\",…\n$ consort_age      &lt;chr&gt; \"?\", \"12\", \"14\", \"–\", \"?\", \"16\", \"?\", \"?\", \"?\", \"–\", …\n$ year_of_marriage &lt;chr&gt; \"851(?)\", \"856\", \"858\", \"–\", \"?\", \"868\", \"893\", \"902\"…\n\n\nAs you can see above, uncertainty in the dataset is often indicated with ? or - being included in the string. Ultimately I want to work with numeric variables, for things like age and year, so I’m going to need to clean them up. I also want to track whether a date or age is uncertain, so I am going to create columns tracking that information. All of the queens in the dataset are named Mary, Elizabeth, Anne, or Victoria. Using str_detect and some OR logic, I believe that I have caught all of them.\n\n\nRows: 84\nColumns: 14\n$ sovereign_name       &lt;chr&gt; \"Æthelwulf\", \"Æthelwulf\", \"Æthelbald\", \"Æthelberh…\n$ sovereign_age        &lt;dbl&gt; NA, 50, 24, NA, NA, 19, 19, 28, 31, NA, NA, 22, N…\n$ consort_name         &lt;chr&gt; \"Osburh\", \"Judith of Flanders\", \"Judith of Flande…\n$ consort_age          &lt;dbl&gt; NA, 12, 14, NA, NA, 16, NA, NA, NA, NA, NA, NA, N…\n$ year_of_marriage     &lt;dbl&gt; 851, 856, 858, NA, NA, 868, 893, 902, 905, NA, NA…\n$ sovereign_age_unc    &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FAL…\n$ consort_age_unc      &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, TRU…\n$ year_of_marriage_unc &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FA…\n$ any_unc              &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE…\n$ sovereign_type       &lt;fct&gt; King, King, King, King, King, King, King, King, K…\n$ age_diff_pos         &lt;lgl&gt; NA, TRUE, TRUE, NA, NA, TRUE, NA, NA, NA, NA, NA,…\n$ age_diff             &lt;dbl&gt; NA, 38, 10, NA, NA, 3, NA, NA, NA, NA, NA, NA, NA…\n$ min_age              &lt;dbl&gt; NA, 12, 14, NA, NA, 16, NA, NA, NA, NA, NA, NA, N…\n$ max_age              &lt;dbl&gt; NA, 50, 24, NA, NA, 19, NA, NA, NA, NA, NA, NA, N…"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#plan",
    "href": "posts/tt20240819/englishMonarchy.html#plan",
    "title": "English Monarchy",
    "section": "Plan",
    "text": "Plan\nMake a plot with sovereign age and consort age vs. the year of marriage. On this plot I’m going to highlight:\n\nThe age gap. If both sovereign and consort have the age recorded in the data, there will be a vertical line drawn from the younger to the elder.\nThe gender of the sovereign. Kings are light blue and queens are pink.\nMarriages with uncertain data (either in the year or the ages of those involved) are more transparent so that they stand out less."
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#one-more-visualization",
    "href": "posts/tt20240819/englishMonarchy.html#one-more-visualization",
    "title": "English Monarchy",
    "section": "One more visualization",
    "text": "One more visualization\nPairs plots are fun, and the ggpairs function will automatically calculate some correlation values and put them on the plot as well. I’ve always done these using old school pairs and I thought it would be fun to look at one using the ggplot version. One big advantage is how it automatically uses the facet_grid framework to make the plots and include special plots along the diagonal. You could do the same thing with pairs, but it was more work.\nA few notes about this plot:\n\nThe density plots for the sovereign queens are “spikey” (for lack of a better term). There are just so few sovereign queens. Furthermore the age range at marriage is broad enough that this distribution is just not smooth. Until recently, the succession rules heavily favored male heirs. With the new rules recently adapted, maybe in another millenium or two, there will be enough sovereign queens that we can start approaching gender parity in this area.\nAlso, even though the sovereign queens were the monarch, they also were (in general) younger than their consort, while the opposite is true for the kings."
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#the-model-that-wasnt-quite-there",
    "href": "posts/tt20240819/englishMonarchy.html#the-model-that-wasnt-quite-there",
    "title": "English Monarchy",
    "section": "The model that wasn’t quite there",
    "text": "The model that wasn’t quite there\n\nI like making different kinds of models. I’m wondering if we can build a model for sovereign age at marriage given inputs like gender and year. I didn’t do it here, in part, because I think that there is other work to be done. In particular, how long a sovereign has been in power would be useful data to gather, as well as figuring out how to deal with multiple marriages such as the case of Henry VIII.\n\n\n\n# A tibble: 6 × 5\n  sovereign_name sovereign_age consort_name        consort_age year_of_marriage\n  &lt;chr&gt;          &lt;chr&gt;         &lt;chr&gt;               &lt;chr&gt;       &lt;chr&gt;           \n1 Henry VIII     18            Catherine of Aragon 24          1509            \n2 Henry VIII     42            Anne Boleyn         32          1533            \n3 Henry VIII     45            Jane Seymour        28          1536            \n4 Henry VIII     49            Anne of Cleves      25          1540            \n5 Henry VIII     49            Catherine Howard    19          1540            \n6 Henry VIII     52            Catherine Parr      31          1543"
  },
  {
    "objectID": "posts/tt20240819/englishMonarchy.html#ew",
    "href": "posts/tt20240819/englishMonarchy.html#ew",
    "title": "English Monarchy",
    "section": "Ew",
    "text": "Ew\nI thought about ignoring this, but 2024 me simply cannot. I know it was a different time. I am simply upset that a society allowed this sort of predatory behavior under the guise of a self-proclaimed and self-serving monarch declaring his divine right as well as the nobility that enabled and enforced this behavior in service of the accumulation of power. So I’m creating a table and calling it my “Hall of Shame.” I’m not sure that age difference in a relationship is the single best way for building this group, but that’s the data that I have in front of me to use.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHall of Shame\n\n\nPerpetraitor\nVictim\nΔ\nYear\n\n\nName\nAge\nName\nAge\n\n\n\n\nEdward I\n60\nMargaret of France\n20\n40\n1299\n\n\nÆthelwulf\n50\nJudith of Flanders\n12\n38\n856\n\n\nHenry I\n53\nAdeliza of Louvain\n18\n35\n1121\n\n\nHenry VIII\n49\nCatherine Howard\n19\n30\n1540\n\n\nWilliam IV\n53\nAdelaide of Saxe-Meiningen\n26\n27\n1818\n\n\nJames II\n40\nMary of Modena\n15\n25\n1673\n\n\n\n#TidyTuesday • Sources: Ian Visits and f. hull dataset"
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset2.html",
    "href": "posts/heatEqnReset/HeatEqnReset2.html",
    "title": "Using the Heat Equation to model a real-world system (Part 2)",
    "section": "",
    "text": "In my last post, I spoke about the issues with modeling a real-world system using the heat equation. Even the simplest 1D system promised some degree of pain. So I wanted to begin discussing numerical methods. I’ve been going through some materials created by the fenics project, and while what I’m presenting below will be somewhat based on those methods, I’m going to skip using their package (for now)."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset2.html#applying-the-finite-element-method-to-the-1d-robin-problem",
    "href": "posts/heatEqnReset/HeatEqnReset2.html#applying-the-finite-element-method-to-the-1d-robin-problem",
    "title": "Using the Heat Equation to model a real-world system (Part 2)",
    "section": "Applying the Finite Element Method to the 1D Robin problem",
    "text": "Applying the Finite Element Method to the 1D Robin problem\nIn my last post, I gave myself the following challenge:\n\nYour mission, should you choose to accept it, is to model a 1D object that has a length of 1, with a uniform initial temperature \\(T_0\\). The exterior temperature at each end of the rod is 0. Assume no heat escapes along the length of the rod.\n\nLet’s apply the Finite Element method to this problem. In general the setup is the same. We have: 1. The (1D) Heat Equation: \\[\n\\frac{\\partial u(x,t)}{\\partial t} - \\frac{\\partial^2 u(x,t)}{\\partial x^2} = 0\n\\] 2. The Initial Condition: \\(u(x,0)=T_0\\). 3. The Boundary conditions, one for each end at \\(x=0\\) and \\(x=1\\) \\[\nu(0,t) + b \\left. \\frac{\\partial u(x,t)}{\\partial x}\\right|_{x=0} = 0 \\qquad \\text{and} \\qquad u(1,t) - b\\left. \\frac{\\partial u(x,t)}{\\partial x}\\right|_{x=1} = 0\n\\]\n\nStep 1: Discretize the time variable.\nInstead of doing separation of variables using the usual analytic methods, we are going to define:\n\\[\nu^k(x) = u(x,t_k)\n\\] where \\(t_k = k \\Delta t\\). The parameter \\(\\Delta t\\) is something that can be freely chosen, and \\(k\\) is an index \\((0,1,2,\\ldots)\\). Substituting this in, we can write the following: 1. The (1D) Heat Equation: \\[\n\\frac{u^k(x)-u^{k-1}(x)}{\\Delta t} - \\frac{d^2 u^k(x)}{dx^2} = 0\n\\] 2. The Initial condition: \\[\nu^0(x) = T_0\n\\] 3. The boundary conditions: \\[\nu^k(0) + b \\left. \\frac{du^k(x)}{dx}\\right|_{x=0} = 0 \\qquad \\text{and} \\qquad u^k(1) - b \\left. \\frac{du^k(x)}{dx}\\right|_{x=1} = 0\n\\]\n\n\nStep 2: Convert the Heat Equation to a weak formulation\nThis is done by multiplying the PDE by a test function \\(v(x)\\) and integrating over the region of interest (in this case, \\(x\\in[0,1]\\)). \\[\n\\int_0^1 v(x) u^k(x) dx - \\Delta t \\int_0^1 v(x) \\frac{d^2u^k(x)}{dx^2} dx = \\int_0^1 v(x) u^{k-1}(x) dx\n\\]\nWe can now integrate the second term by parts: \\[\n\\begin{align*}\n\\int_0^1 v(x) \\frac{d^2u^k(x)}{dx^2} dx  &= \\left[ v(x) \\frac{du^k(x)}{dx} \\right]_0^1 - \\int_0^1 \\frac{dv(x)}{dx} \\frac{du^k(x)}{dx} dx \\\\\n  &= \\left[ -v(1) \\frac{u^k(1)}{b}  - v(0) \\frac{u^k(0)}{b} \\right] - \\int_0^1 \\frac{dv(x)}{dx} \\frac{du^k(x)}{dx} dx \\\\\n\\end{align*}\n\\] where the term in square brackets is given by applying the boundary conditions. So now we have two things to keep track of:\n\nThe Initial condition: \\[\nu^0(x) = T_0\n\\]\nThe weak formulation of the PDE/boundary condition \\[\n\\begin{align*}\n\\int_0^1 v(x) u^{k-1}(x) dx = \\int_0^1 v(x) u^k(x) dx &+ \\Delta t \\int_0^1 \\frac{dv(x)}{dx} \\frac{du^k(x)}{dx} dx \\\\\n& + \\frac{\\Delta t}{b} \\left[ v(1) u^k(1) + v(0) u^k(0) \\right]\n\\end{align*}\n\\] Notice that the LHS of this equation depends on the test function \\(v(x)\\) and the solution of the heat equation at the previous time-step \\(u^{k-1}(x)\\).\n\n\n\nStep 3: Discretize the spatial variable\nUltimately, this step will allow us to solve this problem as a linear-algebra problem, which is something that computers have been optimized to do very well. We do this by assuming the following: \\[\nu^k(x) = \\sum_{j=1}^N u_j^k \\varphi_j(x)\n\\] where \\(x_j = \\frac{j-1}{N-1}\\), \\(h=\\frac{1}{N}\\) and \\[\n\\varphi_j(x) =\n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_j\\right|}{h}\\right) &\\left|x-x_j\\right|\\leq h \\\\\n0 & \\text{else}\n\\end{cases}\n\\] This creates a uniform lattice of points. It should be noted that this choice of \\(\\varphi_j(x)\\) is method dependant. Also, when working in higher dimensions, a cartesian grid is not optimal. But this is what I’ll use for this problem.\n\nSimplify the Initial condition\nLet’s insert this definition of \\(u^k(x)\\) into our initial condition, multiply by \\(\\varphi_i(x)\\), and integrate over the region of interest: \\[\n\\int_0^1 dx \\varphi_i(x) \\sum_{j=1}^N u^0_j \\varphi_j(x) = \\int_0^1 dx \\varphi_i(x) T_0\n\\] We can simplify this by calculating the integrals: \\[\n\\int_0^1 dx \\varphi_i(x) =\n\\begin{cases}\n\\frac{h}{2} &i=1 \\text{ or } i=N \\\\\nh & \\text{else}\n\\end{cases}\n\\] and \\[\n\\int_0^1 dx \\varphi_i(x) \\varphi_j(x) =\n\\begin{cases}\n\\frac{h}{3} & (i=j=1) \\text{ or } (i=j=N) \\\\\n\\frac{2h}{3} & (i=j) \\text{ and } (i\\neq 1 \\text{ or } i\\neq N) \\\\\n\\frac{h}{6} & j=i\\pm 1 \\\\\n0 &\\text{else}\n\\end{cases}\n\\]\nRe-arranging terms, we can find \\(N\\) equations: \\[\n\\begin{align*}\n2 u_1^0 + u_2^0 = 3 T_0 &\\qquad i=1 \\\\\nu_{i-1}^0 + 4 u_i^0 + u_{i+1}^0 = 6 T_0 &\\qquad i\\neq 1, i\\neq N \\\\\nu_{N-1}^0 + 2u_N^0 = 3 T_0 &\\qquad i=N\n\\end{align*}\n\\]\nSince the initial temperature is uniform, this (quite sensibly) can be solved as: \\[\nu_i^0 = T_0\n\\]\n\n\nSimplify the weak formulation\nNext we will simplify the weak formulation describing the PDE and Boundary conditions assuming \\[\nu^k(x) = \\sum_{j=1}^N u_j^k \\varphi_j(x)\n\\] and \\[\nv(x) = \\varphi_i(x)\n\\]\nPlugging this in we get: \\[\n\\begin{align*}\n\\sum_{j=1}^N u_j^{k-1} \\int_0^1 dx \\varphi_i(x) \\varphi_j(x) = &\\sum_{j=1}^N u_j^k \\int_0^1 dx \\varphi_i(x) \\varphi_j(x) \\\\\n&+ \\sum_{j=1}^N \\Delta t u_j^k \\int_0^1 dx \\frac{d\\varphi_i(x)}{dx} \\frac{d\\varphi_j(x)}{dx} \\\\\n&+ \\frac{\\Delta t}{b} \\sum_{j=1}^N \\left[ \\varphi_i(1) u^k_j \\varphi_j(1) + \\varphi_i(0) u^k_j \\varphi_j(0) \\right]\n\\end{align*}\n\\]\nWe can simplify this again, but we will need to consider the integral below in addition to other integrals we have calculated previously. \\[\n\\int_0^1 dx \\frac{d\\varphi_i(x)}{dx} \\frac{d\\varphi_j(x)}{dx} =\n\\begin{cases}\n\\frac{1}{h} & (i=j=1) \\text{ or } (i=j=N) \\\\\n\\frac{2}{h} & (i=j) \\text{ and } (i\\neq 1 \\text{ or } i\\neq N) \\\\\n-\\frac{1}{h} & j=i\\pm 1 \\\\\n0 &\\text{else}\n\\end{cases}\n\\]\nFinally, we will note that by the definition of our \\(\\varphi_i(x)\\) function, we can simplify the values on the boundary as follows: \\[\n\\varphi_i(0) = \\delta_{i1} \\qquad \\text{and} \\qquad \\varphi_i(1) = \\delta_{iN}\n\\]\nThis leaves us with the following system of \\(N\\) equations to solve: \\[\n\\begin{align*}\n2\\left(1+\\frac{3(b+h)\\Delta t}{bh^2}\\right) u_0^k + \\left(1-\\frac{6\\Delta t}{h^2}\\right)u_1^k &= 2u_0^{k-1} + u_1^{k-1} \\quad i=1 \\\\\n\\left(1-\\frac{6\\Delta t}{h^2}\\right)u_{N-1}^k + 2\\left(1+\\frac{3(b+h)\\Delta t}{bh^2}\\right) u_N^k &= u_{N-1}^{k-1} + 2u_N^{k-1} \\quad i=N \\\\\n\\left(1-\\frac{6\\Delta t}{h^2}\\right)u_{i-1}^k + 4\\left(1+\\frac{3\\Delta t}{h^2}\\right) u_i^k + \\left(1-\\frac{6\\Delta t}{h^2}\\right)u_{i+1}^k &= u_{i-1}^{k-1} + 4u_i^{k-1} + u_{i+1}^{k-1}  \\\\\n&\\qquad i\\neq 1 \\text{ and } i\\neq N \\\\\n\\end{align*}\n\\]\nThis looks somewhat intimidating, but if we define: \\[\nA = 2\\left(1+\\frac{3(b+h)\\Delta t}{bh^2}\\right) \\quad B=4\\left(1+\\frac{3\\Delta t}{h^2}\\right) \\quad C=\\left(1-\\frac{6\\Delta t}{h^2}\\right)\n\\] we get \\[\n\\begin{align*}\nA u_0^k + C u_1^k &= 2u_0^{k-1} + u_1^{k-1} &\\quad i=1 \\\\\nC u_{N-1}^k + A u_N^k &= u_{N-1}^{k-1} + 2u_N^{k-1} &\\quad i=N \\\\\nCu_{i-1}^k + B u_i^k + Cu_{i+1}^k &= u_{i-1}^{k-1} + 4u_i^{k-1}  + u_{i+1}^{k-1}&\\quad i\\neq 1 \\text{ and } i\\neq N \\\\\n\\end{align*}\n\\] We can turn this into a matrix equation: \\[\nK U = G\n\\] where \\(U\\) is a \\((N\\times 1)\\) matrix made up of the \\(u_i^k\\)’s, \\(K\\) is (assuming \\(N=5\\))\n\\[\nK =\n\\begin{bmatrix}\nA & C & 0 & 0 & 0 \\\\\nC & B & C & 0 & 0 \\\\\n0 & C & B & C & 0 \\\\\n0 & 0 & C & B & C \\\\\n0 & 0 & 0 & C & A\n\\end{bmatrix}\n\\] and \\(G = G_s u^{k-1}\\) is made from the right hand side of the above equation:\n\\[\nG_s =\n\\begin{bmatrix}\n2 & 1 & 0 & 0 & 0 \\\\\n1 & 4 & 1 & 0 & 0 \\\\\n0 & 1 & 4 & 1 & 0 \\\\\n0 & 0 & 1 & 4 & 1 \\\\\n0 & 0 & 0 & 1 & 2\n\\end{bmatrix}\n\\] and \\[\nu^{k-1} =\n\\begin{bmatrix}\nu^{k-1}_1 \\\\\nu^{k-1}_2 \\\\\nu^{k-1}_3 \\\\\nu^{k-1}_4 \\\\\nu^{k-1}_5\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset2.html#lets-make-code",
    "href": "posts/heatEqnReset/HeatEqnReset2.html#lets-make-code",
    "title": "Using the Heat Equation to model a real-world system (Part 2)",
    "section": "Let’s make code!",
    "text": "Let’s make code!\nLet’s make some computational choices and code this up. First, I’ll begin by setting up the initial condition.\n\nimport numpy as np\n\nN = 101\nh = 1/(N-1)\ninitTemp = 10\nxi = np.linspace(0,1,N)\nu0 = initTemp * np.ones(N)\n\nNext, I’ll define the matrices on the LHS and RHS of the equation above, as well as a few parameters.\n\nb = 1\nDt = 0.1\ntMax = 3\ntVals = np.arange(0,tMax, Dt)\n\nA = 2*(1 + 3*Dt*(b+h)/(b*h**2))\nB = 4*(1 + 3*Dt/h**2)\nC = 1 - 6*Dt/h**2\n\n## Left hand side\nK = np.zeros([N,N])\nGsq = np.zeros([N,N])\nfor i in range(1,N-1):\n  K[i,i] = B\n  K[i, i-1] = C\n  K[i, i+1] = C\n  Gsq[i,i] = 4\n  Gsq[i,i-1] = 1\n  Gsq[i,i+1] = 1\n\nK[0, 0:2] = [A, C]\nK[N-1, N-2:] = [C, A]\nGsq[0, 0:2] = [2,1]\nGsq[N-1, N-2:] = [1,2]\n\nPython can find the new u-matrix in terms of the old u matrix in one line:\n\nnewU = np.linalg.solve(K,G)\n\nSo let’s build our solution:\n\nnSteps = int(tMax/Dt)\nU = np.zeros([N,nSteps])\nfor k in range(nSteps):\n  if(k==0):\n    newU = np.ones(N) * initTemp\n  else:\n    G = np.matmul(Gsq,oldU)\n    newU = np.linalg.solve(K,G)\n  U[:, k] = newU    \n  oldU = newU\n\nAnd let’s make a nice 3D plot of the solution:\n\nimport matplotlib.pyplot as plt\nT, X = np.meshgrid(tVals, xi)\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(T,X,U,cmap='magma')\nax.set_xlabel(r'$t$')\nax.set_ylabel(r'$x$')\nax.set_zlabel(r'$u$')\nplt.show()"
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset2.html#view-some-solutions",
    "href": "posts/heatEqnReset/HeatEqnReset2.html#view-some-solutions",
    "title": "Using the Heat Equation to model a real-world system (Part 2)",
    "section": "View some solutions:",
    "text": "View some solutions:\n[7/15/25 Minor update: The graph titles were not displaying enough significant digits, so I fixed the display.]\nNote, that we have a property that can change the dynamics of this system, namely \\(b\\), which is related to the (inverse of the) heat transfer coefficient. For the previous plot \\(b=1\\). Compare to these, where \\(b=5\\) and \\(b=0.5\\):\n\n\n\n\n\n\n\n\n\n\nLet’s compare this to the Dirichlet solution from the previous post. Note, there is a minor difference from the previous post. I have re-indexed the sum starting at 0 since python zero-indexes the functions there, and it’s just a little cleaner. \\[\nu(x,t) = \\sum_{n=0}^{\\infty} \\frac{4T_0}{(2n+1)\\pi}\\sin\\left((2n-+)\\pi x\\right) e^{-(2n+1)^2\\pi^2t}\n\\] First, let’s note that the only free parameter here is the initial temperature \\(T_0\\). There is no equivalent to the “inverse heat transfer coefficient” \\(b\\) that I defined for the Robin problem.\n\ndef uDirichelet(t,x,T0):\n  uD = 0\n  for n in range(200):\n    term = 4*T0/((2*n+1)*np.pi) * np.sin((2*n+1)*np.pi*x) * np.exp(-(2*n+1)**2 * np.pi**2 * t)\n    uD += term\n  return uD\n\nuD = np.zeros(U.shape)\nfor i in range(len(tVals)):\n  for j in range(len(xi)):\n    uD[j,i] = uDirichelet(tVals[i],xi[j],initTemp)\n\nfig = plt.figure()\nfig.suptitle(\"Temperature of 1D bar with Dirichelet boundary conditions\")\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(T,X,uD,cmap='magma')\nax.set_xlabel(r'$t$')\nax.set_ylabel(r'$x$')\nax.set_zlabel(r'$u$')\nplt.show()\n\n\n\n\n\n\n\n\nThis is similar to the Robin plot for a very small \\(b\\) value.\n\nuRobin(10,101,5,0.002,0.005).plotTemp()\n\n\n\n\n\n\n\n\nAlthough, it should be noted that this doesn’t have the odd bump that the Dirichlet solution has for small time values."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset2.html#where-to-go-from-here",
    "href": "posts/heatEqnReset/HeatEqnReset2.html#where-to-go-from-here",
    "title": "Using the Heat Equation to model a real-world system (Part 2)",
    "section": "Where to go from here",
    "text": "Where to go from here\nOk, so I’ve solved the 1D Robin problem, and compared it to the Dirichlet problem. Why not just make this 3D and roll my own from here?\n\nI need to redo all the math every time that I do different shapes/boundary conditions. It would sure be nice if someone else would do that for me. Like, programmatically. With a peer-reviewed software package.\nAs you go to 2D and 3D, a rectangular grid/mesh is not as numerically appropriate and can lead to unwanted errors. Quoting J.D. Jackson’s Graduate Electricity and Magnetism text:\n\n\nA square lattice is not optimal in many problems because the solution may change more rapidly in some parts of the domain of interest than in other parts. In such regions one wishes to have a finer mesh. An [Finite Element Analysis] method with a standard generic shape, but permitting different sizes, will be more flexible and therefore superior.\n\nSo, not only would I have to do painstaking math, I’d have to do slightly different painstaking math. As I have convinced myself that I know how the algorithm works, and why different steps are important, I’m comfortable using externally created code.\nIn my next post, I plan to solve the 1D problems I’ve solved here using the FENICS code. And this will let me generalize this to 3D as well as model a more realistic system."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinRod.html",
    "href": "posts/heatEqnReset/HeatEqnRobinRod.html",
    "title": "Using the Heat Equation to model a real-world system (Part 4)",
    "section": "",
    "text": "I’m still getting used to the FEniCSx software, so I’m going to go through the process of modeling a 1D rod, using Robin boundary conditions, and heavily annotating my code. This is (finally?) getting closer to a “real world” system, as it has the correct boundary condition describing convection. But it is still a 1D rod so, your mileage may vary.\n\n\nFirst, I’ll load in all of the dependencies required. There are a few “families” of dependencies that I’m including. These are:\n\nnumpy and matplotlib because they are standard python tools for dealing with tabular data and graphics\npetsc4py and mpi4py are libraries often used in FEniCSx code because they support parallelization and speed up computation.\ndolfinx is the package that I’m using to set up the Finite Element Method (part of FEniCSx)\nufl is a package with FEniCSx that translates a more convential mathematical notation into forms required by dolfinx. I like it when code “looks like” math/physics. (That’s why I teach students how to create cell names and named ranges when using Excel.)\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nfrom petsc4py import PETSc\nfrom mpi4py import MPI\n\nfrom dolfinx import default_scalar_type, io \nfrom dolfinx.fem import (Constant,  Function, functionspace, form)\nfrom dolfinx.fem.petsc import (LinearProblem, assemble_matrix, create_vector, \n                               assemble_vector, apply_lifting, set_bc)\nfrom dolfinx.mesh import create_interval, locate_entities, meshtags\nfrom ufl import (SpatialCoordinate, inner, ds, dx, Measure, TrialFunction, TestFunction, grad)\n\n\n\nNone of these will have units because I’m living in a willy-nilly world without units. (For now).\n\n\\(T_0 = 10\\) uniform initial temperature for the rod.\n\\(T_\\text{ext} = 0\\) uniform and constant temperature of the surroundings.\n\\(h = 0.5\\) “Heat conduction” coefficient between rod and surroundings\n\\(\\kappa = 1\\) “Thermal conductivity” of rod\nThe simulation will run for 5 DataWolfs (my new, made up dimensionless time unit)\n\\(dt = 0.1\\) Time step size.\n\\(L = 1\\) rod “length”\n\n\nt = 0 \nfinal_time = 5.0  # Final time for the simulation\ndt = 0.1  # Time step size\nnum_steps = int((final_time - t) / dt)  \nT0 = 10.0  # Initial uniform temperature of the rod\nextTemp = 0.0  # External temperature at the boundaries (constant)\ntPlot = np.linspace(0, final_time, num_steps+1)  # Time points for plotting\n\n# Define the mesh and function space\nn_elements = 32\n# Create a 1D domain representing the rod from 0 to 1\ndomain = create_interval(\n    MPI.COMM_WORLD,  # MPI communicator\n    n_elements,  # Number of elements in the mesh\n    [0.0, 1.0]  # Interval from 0 to 1 (the length of the rod)\n)\n\nx = SpatialCoordinate(domain)  # Spatial coordinates of the domain\ntempExt = lambda x: extTemp  # External temperature function (constant in this case)\ns = tempExt(x)  # External temperature at the boundary\nf = Constant(domain, PETSc.ScalarType(0))  # Source term (zero in this case)\nh = Constant(domain, PETSc.ScalarType(0.5))  # Robin boundary condition coefficient\nkappa = Constant(domain, PETSc.ScalarType(1.0))  # Thermal conductivity\n\n\n\n\n\nWe will create a function space that assumes linear elements between the grid degrees of freedom. This is the Galerkin method I talked about previously, where the basis functions are linear functions localized near each of the mesh points: \\[\n\\varphi_i =\n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_i\\right|}{h} \\right) &\\left|x-x_i\\right|\\leq h \\\\\n0 & \\text{else}\n\\end{cases}\n\\]\nI will create two functions in this function space:\n\nuPrev is the solution at the previous time step, representing the \\(u^{k-1}\\) in the linear form.\nuWork is the solution at the current time step, representing the \\(u^k\\) in the bilinear form.\n\n\n# Create a function space for the finite element method\nV = functionspace( \n    domain, ('Lagrange',1) # Linear Lagrange elements\n)\n\n# Create a constant function for the initial condition\ndef initial_condition(x):\n  return np.full(x.shape[1], T0, dtype=np.float64)  # Initial temperature T0\n\nuPrev = Function(V)\nuPrev.name = \"uPrev\"  # Name the function for clarity\nuPrev.interpolate(initial_condition)  # Interpolate the initial condition into the function space\n\nuWork = Function(V)  # Function to hold the solution at the current time step\nuWork.name = \"uWork\"  # Name the function for clarity \nuWork.interpolate(initial_condition)  # Initialize with the same initial condition\n\n\n\n\nWe are using the Robin boundary condition, suitable for describing convection. \\[\n-\\kappa \\left(\\hat{n}\\cdot\\nabla\\right) u^k = h^k(u^k - s^k) \\quad \\forall x\\in\\{0,1\\}\n\\]\nThe code below starts with a python version of the above definition of where the boundary is, and then uses an automated process to convert that into a useful definition for dolfinx. I’m also defining the measures for integration based on these boundary definitions. Note that Fenics Tutorials usually have at least one surface that has an explicit Dirichlet boundary condition.\n\nboundaries = [\n  (1, lambda x: np.isclose(x[0], 0.0)),  # Left boundary located at x=0\n  (2, lambda x: np.isclose(x[0], 1.0))  # Right boundary located at x=1\n]\nfacet_indices, facet_markers = [], []\ntdim = domain.topology.dim\nfdim = tdim - 1  # Dimension of the facets (1D for a rod)\n\nfor (marker, locator) in boundaries:\n    facets = locate_entities(domain, fdim, locator)\n    facet_indices.append(facets)\n    facet_markers.append(np.full_like(facets, marker))\nfacet_indices = np.hstack(facet_indices).astype(np.int32)\nfacet_markers = np.hstack(facet_markers).astype(np.int32)\nsorted_facets = np.argsort(facet_indices)\nfacet_tag = meshtags(domain, fdim, facet_indices[sorted_facets], facet_markers[sorted_facets])\n\nbcs = []  # No Dirichlet boundary conditions, so we leave this empty\ndx = Measure(\"dx\", domain=domain)  # Define the measure for the volume integral\nds = Measure(\"ds\", domain=domain, subdomain_data=facet_tag)  # Define the measure for the boundary integral\n\n\n\n\nAs stated in previous posts, the variational formulation (note: \\(u^k \\rightarrow u\\)) for this problem is: \\[\na(u,v) = L(v)\n\\] where the bilinear form is: \\[\na(u,v) = \\int_\\Omega uv dx + \\int_\\Omega \\Delta t \\kappa \\nabla u \\cdot \\nabla v dx + \\sum_l \\int_{\\Gamma^R_l} \\frac{\\Delta t}{\\kappa}  u v ds\n\\] and the linear form (for the Robin condition only) is: \\[\nL(v) = \\int_\\Omega u^{k-1} v dx + \\int_\\Omega f v dx + \\sum_l \\int_{\\Gamma^R_l} \\Delta t h_l s_l v ds\n\\] Let’s define the trial function u and the test function v and set up these forms:\n\nu = TrialFunction(V)  # Trial function for the finite element method\nv = TestFunction(V)  # Test function for the finite element method\na = u * v * dx + dt * kappa * inner(grad(u), grad(v)) * dx  + dt * h / kappa * u * v * ds # Bilinear form for the RBC\nL = (uPrev + dt * f) * v * dx + dt * h / kappa * s * v * ds  # Linear form for the RBC\nbilinear_form = form(a)  # Bilinear form for the weak formulation\nlinear_form = form(L)  # Linear form for the weak formulation\n\n\n\n\nOne of the reasons that we use the Finite Element method is that computers are pretty good at doing linear algebra operations quickly. So we begin by setting up the linear algebra structures.\n\nA = assemble_matrix(bilinear_form, bcs=bcs)  # Assemble the matrix A\nA.assemble()  # Finalize the assembly of the matrix A\nb = create_vector(linear_form)  # Create a vector for the right-hand side\n\nNow let’s set up a framework to solve the linear system. Note, the 3rd and 4th lines below are talking about a “Preconditioner”. I spent some time figuring out what that was all about. It does a LU decomposition, which is a form of Gaussian Elimination (ish). Basically, its all about speeding things up knowing that this is a sparse matrix system (remember, only neighboring elements contribute due to the localization of the basis functions).\n\nsolver = PETSc.KSP().create(domain.comm)\nsolver.setOperators(A)  # Set the matrix A for the solver\nsolver.setType(PETSc.KSP.Type.PREONLY)  # Use a preconditioner\nsolver.getPC().setType(PETSc.PC.Type.LU)  # Use LU preconditioner\n\n\n\n\nI’m going to use a matplotlib surface plot to display my result rather than pyvista. I was playing around on StackExchange and came across a post that complained about why a pyvista version of a plot looked so ugly when matplotlib could do it so easily. The answer was basically, that the poster used pyvista correctly, it just contained data that was on vastly different scales. The answerer said something to the effect of, “You have to tell PyVista to lie to you.” My question (at least for now) is, “How does PyVista know my units are meaningful?” Since my units are not (yet) meaningful, I’ll stick with matplotlib. Plus, I always try to learn only one thing at a time.\n\nxMesh = domain.geometry.x[: ,0]\nTc, Xc = np.meshgrid(tPlot, xMesh)  # Create a mesh grid for plotting\nUc = np.zeros_like(Tc)\nUc[:, 0] = uWork.x.array  # Initial condition for plotting\n\n\n\n\nNow we need to advance in time, solving the linear system at each time-step. Note that the solver assumes that you are solving the equation: \\[\nA x = b\n\\] at each time step, so the linear form needs to be assembled into the vector b.\n\nfor i in range(num_steps):\n    t += dt  # Current time\n\n    # Update the RHS reusing the previous solution\n    with b.localForm() as loc_b:\n        loc_b.set(0.0)\n    \n    assemble_vector(b, linear_form)\n    apply_lifting(b, [bilinear_form], [bcs])  # Apply boundary conditions\n    b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)  # Update ghost values\n    set_bc(b, bcs)  # Set the boundary conditions\n\n    # Solve linear problem\n    solver.solve(b, uWork.x.petsc_vec)\n    # Put the solution in our uWork object\n    uWork.x.scatter_forward()\n\n    # Update the solution at the current time step for plotting\n    Uc[:, i+1] = uWork.x.array\n    \n    # Update solution at previous time step (uPrev)\n    uPrev.x.array[:] = uWork.x.array\n\n\n\n\nMake the plot the normal matplotlib way.\n\nfig, ax = plt.subplots(subplot_kw={'projection': '3d'},figsize=(8,7) ) # Create a 3D plot\nax.plot_surface(Xc, Tc, Uc, cmap='viridis', edgecolor='none')  # Plot the FENICS solution\nax.set_title(rf'$\\kappa = ${kappa.value:.2f}')\nax.set_xlabel('Position along the rod (x)')  # X-axis label\nax.set_ylabel('Time (t)')  # Y-axis label\nax.set_zlabel('Temperature (u)')  # Z-axis label\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.suptitle('Robin Problem for a Unit Rod')  # Overall title for the plot\nplt.subplots_adjust(top=0.9)  # Adjust the top margin to fit\nplt.show()  # Show the plot\n\n\n\n\n\n\n\n\n\n\n\nLet’s make this plot to compare with the one I made where I adjusted the heat transfer coefficient on my homemade version of the finite element method."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinRod.html#modeling-a-1d-unit-rod-with-convection",
    "href": "posts/heatEqnReset/HeatEqnRobinRod.html#modeling-a-1d-unit-rod-with-convection",
    "title": "Using the Heat Equation to model a real-world system (Part 4)",
    "section": "",
    "text": "I’m still getting used to the FEniCSx software, so I’m going to go through the process of modeling a 1D rod, using Robin boundary conditions, and heavily annotating my code. This is (finally?) getting closer to a “real world” system, as it has the correct boundary condition describing convection. But it is still a 1D rod so, your mileage may vary.\n\n\nFirst, I’ll load in all of the dependencies required. There are a few “families” of dependencies that I’m including. These are:\n\nnumpy and matplotlib because they are standard python tools for dealing with tabular data and graphics\npetsc4py and mpi4py are libraries often used in FEniCSx code because they support parallelization and speed up computation.\ndolfinx is the package that I’m using to set up the Finite Element Method (part of FEniCSx)\nufl is a package with FEniCSx that translates a more convential mathematical notation into forms required by dolfinx. I like it when code “looks like” math/physics. (That’s why I teach students how to create cell names and named ranges when using Excel.)\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nfrom petsc4py import PETSc\nfrom mpi4py import MPI\n\nfrom dolfinx import default_scalar_type, io \nfrom dolfinx.fem import (Constant,  Function, functionspace, form)\nfrom dolfinx.fem.petsc import (LinearProblem, assemble_matrix, create_vector, \n                               assemble_vector, apply_lifting, set_bc)\nfrom dolfinx.mesh import create_interval, locate_entities, meshtags\nfrom ufl import (SpatialCoordinate, inner, ds, dx, Measure, TrialFunction, TestFunction, grad)\n\n\n\nNone of these will have units because I’m living in a willy-nilly world without units. (For now).\n\n\\(T_0 = 10\\) uniform initial temperature for the rod.\n\\(T_\\text{ext} = 0\\) uniform and constant temperature of the surroundings.\n\\(h = 0.5\\) “Heat conduction” coefficient between rod and surroundings\n\\(\\kappa = 1\\) “Thermal conductivity” of rod\nThe simulation will run for 5 DataWolfs (my new, made up dimensionless time unit)\n\\(dt = 0.1\\) Time step size.\n\\(L = 1\\) rod “length”\n\n\nt = 0 \nfinal_time = 5.0  # Final time for the simulation\ndt = 0.1  # Time step size\nnum_steps = int((final_time - t) / dt)  \nT0 = 10.0  # Initial uniform temperature of the rod\nextTemp = 0.0  # External temperature at the boundaries (constant)\ntPlot = np.linspace(0, final_time, num_steps+1)  # Time points for plotting\n\n# Define the mesh and function space\nn_elements = 32\n# Create a 1D domain representing the rod from 0 to 1\ndomain = create_interval(\n    MPI.COMM_WORLD,  # MPI communicator\n    n_elements,  # Number of elements in the mesh\n    [0.0, 1.0]  # Interval from 0 to 1 (the length of the rod)\n)\n\nx = SpatialCoordinate(domain)  # Spatial coordinates of the domain\ntempExt = lambda x: extTemp  # External temperature function (constant in this case)\ns = tempExt(x)  # External temperature at the boundary\nf = Constant(domain, PETSc.ScalarType(0))  # Source term (zero in this case)\nh = Constant(domain, PETSc.ScalarType(0.5))  # Robin boundary condition coefficient\nkappa = Constant(domain, PETSc.ScalarType(1.0))  # Thermal conductivity\n\n\n\n\n\nWe will create a function space that assumes linear elements between the grid degrees of freedom. This is the Galerkin method I talked about previously, where the basis functions are linear functions localized near each of the mesh points: \\[\n\\varphi_i =\n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_i\\right|}{h} \\right) &\\left|x-x_i\\right|\\leq h \\\\\n0 & \\text{else}\n\\end{cases}\n\\]\nI will create two functions in this function space:\n\nuPrev is the solution at the previous time step, representing the \\(u^{k-1}\\) in the linear form.\nuWork is the solution at the current time step, representing the \\(u^k\\) in the bilinear form.\n\n\n# Create a function space for the finite element method\nV = functionspace( \n    domain, ('Lagrange',1) # Linear Lagrange elements\n)\n\n# Create a constant function for the initial condition\ndef initial_condition(x):\n  return np.full(x.shape[1], T0, dtype=np.float64)  # Initial temperature T0\n\nuPrev = Function(V)\nuPrev.name = \"uPrev\"  # Name the function for clarity\nuPrev.interpolate(initial_condition)  # Interpolate the initial condition into the function space\n\nuWork = Function(V)  # Function to hold the solution at the current time step\nuWork.name = \"uWork\"  # Name the function for clarity \nuWork.interpolate(initial_condition)  # Initialize with the same initial condition\n\n\n\n\nWe are using the Robin boundary condition, suitable for describing convection. \\[\n-\\kappa \\left(\\hat{n}\\cdot\\nabla\\right) u^k = h^k(u^k - s^k) \\quad \\forall x\\in\\{0,1\\}\n\\]\nThe code below starts with a python version of the above definition of where the boundary is, and then uses an automated process to convert that into a useful definition for dolfinx. I’m also defining the measures for integration based on these boundary definitions. Note that Fenics Tutorials usually have at least one surface that has an explicit Dirichlet boundary condition.\n\nboundaries = [\n  (1, lambda x: np.isclose(x[0], 0.0)),  # Left boundary located at x=0\n  (2, lambda x: np.isclose(x[0], 1.0))  # Right boundary located at x=1\n]\nfacet_indices, facet_markers = [], []\ntdim = domain.topology.dim\nfdim = tdim - 1  # Dimension of the facets (1D for a rod)\n\nfor (marker, locator) in boundaries:\n    facets = locate_entities(domain, fdim, locator)\n    facet_indices.append(facets)\n    facet_markers.append(np.full_like(facets, marker))\nfacet_indices = np.hstack(facet_indices).astype(np.int32)\nfacet_markers = np.hstack(facet_markers).astype(np.int32)\nsorted_facets = np.argsort(facet_indices)\nfacet_tag = meshtags(domain, fdim, facet_indices[sorted_facets], facet_markers[sorted_facets])\n\nbcs = []  # No Dirichlet boundary conditions, so we leave this empty\ndx = Measure(\"dx\", domain=domain)  # Define the measure for the volume integral\nds = Measure(\"ds\", domain=domain, subdomain_data=facet_tag)  # Define the measure for the boundary integral\n\n\n\n\nAs stated in previous posts, the variational formulation (note: \\(u^k \\rightarrow u\\)) for this problem is: \\[\na(u,v) = L(v)\n\\] where the bilinear form is: \\[\na(u,v) = \\int_\\Omega uv dx + \\int_\\Omega \\Delta t \\kappa \\nabla u \\cdot \\nabla v dx + \\sum_l \\int_{\\Gamma^R_l} \\frac{\\Delta t}{\\kappa}  u v ds\n\\] and the linear form (for the Robin condition only) is: \\[\nL(v) = \\int_\\Omega u^{k-1} v dx + \\int_\\Omega f v dx + \\sum_l \\int_{\\Gamma^R_l} \\Delta t h_l s_l v ds\n\\] Let’s define the trial function u and the test function v and set up these forms:\n\nu = TrialFunction(V)  # Trial function for the finite element method\nv = TestFunction(V)  # Test function for the finite element method\na = u * v * dx + dt * kappa * inner(grad(u), grad(v)) * dx  + dt * h / kappa * u * v * ds # Bilinear form for the RBC\nL = (uPrev + dt * f) * v * dx + dt * h / kappa * s * v * ds  # Linear form for the RBC\nbilinear_form = form(a)  # Bilinear form for the weak formulation\nlinear_form = form(L)  # Linear form for the weak formulation\n\n\n\n\nOne of the reasons that we use the Finite Element method is that computers are pretty good at doing linear algebra operations quickly. So we begin by setting up the linear algebra structures.\n\nA = assemble_matrix(bilinear_form, bcs=bcs)  # Assemble the matrix A\nA.assemble()  # Finalize the assembly of the matrix A\nb = create_vector(linear_form)  # Create a vector for the right-hand side\n\nNow let’s set up a framework to solve the linear system. Note, the 3rd and 4th lines below are talking about a “Preconditioner”. I spent some time figuring out what that was all about. It does a LU decomposition, which is a form of Gaussian Elimination (ish). Basically, its all about speeding things up knowing that this is a sparse matrix system (remember, only neighboring elements contribute due to the localization of the basis functions).\n\nsolver = PETSc.KSP().create(domain.comm)\nsolver.setOperators(A)  # Set the matrix A for the solver\nsolver.setType(PETSc.KSP.Type.PREONLY)  # Use a preconditioner\nsolver.getPC().setType(PETSc.PC.Type.LU)  # Use LU preconditioner\n\n\n\n\nI’m going to use a matplotlib surface plot to display my result rather than pyvista. I was playing around on StackExchange and came across a post that complained about why a pyvista version of a plot looked so ugly when matplotlib could do it so easily. The answer was basically, that the poster used pyvista correctly, it just contained data that was on vastly different scales. The answerer said something to the effect of, “You have to tell PyVista to lie to you.” My question (at least for now) is, “How does PyVista know my units are meaningful?” Since my units are not (yet) meaningful, I’ll stick with matplotlib. Plus, I always try to learn only one thing at a time.\n\nxMesh = domain.geometry.x[: ,0]\nTc, Xc = np.meshgrid(tPlot, xMesh)  # Create a mesh grid for plotting\nUc = np.zeros_like(Tc)\nUc[:, 0] = uWork.x.array  # Initial condition for plotting\n\n\n\n\nNow we need to advance in time, solving the linear system at each time-step. Note that the solver assumes that you are solving the equation: \\[\nA x = b\n\\] at each time step, so the linear form needs to be assembled into the vector b.\n\nfor i in range(num_steps):\n    t += dt  # Current time\n\n    # Update the RHS reusing the previous solution\n    with b.localForm() as loc_b:\n        loc_b.set(0.0)\n    \n    assemble_vector(b, linear_form)\n    apply_lifting(b, [bilinear_form], [bcs])  # Apply boundary conditions\n    b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)  # Update ghost values\n    set_bc(b, bcs)  # Set the boundary conditions\n\n    # Solve linear problem\n    solver.solve(b, uWork.x.petsc_vec)\n    # Put the solution in our uWork object\n    uWork.x.scatter_forward()\n\n    # Update the solution at the current time step for plotting\n    Uc[:, i+1] = uWork.x.array\n    \n    # Update solution at previous time step (uPrev)\n    uPrev.x.array[:] = uWork.x.array\n\n\n\n\nMake the plot the normal matplotlib way.\n\nfig, ax = plt.subplots(subplot_kw={'projection': '3d'},figsize=(8,7) ) # Create a 3D plot\nax.plot_surface(Xc, Tc, Uc, cmap='viridis', edgecolor='none')  # Plot the FENICS solution\nax.set_title(rf'$\\kappa = ${kappa.value:.2f}')\nax.set_xlabel('Position along the rod (x)')  # X-axis label\nax.set_ylabel('Time (t)')  # Y-axis label\nax.set_zlabel('Temperature (u)')  # Z-axis label\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.suptitle('Robin Problem for a Unit Rod')  # Overall title for the plot\nplt.subplots_adjust(top=0.9)  # Adjust the top margin to fit\nplt.show()  # Show the plot\n\n\n\n\n\n\n\n\n\n\n\nLet’s make this plot to compare with the one I made where I adjusted the heat transfer coefficient on my homemade version of the finite element method."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinRod.html#next-steps",
    "href": "posts/heatEqnReset/HeatEqnRobinRod.html#next-steps",
    "title": "Using the Heat Equation to model a real-world system (Part 4)",
    "section": "Next steps",
    "text": "Next steps\nI’m going to add in more dimensions, keeping the Robin condition. Specifically, I’m going to model a 2D sheet and a 3D box that are analogous to the above system. The rationale for this is that I want to start learning how to use pyvista, a 3D visualization tool that is used in many FEniCSx tutorials. It seems…unproductive…to use 2D/3D modeling tools to describe 1D systems.\nAfter that, I’ll need to do two things:\n\nGo back to the physics and make sure I can do units correctly. This is especially important for dealing with external heat sources.\nFigure out how to make composite boundaries. Ultimately, I want to model a house, so I need to figure out how I want to create walls, doors, and windows."
  },
  {
    "objectID": "posts/olympic240805/olympicMedalData.html",
    "href": "posts/olympic240805/olympicMedalData.html",
    "title": "Olympic countries: Fun facts and visualizations",
    "section": "",
    "text": "This week we’re exploring Olympics data!\nThe data this week comes from the RGriffin Kaggle dataset: 120 years of Olympic history: athletes and results, basic bio data on athletes and medal results from Athens 1896 to Rio 2016.\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(showtext)\nlibrary(janitor)\nlibrary(ggdist)\nlibrary(ggrepel)\nlibrary(scales)\nlibrary(paletteer)\nlibrary(gt)\n\n\nload('olympicMedalResults.RData')"
  },
  {
    "objectID": "posts/olympic240805/olympicMedalData.html#data-in-this-dataset",
    "href": "posts/olympic240805/olympicMedalData.html#data-in-this-dataset",
    "title": "Olympic countries: Fun facts and visualizations",
    "section": "Data in this dataset:",
    "text": "Data in this dataset:\nFirst, I am planning on analyzing the summer and winter olympics separately. Furthermore, it occurs to me that the year in this dataset should be treated as a factor variable, rather than a numeric variable. This will help if (for example) the olympics were skipped or postponed, and it will definitely help when the winter games were shifted by 2 years so that the intervals between games are uniform.\n\ncountryParticipation &lt;- olympics |&gt; count(noc) |&gt;\n  arrange(desc(n)) \n\nMy plan is to plot out participation, medal count, and gold medal count by country NOC region. The reason for this due to the fact that there are an obnoxious number of “teams” (1184) already in this dataset. Also, I don’t think that we want to track the results of “Osborne Swimming Club, Manchester” or “Phalainis ton Thorichtou ‘Psara’-3” on the same level as Spain, China, Brazil, USA, etc. As it stands, there are plenty of countries to keep track of! As it is, there are 230 national olympic committeees. For fun, let’s look at the least frequent participants.\n\n\n\n\n\n\n\n\n\n\n\n\nOlympic participant breakdown\n\n\n10 lowest participating countries\n\n\nCountry code\nParticipant #\n\n\n\n\nYAR\n11\n\n\nBRU\n10\n\n\nTLS\n9\n\n\nKOS\n8\n\n\nTUV\n7\n\n\nYMD\n5\n\n\nSSD\n3\n\n\nNBO\n2\n\n\nUNK\n2\n\n\nNFL\n1\n\n\n\n#TidyTuesday • Source: RGriffin Kaggle dataset\n\n\n\n\n\n\n\n\n\nAside: Ummm…\nWhat is NFL and who is the lone participant from there?\n\nolympics |&gt; filter(noc==\"NFL\") |&gt; glimpse()\n\nRows: 1\nColumns: 15\n$ id     &lt;dbl&gt; 36547\n$ name   &lt;chr&gt; \"Robert Arthur \\\"Bob\\\" Fowler\"\n$ sex    &lt;chr&gt; \"M\"\n$ age    &lt;dbl&gt; 21\n$ height &lt;dbl&gt; 170\n$ weight &lt;dbl&gt; 57\n$ team   &lt;chr&gt; \"Newfoundland\"\n$ noc    &lt;chr&gt; \"NFL\"\n$ games  &lt;chr&gt; \"1904 Summer\"\n$ year   &lt;dbl&gt; 1904\n$ season &lt;chr&gt; \"Summer\"\n$ city   &lt;chr&gt; \"St. Louis\"\n$ sport  &lt;chr&gt; \"Athletics\"\n$ event  &lt;chr&gt; \"Athletics Men's Marathon\"\n$ medal  &lt;chr&gt; NA\n\n\nOk, wait a minute. So the Canadians don’t want to accept this guy? Was Newfoundland it’s own country back then?\n(Feverish googling occurs)\nWell, I’ll be darned, it was! According to Wikipedia:\n\nUntil 1949, the Dominion of Newfoundland was a separate dominion in the British Empire. In 1933, the House of Assembly of the self-governing dominion voted to dissolve itself and to hand over administration of Newfoundland and Labrador to the British-appointed Commission of Government. This followed the suffering caused by the Great Depression and Newfoundland’s participation in the First World War. On March 31, 1949, it became the 10th and most recent province to join the Canadian Confederation as “Newfoundland”. On December 6, 2001, the Constitution of Canada was amended to change the province’s name from “Newfoundland” to “Newfoundland and Labrador”.\n\nHuh…I learn something new every day! And here I thought it was because most Canadians think (insert Newfie joke here)."
  },
  {
    "objectID": "posts/olympic240805/olympicMedalData.html#back-to-the-show",
    "href": "posts/olympic240805/olympicMedalData.html#back-to-the-show",
    "title": "Olympic countries: Fun facts and visualizations",
    "section": "Back to the show",
    "text": "Back to the show\nI think that I should create a function that sorts the participation data (and later, the medalist data) by country and year. Also, since 230 lines would make the graph look like messy spaghetti, I think it would be best to limit the results to the top 10 countries by the metric being plotted (participation, number medalists, number gold medalists).\n\ncountByCountryYearSzn = function(dat,top=TRUE){\n  cbcys &lt;- dat |&gt; group_by(across(all_of(c(\"season\",\"noc\",\"year\")))) |&gt;\n      summarize(\n        pcount = n()\n      ) |&gt;\n    mutate(\n      cumCount = cumsum(pcount)\n    )\n  \n  countryTotal &lt;- dat |&gt; count(noc) |&gt;\n    arrange(desc(n))\n  \n  nC = nrow(countryTotal)\n  \n  if(top){\n    cKeep = countryTotal[1:10, ]\n  }else{\n    cKeep = countryTotal[(nC-10):nC, ]\n  }\n  \n  out &lt;- cbcys |&gt; inner_join(cKeep,join_by(noc))\n  \n  out$noc = factor(out$noc, levels = cKeep$noc)\n\n  return(out)\n}\n\nNow, let’s make a graph of olympic participation:\n\npart = countByCountryYearSzn(olympics,top=TRUE)\n\n`summarise()` has grouped output by 'season', 'noc'. You can override using the\n`.groups` argument.\n\nggplot(part, aes(x=year, y=cumCount, color=noc)) +\n  geom_step() + facet_wrap(~ season, ncol=1, scales=\"free_y\") + \n  theme_simple() + theme(\n    plot.background = element_rect(fill=grn,color=grn),\n    panel.background = element_rect(fill=ltGrn,color=ltGrn),\n    legend.key = element_rect(fill=ltGrn,color=ltGrn),\n    legend.background = element_rect(fill=ltGrn,color=ltGrn)\n  ) +\n  labs(\n    title = \"Olympic participation by country (top 10)\",\n    x = \"Year of Olympic Games\",\n    y = \"Cumulative participant count\",\n    caption = caption_text,\n    color = \"Nation\"\n  ) +\n  scale_color_paletteer_d(col_pal_dis_long)\n\n\n\n\n\n\n\n\nThe medal breakdown\n\nolyMedal &lt;- olympics |&gt; filter(!is.na(medal))\n\nmedalists = countByCountryYearSzn(olyMedal,top=TRUE)\n\n`summarise()` has grouped output by 'season', 'noc'. You can override using the\n`.groups` argument.\n\nggplot(medalists, aes(x=year,y=cumCount,color=noc)) +\n  geom_step() + facet_wrap(~ season, ncol=1, scales=\"free_y\") + \n  theme_simple() + theme(\n    plot.background = element_rect(fill=silver,color=silver),\n    panel.background = element_rect(fill=ltSilver,color=ltSilver),\n    legend.key = element_rect(fill=ltSilver,color=ltSilver),\n    legend.background = element_rect(fill=ltSilver,color=ltSilver)\n  ) +\n  labs(\n    title=\"Olympic medalists by country (top 10)\",\n    x = \"Year of Olympic Games\",\n    y = \"Cumulative medal count\",\n    caption = caption_text,\n    color = \"Nation\"\n  ) +\n  scale_color_paletteer_d(col_pal_dis_long)\n\n\n\n\n\n\n\n\nI will note that URS is the Soviet Union, and RUS is Russia. Clearly that country’s 20th century history means that it is not treated as continuous by the Olympic Federation. It reminds me of when I was a kid watching Where in the World is Carmen Sandiego and all of a sudden there were new countries on the European maps. &lt;/nostalgia trip&gt;\nBut you can totally see the rivalry fueled by the Cold War when you look at the “slope” of the summer olympic medal accumulation graph and compare the Soviets (and later, the Russians) to the Americans.\n\nolyGold &lt;- olympics |&gt; filter(medal==\"Gold\")\n\ngoldMetals = countByCountryYearSzn(olyGold,top=TRUE)\n\n`summarise()` has grouped output by 'season', 'noc'. You can override using the\n`.groups` argument.\n\nggplot(goldMetals, aes(x=year,y=cumCount,color=noc)) +\n  geom_step() + facet_wrap(~ season, ncol = 1, scales=\"free_y\") + \n  theme_simple() + theme(\n    plot.background = element_rect(fill=gold,color=gold),\n    panel.background = element_rect(fill=ltGold,color=ltGold),\n    legend.key = element_rect(fill=ltGold,color=ltGold),\n    legend.background = element_rect(fill=ltGold,color=ltGold)\n  ) +\n  labs(\n    title=\"Olympic Golds by country (top 10)\",\n    x = \"Year of Olympic Games\",\n    y = \"Cumulative gold metal count\",\n    caption = caption_text,\n    color = \"Nation\"\n  ) +\n  scale_color_paletteer_d(col_pal_dis_long)"
  },
  {
    "objectID": "posts/collision/puckStickCollision.html",
    "href": "posts/collision/puckStickCollision.html",
    "title": "Puck, meet stick",
    "section": "",
    "text": "I can make this pretty video using Manim!"
  },
  {
    "objectID": "posts/collision/puckStickCollision.html#first-set-up-the-problem",
    "href": "posts/collision/puckStickCollision.html#first-set-up-the-problem",
    "title": "Puck, meet stick",
    "section": "First, set up the problem",
    "text": "First, set up the problem\nFor this calculation, I’ll be working in the LAB frame (with the initial velocity, and initial angular velocity of the stick equal to zero).\n\nAfter the collision is complete, I will define:\n\n\\(\\vec{v}_1 = (v_1, 0)\\) is the velocity of the puck. During the collision, we’ll assume that the force that the stick exerts on the puck is purely horizontal. Therefore, the final velocity of the puck will be also in the \\(x-\\)direction.\n\\(\\vec{v}_2 = (v_2, 0)\\) is the velocity of the stick’s center of mass. During the collision, the puck’s force on the stick is purely horizontal. Therefore, the final velocity of the stick’s center of mass will be also in the \\(x-\\)direction.\n\\(\\omega_2\\) is the z-component of the angular velocity of the stick about it’s center of mass."
  },
  {
    "objectID": "posts/collision/puckStickCollision.html#now-do-the-collision-physics",
    "href": "posts/collision/puckStickCollision.html#now-do-the-collision-physics",
    "title": "Puck, meet stick",
    "section": "Now, do the collision physics",
    "text": "Now, do the collision physics\nConservation of momentum in the \\(x-\\)direction:\n\\[\nm_1 u_1 = m_1 v_1 + m_2 v_2\n\\]\nConservation of angular momentum in the \\(z-\\)direction: \\[\nm_1 u_1 b = m_1 v_1 b + I\\omega_2\n\\] where \\(I\\) is the moment of inertia of a stick with length \\(L\\) about it’s center of mass: \\(I = \\frac{1}{12}m_2 L^2\\).\n\nCoefficient of restitution\nThe coefficient of restitution is generally defined as the “bounciness” of a collision. The coefficient of restitution has the following properties\n\n\\(\\varepsilon = 1\\) for Elastic collisions\n\\(\\varepsilon &lt; 1\\) for Inelastic collisions\n\\(\\varepsilon = 0\\) for Totally inelastic collisions (This is when the objects stick together)\n\nThe coefficient of restitution is defined as: \\[\n\\varepsilon = \\frac{\\left|\\text{final relative velocity}\\right|}{\\left|\\text{initial relative velocity}\\right|}\n\\] For collisions between point particles, we define: \\[\n\\varepsilon = \\frac{\\left|\\vec{v}_2-\\vec{v}_1\\right|}{\\left|\\vec{u}_2-\\vec{u}_1\\right|}\n\\] where \\(\\vec{u}_1, \\vec{u}_2\\) are the initial velocities, and \\(\\vec{v}_1, \\vec{v}_2\\) are the final velocities of the two objects.\nFor extended systems, we need to calculate this using the relative velocities of the impact points. For this system, we can define: \\[\n\\varepsilon = \\frac{\\left|v_2^* - v_1\\right|}{\\left|u_1\\right|}\n\\]\nwhere, \\(v_2^* = v_2 + \\omega_2 b\\) is the velocity of the impact point on the stick. This is a common technique used in subsequent mechanics courses. For this calculation, I will force \\(\\varepsilon \\neq 0\\) because if the puck “sticks” to the stick like a totally inelastic collision, the motion after will be of a composite object, rather than a separate puck and stick."
  },
  {
    "objectID": "posts/collision/puckStickCollision.html#solve-this-system-of-equations",
    "href": "posts/collision/puckStickCollision.html#solve-this-system-of-equations",
    "title": "Puck, meet stick",
    "section": "Solve this system of equations",
    "text": "Solve this system of equations\nThe above 3 conditions provide us with 3 equations relating 3 unknowns \\((v_1, v_2, \\omega_2)\\) in terms of known quantities. I could try to solve these symbolically, but I really don’t feel the need to do so. Rather I’ll use a numerical technique using the python function fsolve in the scipy library. To accomplish this, I need to rearrange these equations so that they all equal zero:\n\\[\n\\begin{align*}\n    0 &= m_1 v_1 + m_2 v_2 - m_1 u_1\\\\\n    0 &= m_1 v_1 b + I \\omega_2 - m_1 u_1 b\\\\\n    0 &= \\left|v_2 + b \\omega_2 - v_1\\right| - \\varepsilon\\left|u_1\\right|\n\\end{align*}\n\\]"
  },
  {
    "objectID": "posts/projectileMotion/projectileMotionWithDrag.html",
    "href": "posts/projectileMotion/projectileMotionWithDrag.html",
    "title": "Ready, Aim, Compute!",
    "section": "",
    "text": "I’ve stalled out a bit on my heat equation modeling project because I’ve been thinking about ways to make it better. Also, I’ve been busy with the real world. So I thought I’d adapt something that I’ve used in class and post it here. Plus, I can’t let my students have all the fun, right? In the standard treatment, we often make approximations that may or may not be valid, and never test these approximations. In fact, that’s why we physicists often get made fun of, because we are talking about spherical cows. I like to get my students to think beyond spherical cows and give them tools to examine the limits of these approximations. So I’m going to build the models, and then play around a bit."
  },
  {
    "objectID": "posts/projectileMotion/projectileMotionWithDrag.html#a-typical-physics-1-projectile-motion-problem",
    "href": "posts/projectileMotion/projectileMotionWithDrag.html#a-typical-physics-1-projectile-motion-problem",
    "title": "Ready, Aim, Compute!",
    "section": "A typical Physics 1 projectile motion problem",
    "text": "A typical Physics 1 projectile motion problem\nI’ve given this problem (or variations of it) in my physics class for years:\n\nWhile on a vacation to Kenya, you visit the port city of Mombassa on the Indian Ocean. On the coast, you find an old Portuguese fort probably built in the 16th century. Large stone walls rise vertically from the shore to protect the fort from cannon fire from pirate ships. You wonder how close a pirate ship would have to sail to the fort to be in range of the fort’s cannon. Of course you realize that the range depends on the velocity that the cannonball leaves the cannon, as well as the height of the cliff.\n\nUsually, we set up a coordinate system like the picture below:\n\n\n\n\n\nUsing this coordinate system, we can determine the equations of motion as follows:\n\\[\n\\begin{align*}\na_x(t) = \\frac{dv_x}{dt} &= 0 \\\\\na_y(t) = \\frac{dv_y}{dt} &= -g \\\\\n\\end{align*}\n\\]\nThese are integrated to find the velocity with the condition: \\(\\vec{v}_i = (v_i\\cos\\theta, v_i\\sin\\theta) = (v_x(0),v_y(0))\\):\n\\[\n\\begin{align*}\nv_x(t) = \\frac{dx}{dt} &= v_i \\cos\\theta t \\\\\nv_y(t) = \\frac{dy}{dt} &= v_i \\sin\\theta t - gt \\\\\n\\end{align*}\n\\]\nThese are integrated again to find the position with the condition: \\(\\vec{r}_i = (0,H) = (x(0),y(0))\\)\n\\[\n\\begin{align*}\nx(t) &= v_i \\cos\\theta t \\\\\ny(t) &= H + v_i\\sin\\theta t - \\frac{1}{2}gt^2 \\\\\n\\end{align*}\n\\]\nWe are also interested in the time of flight (i.e., How long the projectile is in the air):\n\\[\ny(T) = 0 = H + v_i \\sin\\theta T - \\frac{1}{2} gT^2 \\implies T = \\frac{v_i\\sin\\theta + \\sqrt{v_i^2 \\sin^2\\theta + 2gH}}{g}\n\\]\n(Note, since the projectile is launched at \\(t=0\\), we expect the time of flight \\(T&gt;0\\), so I have thrown out the negative solution for \\(T\\) in the equation above.)\nAnd the range1 of the projectile: \\[\nD = x(T) = v_i\\cos\\theta T = v_i \\cos\\theta \\frac{v_i\\sin\\theta + \\sqrt{v_i^2 \\sin^2\\theta + 2gH}}{g}\n\\]\nThis allows us to give physics students problems, and get them to calculate things. We also say that the motion of the cannonball is parabolic, and a bunch of other stuff that only works if we are talking about spherical cows flying around in vacuum. Anyone who has seen a shot tracer of a golf ball will say that these don’t look like the parabolas we all drew back in High School Algebra classes. So what’s going on?\n\n\n\n\n\n\nIdeal Projectile Motion: Thinking about code\nAt this point, we have fully specified the problem. Any motion is fully specified given the cliff height \\(H\\), launch speed \\(v_i\\), and launch angle \\(\\theta\\). We are done. Computationally, we want to be able to calculate all the important things, and define all of the important functions. I have chosen to use a python class to do so. The nice thing about using classes is that you can specify all of the variables for the system, but not have them cluttering the working environment.\n\nimport numpy as np\n\nclass idealProjectile:\n  '''\n  Does the standard Physics 1 treatment of a projectile on earth for a projectile \n  fired from an elevated position\n  Inputs:\n    vLaunchMag = launch speed in m/s\n    vLaunchDir = launch angle measured from horizontal in degrees\n    height = elevation of the position in m\n  Outputs: (All in SI units)\n    tof = time of flight in seconds\n    maxX = range of projectile in m\n    position = function that calculates vector position as a function of time\n    velocity = function that calculates vector velocity as a function of time\n    acceleration = function that calculates vector acceleration as a function of time\n  '''\n  def __init__(self, vLaunchMag, vLaunchDir, height):\n    self.v0 = vLaunchMag\n    theta = np.pi/180*float(vLaunchDir)\n    self.theta = theta\n    self.h = height\n    self.g = 9.81\n    g = self.g\n    v0x = vLaunchMag*np.cos(theta)\n    v0y = vLaunchMag*np.sin(theta)\n    self.tof = (v0y + np.sqrt(v0y**2 + 2*g*height))/g\n    self.maxX = v0x * self.tof\n\n  def position(self, t):\n    v0, theta, g, h = self.v0, self.theta, self.g, self.h\n    v0x = v0*np.cos(theta)\n    v0y = v0*np.sin(theta)\n    x = v0x * t\n    y = h + v0y*t - 1/2 * g * t**2\n    return [x,y]\n  \n  def velocity(self,t):\n    v0, theta, g = self.v0, self.theta, self.g\n    v0x = v0*np.cos(theta)\n    v0y = v0*np.sin(theta)\n    vx = v0x\n    vy = v0y - g*t\n    return [vx,vy]\n\n  def acceleration(self,t):\n    return [0,-self.g]"
  },
  {
    "objectID": "posts/projectileMotion/projectileMotionWithDrag.html#air-resistance-its-a-drag.",
    "href": "posts/projectileMotion/projectileMotionWithDrag.html#air-resistance-its-a-drag.",
    "title": "Ready, Aim, Compute!",
    "section": "Air resistance: It’s a drag.",
    "text": "Air resistance: It’s a drag.\nWhen we model motion in a fluid, for large, fast objects we can write:\n\\[\n\\vec{F}_{\\text{air}} = -c \\left|\\vec{v}\\right|\\vec{v} = -c \\sqrt{v_x(t)^2+v_y(t)^2} (v_x(t), v_y(t))\n\\] where the coefficient \\(c\\) is a constant that depends on the size and shape of the object moving through air, as well as the density of the fluid. This model can get more complicated, and wikipedia discusses it further at a reasonably intro-level. But I won’t bore you here.\nIncluding this in our model for projectile motion allows us to generate new equations of motion, and this can be done for all levels of physics.\n\\[\n\\begin{align*}\na_x(t) = \\frac{dv_x}{dt} &= - \\frac{c}{m} \\sqrt{v_x^2+v_y^2} v_x\\\\\na_y(t) = \\frac{dv_y}{dt} &= -g - \\frac{c}{m} \\sqrt{v_x^2+v_y^2} v_y\\\\\n\\end{align*}\n\\]\nThese are integrated to find the velocity with the condition: \\(\\vec{v}_i = (v_i\\cos\\theta, v_i\\sin\\theta) = (v_x(0),v_y(0))\\), and we get…an error.\n\n\n\n\n\nWell, we can integrate these equations if we use, well, I’ll let Katherine Johnson’s character from the movie Hidden Figures tell you:\n\n\n\n\nWe won’t actually use Euler’s method, but instead use the default method in Python’s scipy.integrate.solve_ivp function - an application of the Runge-Kutta method which is still pretty ancient. (Well, it’s older than me!) I won’t be going into the details of the method here.\nThe level of the class that I’m teaching determines how I proceed from here. If we have an upper level class, students use the numeric integrator of their choice, be it in Mathematica, Matlab, Python, or something else. In an intro class, I walk through Euler (or Euler-Cromer) integration with them. (And they will have seen a 1D implementation of Euler’s method before we tackle this 2D version.)\n\nThinking about code\nOnce we add the projectile mass \\(m\\), and drag coefficient \\(c\\) to the parameters that we had for the the ideal motion, \\(H\\), \\(v_i\\), and \\(\\theta\\), we have fully specified the problem. Despite the fact that we cannot integrate the equations of motion analytically, we can do so numerically. As before, I have chosen to use a python class to carry this out. Actually, I’ve created two classes to do this. Let’s go into the why for this choice in the next sections.\n\nA note about integrating differential equations numerically\nIn physics, we use Newton’s laws to generate differential equations governing the motion of a system. Specifically, we get the acceleration, which is the second derivative of position. So if we want the position as a function of time for a system, this is a 2nd order differential equation. However, numerical methods are built on solving 1st order differential equations.2\nLet’s think about the function \\(u(t)\\) which returns a vector comprised of the position vector combined with the velocity vector.\n\\[\nu(t) = \\left[x(t), y(t), v_x(t), v_y(t) \\right]\n\\]\nWe can take the time derivative of this function (I’ll use a dot to signify differentiation with respect to time) and express it in terms of the velocity and acceleration \\[\n\\dot{u}(t) = \\left[\\dot{x}(t), \\dot{y}(t), \\dot{v}_x(t), \\dot{v}_y(t) \\right] = \\left[v_x(t), v_y(t), a_x(t), a_y(t)\\right]\n\\]\ndragEOM is this function \\(\\dot{u}(t)\\) applied to our projectile system.\n\nclass dragEOM:\n  '''\n  Equations of motion for projectile system with turbulent drag fired from an elevated position\n  Inputs:\n    vLaunchMag = launch speed in m/s\n    vLaunchDir = launch angle measured from horizontal in degrees\n    height = elevation of the position in m\n    mass = mass of projectile in kg\n    dragCoef = drag coefficient for system in kg/m\n  Outputs:\n    udot = [xdot, ydot, vxdot, vydot]\n    splash = function that returns y coordinate (needed for integration)\n  '''\n  def __init__(self, vLaunchMag, vLaunchDir, height, mass, dragCoef):\n      self.v0 = vLaunchMag\n      theta = np.pi/180*float(vLaunchDir)\n      self.theta = theta\n      self.h = height\n      self.g = 9.81\n      g = self.g\n      self.coef = dragCoef/mass\n      v0x = vLaunchMag*np.cos(theta)\n      v0y = vLaunchMag*np.sin(theta)\n      self.idealTof = (v0y + np.sqrt(v0y**2 + 2*g*height))/g\n      self.u0 = [0, height, v0x, v0y]\n\n  def __call__(self,t,u):\n      g, coef = self.g, self.coef\n      x, y, vx, vy = u\n      xdot, ydot = vx, vy\n      vxdot = -coef * np.sqrt(vx**2 + vy**2) * vx\n      vydot = -g - coef * np.sqrt(vx**2 + vy**2) * vy\n      udot = [xdot, ydot, vxdot, vydot]\n      return udot\n\n  def splash(self,t,u):\n      return u[1]\n\n  splash.terminal = True\n\n\n\nGetting the motion\nNow that this is done, we can get the motion for this system using the following class:\n\nfrom scipy.integrate import solve_ivp\n\nclass dragProjectile:\n  '''\n  Equations of motion for projectile system with turbulent drag fired from an elevated position\n  Inputs:\n    vLaunchMag = launch speed in m/s\n    vLaunchDir = launch angle measured from horizontal in degrees\n    height = elevation of the position in m\n    mass = mass of projectile in kg\n    dragCoef = drag coefficient for system in kg/m\n  Outputs:\n    t = vector of time values where the system is solved\n    x, y = vectors of position values matching the time vector above\n    vx, vy = vectors of velocity values matching the time vector above\n    ax, ay = vectors of acceleration values matching the time vector above\n    tof = time of flight \n    maxX = projectile range\n  '''\n  def __init__(self, vLaunchMag, vLaunchDir, height, mass, dragCoef):\n    model = dragEOM(vLaunchMag, vLaunchDir, height, mass, dragCoef)\n    tMax = 2 * model.idealTof\n    tVals = np.linspace(0,tMax,100)\n    u0 = model.u0\n    sol = solve_ivp(model, t_span=[0,tMax], y0 = u0, t_eval=tVals, events=model.splash, dense_output=True)\n    self.tof = sol.t_events[0][0]\n    self.maxX = sol.y_events[0][0][0]\n    self.t = sol.t\n    self.x = sol.y[0, :]\n    self.y = sol.y[1, :]\n    self.vx = sol.y[2, :]\n    self.vy = sol.y[3, :]\n    udot = model(sol.t, sol.y)\n    self.ax = udot[2]\n    self.ay = udot[3]"
  },
  {
    "objectID": "posts/projectileMotion/projectileMotionWithDrag.html#comparing-motion-withwithout-air-resistance",
    "href": "posts/projectileMotion/projectileMotionWithDrag.html#comparing-motion-withwithout-air-resistance",
    "title": "Ready, Aim, Compute!",
    "section": "Comparing motion with/without air resistance",
    "text": "Comparing motion with/without air resistance\nNow that we have these tools built, we can start to visualize this motion. I’ll do this using some functions in my projectile.py file to make graphs. I will also include the following numerical values:\n\n\\(H = 200\\) m\n\\(v_i = 100\\) m/s\n\\(\\theta = 30\\) deg\n\\(m = 1\\) kg\n\\(c = 0.003\\) kg/m\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom projectile import *\n\nH = 200\nvi = 100\ntheta = 30\nm = 1\nc = 0.003\n\nI will visualize this motion in two ways. First, I’ll plot each quantity of the motion (position, velocity, acceleration) vs. time.\n\nplotCannonCurves(vi,theta,H,m,c)\n\n\n\n\n\n\n\n\nNow I will plot the trajectory (y-coordinate vs x-coordinate). Note that I have added boxes to this plot indicating the cliff location and the water level to help guide the eye. The plot has also been set up with an equal aspect ratio so that the horizontal and vertical distances are the same. The green curve should more closely match the golf ball tracer than the red parabolic path does.\n\nmakeTrajectoryPlot(vi,theta,H,m,c)\n\n\n\n\n\n\n\n\n\nWhere to go from here\nUsually, I’ll give my students some tasks like finding the maximum range of the projectile, and comparing the model results. I thought that I would do something a little different as it will allow me to compare the model predictions. I will do this using the fractional difference between the two predictions for both the range and the time of flight. Since I used \\(D\\) to denote the range, I will write \\(D_1\\) to denote the range for model 1 (no air resistance) and \\(D_2\\) to denote the range for model 2 (with air resistance). Therefore the quantity below is the fractional difference between the targeting location of the models.\n\\[\n\\delta_D = \\frac{\\left|D_1 - D_2\\right|}{D_1}\n\\]\nI will also define a similar quantity related to the time-of-flight.\n\\[\n\\delta_T = \\frac{\\left|T_2 - T_1\\right|}{T_2}\n\\]\nNote that I’m using \\(D_1\\) in the denominator of \\(\\delta_D\\) and \\(T_2\\) in the denominator of \\(\\delta_T\\). This is because these are the larger values for each motion.\nI will calculate these quantities for a range of launch velocities, masses, and launch angles keeping the cliff height \\((H=100 \\,\\text{m})\\) and drag coefficient \\((c=0.003 \\,\\text{kg/m})\\) the same as it was before.\n\n\nCode\nimport matplotlib.colors as mc\nimport matplotlib.cm as cm\n\nlaunchVelocities = np.linspace(0,200,21)\nlaunchAngles = np.linspace(0,85,18)\nmasses = np.logspace(-2,2,19)\nnv = len(launchVelocities)\nna = len(launchAngles)\nnm = len(masses)\ndeltaD = np.empty(shape=(nv,na,nm))\ndeltaT = np.empty(shape=(nv,na,nm))\nfor i in range(nv):\n  for j in range(na):\n    for k in range(nm):\n      lv = launchVelocities[i]\n      la = launchAngles[j]\n      mm = masses[k]\n      m1 = idealProjectile(lv,la,H)\n      m2 = dragProjectile(lv,la,H,mm,c)\n      D1 = m1.maxX\n      D2 = m2.maxX\n      T1 = m1.tof\n      T2 = m2.tof\n      deltaT[i,j,k] = np.abs(T1 - T2)/T2\n      if D1&lt;1 and D2 &lt;1:\n        # For small ranges (less than 1 meter from the cliff), just set the \n        # fractional difference equal to zero\n        deltaD[i,j,k] = 0\n      else:\n        deltaD[i,j,k] = np.abs(D1 - D2)/D1\n\n# Set up properties of the color bar \ncnormD = mc.Normalize(vmin=0,vmax=deltaD.max())\ncbarD = cm.ScalarMappable(norm=cnormD,cmap='plasma')\ncnormT = mc.Normalize(vmin=0,vmax=deltaT.max())\ncbarT = cm.ScalarMappable(norm=cnormT)\n\n# Arrange the calculations into multiple grids for making a heatmap/contour plot\nX1, Y1 = np.meshgrid(launchVelocities, launchAngles)\nZ1 = deltaD[:, :, nm//2].transpose()\nZZ1 = deltaT[:, :, nm//2].transpose()\n\nX2, Y2 = np.meshgrid(launchVelocities, masses)\nZ2 = deltaD[:, na//2, :].transpose()\nZZ2 = deltaT[:, na//2, :].transpose()\n\nX3, Y3 = np.meshgrid(launchAngles, masses)\nZ3 = deltaD[nv//2, :, :].transpose()\nZZ3 = deltaT[nv//2, :, :].transpose()\n\n\nNow, let’s examine the model agreement for the range:\n\n\nCode\nfig1, ax1 = plt.subplots(1,3,figsize=(7,4))\nfig1.suptitle(\"Comparing predicted range with/without air resistance\")\nCS = ax1[0].contourf(X1,Y1,Z1,100,cmap='plasma')\nax1[0].set_title(f'Mass = {masses[nm//2]:.2f} kg',size=10)\nax1[0].set_xlabel('Launch velocity (m/s)')\nax1[0].set_ylabel('Launch angle (deg)')\nax1[1].contourf(X2,Y2,Z2,100,cmap='plasma')\nax1[1].set_title(f'Launch angle = {launchAngles[na//2]:.0f} deg',size=10)\nax1[1].set_xlabel('Launch velocity (m/s)')\nax1[1].set_ylabel('Mass (kg)')\nax1[1].set_yscale('log')\nax1[2].contourf(X3,Y3,Z3,100,cmap='plasma')\nax1[2].set_title(f'Launch velocity = {launchVelocities[nv//2]:.0f} m/s',size=10)\nax1[2].set_xlabel('Launch angle (deg)')\nax1[2].set_ylabel('Mass (kg)')\nax1[2].set_yscale('log')\nfig1.subplots_adjust(bottom=0.3,wspace=0.5,right=0.9)\ncbar_ax = fig1.add_axes([0.2, 0.15, 0.65, 0.02])\nfig1.colorbar(cbarD, cax=cbar_ax,label=r'$\\delta_D$',orientation='horizontal')\nghLogo = u\"\\uf09b\"\nliLogo = u\"\\uf08c\"\ntxt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\nplt.figtext(0.6,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\nplt.savefig('rangeCalcFracDiff.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nFinally, I’ll examine the model agreement for the time-of-flight:\n\n\nCode\nfig1, ax1 = plt.subplots(1,3,figsize=(7,4))\nfig1.suptitle(\"Comparing predicted time of flight with/without air resistance\")\nCS = ax1[0].contourf(X1,Y1,ZZ1,100)\nax1[0].set_title(f'Mass = {masses[nm//2]:.2f} kg',size=10)\nax1[0].set_xlabel('Launch velocity (m/s)')\nax1[0].set_ylabel('Launch angle (deg)')\nax1[1].contourf(X2,Y2,ZZ2,100)\nax1[1].set_title(f'Launch angle = {launchAngles[na//2]:.0f} deg',size=10)\nax1[1].set_xlabel('Launch velocity (m/s)')\nax1[1].set_ylabel('Mass (kg)')\nax1[1].set_yscale('log')\nax1[2].contourf(X3,Y3,ZZ3,100)\nax1[2].set_title(f'Launch velocity = {launchVelocities[nv//2]:.0f} m/s',size=10)\nax1[2].set_xlabel('Launch angle (deg)')\nax1[2].set_ylabel('Mass (kg)')\nax1[2].set_yscale('log')\nfig1.subplots_adjust(bottom=0.3,wspace=0.5,right=0.9)\ncbar_ax = fig1.add_axes([0.2, 0.15, 0.65, 0.02])\nfig1.colorbar(cbarT, cax=cbar_ax,label=r'$\\delta_T$',orientation='horizontal')\nghLogo = u\"\\uf09b\"\nliLogo = u\"\\uf08c\"\ntxt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\nplt.figtext(0.6,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\nplt.savefig('tofCalcFracDiff.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nNote that the color scales for these plots have different ranges. In particular the max \\(\\delta_T\\) value is larger than the max \\(\\delta_D\\) value. Given the initial height, it would seem that the time of flight is much more sensitive to air resistance. In general, areas on the plots above where the color is yellow shows a high level of disagreement between motion in vacuum vs. motion in air. Areas where the color is blue/violet shows a low level of disagreement between the models. Since air resistance is dependent on speed, we would expect that at low speeds, air resistance is less important, especially for the range calculation. Given the fact that gravity/weight is the other force of interest, objects with a larger mass are also less sensitive to air resistance.\nThere is an interesting “trough” in the time of flight graphic. You can see that the minimum \\(\\delta_T\\) values aren’t along one of the axes as they are for \\(\\delta_D\\). This is because for very slow, or nearly vertical launch trajectories, the range isn’t going to be very different as it just doesn’t move very fast in the x-direction. Perhaps the best way to think about this is to compare the motion of a gently tossed pebble to a gently tossed feather from the same height. They both land in (about) the same place. So both have a small difference with the vacuum range. The time of flight will be different, since the feather stops going up sooner, and falls with an average acceleration much different than \\(-g\\). Yet the motion of the pebble will be much more similar to the vacuum motion since the drag force is much smaller in magnitude than the weight of the pebble.\n\nMotion of a “feather” vs a “pebble”\n\n\nCode\nvi = 50\nvdir = 85\n\nvacuum = idealProjectile(vi,vdir,H)\niTime = np.linspace(0,vacuum.tof,100)\n[iPosx, iPosy] = vacuum.position(iTime)\n[iVelx, iVely] = vacuum.velocity(iTime)\n[iAccx, iAccy] = vacuum.acceleration(iTime)\n\nfeather = dragProjectile(vi,vdir,H,.1,c)\npebble = dragProjectile(vi,vdir,H,10,c)\n\nfig, ax = plt.subplots(1,3,figsize=(9,4))\nfig.suptitle(f'Motion of ideal projectile, \"feather\", and \"pebble\" for \\n'+\n        f'launch velocity = {vi:.0f} m/s and launch angle = {vdir:.0f} deg')\nax[0].axhline(iAccx,label='vacuum')\nax[0].plot(feather.t, feather.ax,'r',label='feather')\nax[0].plot(pebble.t, pebble.ax,'g',label='pebble')\nax[0].set_xlabel('time (s)')\nax[0].set_ylabel(r'$a_x$ (m/s^2)')\nax[0].legend()\nax[1].axhline(iAccy,label='vacuum')\nax[1].plot(feather.t, feather.ay,'r',label='feather')\nax[1].plot(pebble.t, pebble.ay,'g',label='pebble')\nax[1].set_xlabel('time (s)')\nax[1].set_ylabel(r'$a_y$ (m/s^2)')\nax[0].set_ylim(ax[1].get_ylim())\nax[1].legend()\nax[2].plot(iPosx,iPosy, label='vacuum')\nax[2].plot(feather.x, feather.y,'r', label='feather')\nax[2].plot(pebble.x, pebble.y,'g',label='pebble')\nax[2].axis('equal')\nax[2].set_xlim([0,200])\nax[2].set_xlabel(r'$x$ (m)')\nax[2].set_ylabel(r'$y$ (m)')\nax[2].legend()\nfig.subplots_adjust(wspace=0.4,bottom=0.2)\nplt.figtext(0.65,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=9)\nplt.show()"
  },
  {
    "objectID": "posts/projectileMotion/projectileMotionWithDrag.html#footnotes",
    "href": "posts/projectileMotion/projectileMotionWithDrag.html#footnotes",
    "title": "Ready, Aim, Compute!",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNo, that’s not the “range equation” found in standard physics textbooks. And no, I haven’t made a mistake. The “range equation” in the standard physics text assumes \\(H=0\\), that is, there is no elevation change to be concerned about. We can reduce this if we set \\(H=0\\). In this case, \\(T = \\frac{2 v_i \\sin\\theta}{g}\\) and \\(D = \\frac{2 v_i^2 \\sin\\theta \\cos\\theta}{g} = \\frac{v_i^2 \\sin(2\\theta)}{g}\\), which is the standard physics textbook result, or what the AI will tell you if you google “range equation physics”.↩︎\nIn general, a \\(n\\)th order differential equation has a \\(n\\)th derivative of a function as the highest order derivative of a function. So the equation \\(f'(x) = f(x) + 3(f(x))^2\\) is a 1st order differential equation in \\(f(x)\\) because it has that function, as well as the first derivative of that function only. And \\(f''(x) = f(x) + 3(f'(x))^2\\) is a 2nd order differential equation.↩︎"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "Steven Wolf - Data World",
    "section": "",
    "text": "This is the weblog so I can do some #TidyTuesday activities and play with Quarto.\nGo to the webpage here: datawolf04.github.io"
  },
  {
    "objectID": "posts/tt20240813/worldFairs.html",
    "href": "posts/tt20240813/worldFairs.html",
    "title": "World’s Fairs",
    "section": "",
    "text": "This week’s #TidyTuesday is all about World’s Fairs, and I have always wanted to figure out how to make a visualization with a map. So this is the week that I try that out. In addition to the data from Wikipedia in the given dataset, I have also downloaded S. Altan’s Kaggle Dataset: Countries by Continent.\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(rworldmap)\nlibrary(paletteer)\nlibrary(RColorBrewer)\n\nload('worldsFairs.Rdata')\nsource('helperFunctions.R')"
  },
  {
    "objectID": "posts/tt20240813/worldFairs.html#plan-and-data-cleaning",
    "href": "posts/tt20240813/worldFairs.html#plan-and-data-cleaning",
    "title": "World’s Fairs",
    "section": "Plan and data cleaning",
    "text": "Plan and data cleaning\nMy plan is to create visualizations that look at different world’s fair properties by continent and country. I will clean the data a bit, and then generate some tables.\n\nContinental breakdown of World’s fair\n\nfairData = left_join(worlds_fairs,countryContinent, by='country')\n\n# Replace missing continents by hand\nmissing = c(\"Europe\",\"Oceania\",\"Europe\",\"Europe\",\"Asia\")\nfairData$continent[is.na(fairData$continent)] = missing\n\nfairDataByContinent = fairData |&gt;\n  mutate(\n    duration = calcFLMV(start_month, start_year, end_month, end_year) \n  ) |&gt; group_by(continent) |&gt; \n  summarize(\n    N = n(),\n    across(where(is.numeric), ~ mean(.x,na.rm=TRUE))\n  ) |&gt;\n  select(-c('start_month','start_year','end_month','end_year'))\n\n\n\n\n\n\n  \n    \n      World's Fair by the numbers\n    \n    \n      Average properties by host continent\n    \n    \n      Continent\n      Number Hosted\n      Visitors (M)\n      Avg. cost (M$)\n      Land area (hectares)\n      Number of attending countries\n      Fair duration (mo)\n    \n  \n  \n    Asia\n11\n26.0\n1,999.7\n169.4\n103.5\n5.1\n    Europe\n43\n12.7\n547.8\n77.1\n42.7\n5.2\n    North America\n14\n20.9\n281.4\n144.2\n29.8\n8.9\n    Oceania\n2\n9.9\n320.5\n32.5\n34.5\n7.0\n  \n  \n    \n      #TidyTuesday • Sources: Wikipedia and S. Altan Kaggle dataset\n\n    \n  \n  \n    \n       Missing data was ignored from averages taken.\n    \n  \n\n\n\n\n\n\nCountry breakdown of world’s fair\n\nfairDataByCountry = fairData |&gt;\n  mutate(\n    duration = calcFLMV(start_month, start_year, end_month, end_year) \n  ) |&gt; group_by(country) |&gt; \n  summarize(\n    N = n(),\n    across(where(is.numeric), ~ mean(.x,na.rm=TRUE))\n  ) |&gt;\n  select(-c('start_month','start_year','end_month','end_year'))\n\n\n\n\n\n\n  \n    \n      World's Fair by the numbers\n    \n    \n      Average properties by host country\n    \n    \n      Country\n      Number Hosted\n      Visitors (M)\n      Fair cost (M$)\n      Land area (hectares)\n      Number of attending countries\n      Fair duration (mo)\n    \n  \n  \n    Australia\n1\n18.5\n625.0\n40.0\n36.0\n7.0\n    Austria-Hungary\n1\n7.2\n95.0\n233.0\n35.0\n6.0\n    Belgium\n7\n16.4\n558.8\n117.7\n26.9\n6.7\n    Bulgaria\n3\n1.0\n—\n5.8\n40.5\n1.7\n    Canada\n2\n36.2\n371.0\n217.5\n58.5\n6.5\n    Colony of Victoria\n1\n1.3\n16.0\n25.0\n33.0\n7.0\n    Finland\n1\n—\n—\n0.1\n25.0\n1.0\n    France\n9\n21.6\n556.0\n67.9\n34.5\n5.4\n    Germany\n1\n18.1\n3,400.0\n160.0\n155.0\n5.0\n    Haiti\n1\n—\n—\n24.0\n15.0\n7.0\n    Hungary\n1\n1.9\n—\n35.0\n52.0\n2.0\n    Israel\n2\n—\n—\n29.8\n13.0\n2.0\n    Italy\n8\n7.7\n26.0\n68.3\n44.1\n5.5\n    Japan\n4\n27.5\n30.0\n175.7\n69.8\n7.0\n    Kazakhstan\n1\n4.1\n—\n25.0\n115.0\n4.0\n    People's Republic of China\n1\n73.1\n4,200.0\n523.0\n192.0\n6.0\n    Portugal\n1\n10.1\n—\n50.0\n143.0\n5.0\n    South Korea\n2\n11.3\n1,769.0\n57.5\n122.0\n4.0\n    Spain\n4\n13.9\n21.0\n101.2\n68.8\n7.2\n    Sweden\n3\n—\n—\n0.5\n18.3\n2.3\n    United Arab Emirates\n1\n24.1\n—\n438.0\n192.0\n6.0\n    United Kingdom\n2\n6.0\n83.5\n12.5\n32.0\n7.0\n    United States\n11\n18.2\n265.1\n141.8\n25.6\n9.5\n    West Germany\n2\n2.1\n—\n51.6\n24.5\n4.0\n  \n  \n    \n      #TidyTuesday • Sources: Wikipedia and S. Altan Kaggle dataset\n\n    \n  \n  \n    \n       Missing data was ignored from averages taken. Blank values imply no data exists for that country and quantity."
  },
  {
    "objectID": "posts/tt20240813/worldFairs.html#putting-this-on-a-map",
    "href": "posts/tt20240813/worldFairs.html#putting-this-on-a-map",
    "title": "World’s Fairs",
    "section": "Putting this on a map",
    "text": "Putting this on a map\n\nworldFairMap &lt;- joinCountryData2Map(fairDataByCountry, joinCode = 'NAME',\n                                    nameJoinColumn = \"country\")\n\n21 codes from your data successfully matched countries in the map\n3 codes from your data failed to match with a country code in the map\n222 codes from the map weren't represented in your data\n\npar(mar=c(0,0.1,2,0.1),xaxs=\"i\",yaxs=\"i\",cex.main=2)\nattendMap = mapCountryData(worldFairMap, addLegend=FALSE,\n                           nameColumnToPlot = 'attending_countries',\n                           catMethod = \"pretty\",\n                           colourPalette = brewer.pal(10,\"Purples\"),\n                           oceanCol='lightblue',missingCountryCol = 'white',\n                           mapTitle=\"Country attendance\")\n\nYou asked for 7 categories, 10 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"Purples\"): n too large, allowed maximum for palette Purples is 9\nReturning the palette you asked for with that many colors\n\n\nWarning in rwmGetColours(colourPalette, numColours): 9 colours specified and 10\nrequired, using interpolation to calculate colours\n\ndo.call(addMapLegend, c(attendMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\ncostMap = mapCountryData(worldFairMap, nameColumnToPlot = 'cost',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"Greens\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Cost in Millions\")\n\nYou asked for 7 categories, 9 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"Greens\"): n too large, allowed maximum for palette Greens is 9\nReturning the palette you asked for with that many colors\n\ndo.call(addMapLegend, c(costMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\nareaMap = mapCountryData(worldFairMap, nameColumnToPlot = 'area',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"PuBuGn\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Size of fairgrounds\")\n\nYou asked for 7 categories, 6 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"PuBuGn\"): n too large, allowed maximum for palette PuBuGn is 9\nReturning the palette you asked for with that many colors\n\n\nWarning in rwmGetColours(colourPalette, numColours): 9 colours specified and 6\nrequired, using interpolation to calculate colours\n\ndo.call(addMapLegend, c(areaMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\nvisitMap = mapCountryData(worldFairMap, nameColumnToPlot = 'visitors',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"OrRd\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Fair Visitors by the Million\")\n\nYou asked for 7 categories, 8 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\n\nWarning in rwmGetColours(colourPalette, numColours): 9 colours specified and 8\nrequired, using interpolation to calculate colours\n\ndo.call(addMapLegend, c(visitMap, legendWidth=0.5, legendMar=5))\n\n\n\n\n\n\n\ntimeMap = mapCountryData(worldFairMap, nameColumnToPlot = 'duration',\n               catMethod = \"pretty\", addLegend=FALSE,\n               colourPalette = brewer.pal(10,\"OrRd\"),\n               oceanCol='lightblue',missingCountryCol = 'white',\n               mapTitle=\"Length of the World's Fair\")\n\nYou asked for 7 categories, 9 were used due to pretty() classification\n\n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\ndo.call(addMapLegend, c(timeMap, legendWidth=0.5, legendMar=5))"
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html",
    "href": "posts/tt20240903/stackOverflow.html",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "",
    "text": "This week’s dataset is derived from the 2024 Stack Overflow Annual Developer Survey. Conducted in May 2024, the survey gathered responses from over 65,000 developers.\nGiven that one of the big trends being discussed in the world right now is working from home vs. going back to the office, I was wondering if there were any trends in this data as to who is working at home. Note, that this dataset did not include gender or race data. In particular, I’m considering 3 questions:\nload(\"soSurvey.RData\")\nsource('helperFunctions.R')\nlibrary(tidyverse)\nlibrary(paletteer)\n\npersonalDataCats = c('main_branch','age','remote_work','ed_level','years_code',\n                     'years_code_pro','dev_type','org_size','country','currency',\n                     'comp_total')\n\npersonData &lt;- stackoverflow_survey_single_response |&gt;\n  select(all_of(personalDataCats)) |&gt;\n  filter(!is.na(remote_work))\n\ncwRemote = qname_levels_single_response_crosswalk |&gt;\n  filter(qname=='remote_work')\n\ncwRemote$label = c(\"Hybrid\",\"In-person\",\"Remote\")\nremoteLevels = c(\"In-person\",\"Hybrid\",\"Remote\")\n\npersonData &lt;- left_join(personData,cwRemote,by=join_by(remote_work == level)) |&gt;\n  mutate(remote_work = factor(label,levels=remoteLevels)) |&gt; \n  select(!qname & !label)"
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html#work-type-and-education-level",
    "href": "posts/tt20240903/stackOverflow.html#work-type-and-education-level",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "Work type and education level",
    "text": "Work type and education level\n\n\n\n\n\n\n\n\n\nThis graph shows the number of responses as well as the level of education that each user has. We can see that most users of Stack Overflow have at least 4-year college degree. This would seem to be in line with the general profile of someone working in a STEM field. It is somewhat difficult to glean what, if any, role there is between work location and education level.\n\n\n\n\n\n\n\n\n\nNext, we consider the same data, but we are highlighting the counts based on work location. This plot shows that a large fraction of Stack Overflow users are working in hybrid or remote locations.\nIn the following two plots, I’ll show the same information as above, except as percentages rather than raw counts.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNeither of these suggests that education level would predict work location for stack overflow users."
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html#work-type-and-age",
    "href": "posts/tt20240903/stackOverflow.html#work-type-and-age",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "Work type and age",
    "text": "Work type and age\n\n\n\n\n\n\n\n\n\nThe above plot looks at the number of responses by age. We can see clearly that most users are between ages 25 and 44.\n\n\n\n\n\n\n\n\n\nHere we see that the age group from 18-24 is working in-person much more than they work hybrid/remote. As this group is college-aged, and most colleges and universities are back to in-person instruction, this could suggest that students who are learning to code at university are using Stack Overflow for help (as this college professor hopes they would). As users age, they tend to find more hybrid/remote roles."
  },
  {
    "objectID": "posts/tt20240903/stackOverflow.html#work-type-and-experience-coding",
    "href": "posts/tt20240903/stackOverflow.html#work-type-and-experience-coding",
    "title": "Stack Overflow Annual Developer Survey",
    "section": "Work type and Experience coding",
    "text": "Work type and Experience coding\n\n\n\n\n\n\n\n\n\nHere we see a possible echo of the college idea that I raised above. However, I see a few other things as well.\n\nThere seems to be a significant shift that as people gain experience coding, they move from in-person roles to hybrid/remote roles.\nAs you do something for a longer time, you tend to estimate more. All of the responses seem to favor numbers ending in 0 or 5, especially once you get past 10 years. So if someone has 22 years of experience, they will probably round down to 20, or up to 25, rather than stating 20 exactly."
  },
  {
    "objectID": "posts/weatherScrape240808/weatherScrape.html",
    "href": "posts/weatherScrape240808/weatherScrape.html",
    "title": "Scraping Weather Data-Proof of concept",
    "section": "",
    "text": "My friend, Ben Leese, was telling me about his most recent project. He has a passion for going through old naturalist’s notebooks and pulling out data from the depths of that analog mess and bringing it into the digital world. He was talking to me about how weather could impact different bird behaviors. But he only had binary weather data (Yes, it rained/No, it didn’t rain). Furthermore, it was from Raleigh, NC rather than Zebulon, NC. While these places are close on the map, weather is even more local than politics. So I said that I’d try to find some better weather data for him.\nI found this helpful python script for scraping the weather data from Weather Underground, which I will adapt to my purpose.\n\nimport time\nimport sys\n\nimport numpy as np\nimport pandas as pd\nfrom bs4 import BeautifulSoup as BS\nfrom selenium import webdriver\nfrom great_tables import GT\nfrom scrape_wunderground import *\n\nI will scrape weather from the BreakingWind station with code KNCZEBUL74 on 8/1/2024, as I am pretty sure this is the closest station to the desired location.\n\nstation_id = \"KNCZEBUL74\"\ndate_id = \"2024-08-01\"\n\n(\n  GT(scrape_wunderground(station_id,date_id).head(20))\n    .tab_options(\n      column_labels_background_color = \"#3B3A3EFF\",\n  )\n)\n\n\n\n\n\n\n\ntimestamps\nTemperature\nDew Point\nHumidity\nWind Speed\nWind Gust\nPressure\nPrecip. Rate\nPrecip. Accum.\n\n\n\n\n2024-08-01 12:04 AM\n75.0\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:09 AM\n75.0\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:14 AM\n75.0\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:19 AM\n74.8\n72.0\n91.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 12:24 AM\n74.8\n72.0\n91.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:29 AM\n74.8\n72.0\n91.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:34 AM\n74.7\n72.0\n92.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:39 AM\n74.7\n72.0\n92.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:44 AM\n74.6\n72.0\n92.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:49 AM\n74.5\n72.6\n93.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:54 AM\n74.5\n73.0\n93.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 12:59 AM\n74.7\n73.0\n93.0\n0.0\n0.0\n29.93\n0.0\n0.0\n\n\n2024-08-01 1:04 AM\n74.7\n73.0\n93.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:09 AM\n74.7\n72.3\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:14 AM\n74.7\n72.2\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:19 AM\n74.6\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:24 AM\n74.5\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:29 AM\n74.5\n72.0\n92.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:34 AM\n74.5\n72.9\n93.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n2024-08-01 1:39 AM\n74.5\n73.0\n93.0\n0.0\n0.0\n29.92\n0.0\n0.0\n\n\n\n\n\n\n\n\nAnd it works! That being said, I’ll have to find a different weather station because this one seems somewhat new. There is only partial data for 5/29/2024.\n\ndate_id = \"2024-05-29\"\n(\n  GT(scrape_wunderground(station_id,date_id).head(20))\n    .tab_options(\n      column_labels_background_color = \"#3B3A3EFF\",\n  )\n)\n\n\n\n\n\n\n\ntimestamps\nTemperature\nDew Point\nHumidity\nWind Speed\nWind Gust\nPressure\nPrecip. Rate\nPrecip. Accum.\n\n\n\n\n2024-05-29 10:34 PM\n71.2\n51.2\n50.0\n0.2\n0.2\n29.93\n0.0\n0.0\n\n\n2024-05-29 10:39 PM\n71.7\n53.9\n54.0\n1.4\n9.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:44 PM\n73.1\n55.1\n53.0\n0.8\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:49 PM\n72.8\n54.9\n53.0\n0.0\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:54 PM\n72.4\n53.5\n52.0\n0.0\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 10:59 PM\n72.2\n53.0\n52.0\n0.0\n10.0\n29.94\n0.1\n0.1\n\n\n2024-05-29 11:04 PM\n72.1\n53.0\n52.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:09 PM\n72.0\n53.0\n52.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:14 PM\n71.9\n52.1\n51.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:19 PM\n71.8\n51.8\n51.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:24 PM\n71.6\n51.6\n51.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:29 PM\n71.6\n51.0\n50.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:34 PM\n71.4\n51.0\n49.0\n0.0\n10.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:39 PM\n71.3\n51.0\n49.0\n0.0\n8.0\n29.95\n0.1\n0.1\n\n\n2024-05-29 11:44 PM\n71.2\n50.1\n48.0\n0.0\n2.0\n29.95\n0.0\n0.1\n\n\n2024-05-29 11:49 PM\n71.1\n50.0\n47.0\n0.0\n1.3\n29.95\n0.0\n0.1\n\n\n2024-05-29 11:54 PM\n71.1\n50.0\n47.0\n0.0\n0.0\n29.94\n0.0\n0.1\n\n\n2024-05-29 11:59 PM\n70.9\n50.0\n47.0\n0.0\n0.0\n29.94\n0.0\n0.1\n\n\n\n\n\n\n\n\nAnd 5/28/2024 has no data.\n\ndate_id = \"2024-05-28\"\n(\n  GT(scrape_wunderground(station_id,date_id).head(20))\n    .tab_options(\n      column_labels_background_color = \"#3B3A3EFF\",\n  )\n)\n\n\n\n\n\n\n\ntimestamps\nTemperature\nDew Point\nHumidity\nWind Speed\nWind Gust\nPressure\nPrecip. Rate\nPrecip. Accum.\n\n\n\n\n\n\n\n\n\n\nI will have to find a different nearby weather station for this purpose of finding Ben some weather data for the time period he is interested in (mid 1970s). And, once I succeed at that, I will have to aggregate the 5-minute data to daily data. But once that’s done, my friend should have more than enough weather data to help him with his model."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEquationReset.html",
    "href": "posts/heatEqnReset/HeatEquationReset.html",
    "title": "Using the Heat Equation to model a real-world system (Part 1)",
    "section": "",
    "text": "This is going to be a bit different than usual. I’ve been grappling with my heat equation modeling project and thinking about the difference between the way that this subject is taught vs how it actually can work to describe the real world. For context, when I was an undergrad, I had a Math professor say, “This class is all about the Heat Equation.” Sadly, building a realistic Hot box model such as I have been attempting to do in some previous posts wasn’t covered in a way consistent with realistic physics as that course focused on analytic techniques and methods, and didn’t require us to utilize any computational resources.\nMy hope was this: Figure out a way of solving the heat equation in a generic way, then apply the appropriate boundary conditions, adding new tools and methods as things got more complex. That, ultimately didn’t work, so the previous posts were my attempt to roll my own numerical solution. Which works-ish. I find that I’m being bogged down in computational details on problems that have already been solved, and my solution has to be sub-optimal, and is definitely error prone. This is going to be a little meta, rather than data focused, and talk about why it is always nice to work in a large community of smart people.\nWhy write all of this? This has been bugging me for over a year as I pick it up and put it down. I really do want to solve a real world problem that has a direct impact on my life."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEquationReset.html#intro",
    "href": "posts/heatEqnReset/HeatEquationReset.html#intro",
    "title": "Using the Heat Equation to model a real-world system (Part 1)",
    "section": "",
    "text": "This is going to be a bit different than usual. I’ve been grappling with my heat equation modeling project and thinking about the difference between the way that this subject is taught vs how it actually can work to describe the real world. For context, when I was an undergrad, I had a Math professor say, “This class is all about the Heat Equation.” Sadly, building a realistic Hot box model such as I have been attempting to do in some previous posts wasn’t covered in a way consistent with realistic physics as that course focused on analytic techniques and methods, and didn’t require us to utilize any computational resources.\nMy hope was this: Figure out a way of solving the heat equation in a generic way, then apply the appropriate boundary conditions, adding new tools and methods as things got more complex. That, ultimately didn’t work, so the previous posts were my attempt to roll my own numerical solution. Which works-ish. I find that I’m being bogged down in computational details on problems that have already been solved, and my solution has to be sub-optimal, and is definitely error prone. This is going to be a little meta, rather than data focused, and talk about why it is always nice to work in a large community of smart people.\nWhy write all of this? This has been bugging me for over a year as I pick it up and put it down. I really do want to solve a real world problem that has a direct impact on my life."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEquationReset.html#modeling-the-heat-characteristics-of-a-system.",
    "href": "posts/heatEqnReset/HeatEquationReset.html#modeling-the-heat-characteristics-of-a-system.",
    "title": "Using the Heat Equation to model a real-world system (Part 1)",
    "section": "Modeling the heat characteristics of a system.",
    "text": "Modeling the heat characteristics of a system.\nAs you may or may not know, you need 3 things to model a system’s heat characteristics.\n\nThe Heat Equation. \\[\n\\frac{\\partial u(\\vec{x},t)}{\\partial t} - \\nabla^2 u(\\vec{x},t) = f(\\vec{x},t)\n\\] Here, we are assuming that \\(u(\\vec{x},t)\\) is the temperature at some point in space \\(\\vec{x}\\) within our 3D region of interest \\((\\vec{x}\\in\\Omega\\subset\\mathbb{R}^3)\\), and some time \\(t&gt;0\\). The function \\(f(\\vec{x},t)\\) describes the internal source generation. I’m playing fast and loose with units, but, I’ll bring those back later. Just ask any self respecting theoretical particle physicist, \\(\\hbar=c=1\\).\n\n\nA brief aside about term order:\nAlso of note, some texts introduce the heat equation with the terms in a different order. I’ve chosen to do it this way because it fits with some of the ways that we model systems in physics. For example, the following equation describes a damped harmonic oscillator: \\[\n\\ddot{x}(t) +2\\beta\\dot{x}(t) + \\omega^2x(t) = 0\n\\] where \\(\\beta = \\frac{2b}{m}\\) and \\(\\omega^2=\\frac{k}{m}\\). But a driven, damped oscillator is described by: \\[\n\\ddot{x}(t) +2\\beta\\dot{x}(t) + \\omega^2x(t) = \\frac{F_{\\text{ext}}}{m}\n\\] This matches the homogeneous/non-homogeneous naming convention for the heat equation. So if you are reading a textbook and it talks about the “Homogeneous form of the heat equation,” it’s really talking about the heat equation without any external sources.\n\n\nAn initial condition. That is we need to know the function \\(g\\): \\[\nu(\\vec{x},0) = g(\\vec{x})\n\\] which will be determined by the characteristics of the problem.\nThe boundary conditions. That is, there are places at the “edge” of the system $$ where the heat dynamics is changed by the fact that there is a boundary between our object of interest and another material/system. From a mathematical perspective, we model the boundary in one of 3 ways.\n\n\nDirichelet boundary conditions specify the value of the temperature on the boundary \\[\n  u(\\vec{x},t) = u^D(\\vec{x},t)\n\\] for \\(x\\in\\partial\\Omega\\) and \\(t&gt;0\\). In general, this temperature could depend on the boundary location and time.\nNeumann boundary conditions specify the value of the derivative of the temperature on the boundary \\[\n  \\frac{\\partial u(\\vec{x},t)}{\\partial n} = u^N(\\vec{x},t)\n\\] for \\(x\\in\\partial\\Omega\\) and \\(t&gt;0\\) and \\(n\\) indicates the directional derivative on the boundary surface. Again, the value of this temperature derivative can vary based on the boundary location and time.\nRobin boundary conditions combine the above conditions. Specifically, the linear combination of the two condition types are specified \\[\nu(\\vec{x},t) + b \\frac{\\partial u(\\vec{x},t)}{\\partial n} = u^R(\\vec{x},t)\n\\] for \\(x\\in\\partial\\Omega\\) and \\(t&gt;0\\) as before, with \\(b\\) being some given constant.\n\nOne way of writing the solution to the heat equation that incorporates all of these elements involves Green functions \\[\n\\begin{align*}\nu(\\vec{x},t) = &\\int_0^{\\infty} dt' \\int_{\\Omega} d^3x' \\, G(\\vec{x},t;\\vec{x}',t')f(\\vec{x}',t') \\\\\n& + \\int_{\\Omega} d^3x' G(\\vec{x},t;\\vec{x}',0)u(\\vec{x}',0) \\\\\n& + \\int_0^t dt' \\int_{\\partial\\Omega} da' \\left[ G(\\vec{x},t;\\vec{x}',t') \\frac{\\partial u(\\vec{x}',t')}{\\partial n'} - u(\\vec{x}',t') \\frac{\\partial G(\\vec{x},t;\\vec{x}',t')}{\\partial n'} \\right]\n\\end{align*}\n\\]\nThis can be interpreted as follows. The temperature at each point of space and time depends on 1. Line 1: The behavior of the external sources compared to the Green functions. 2. Line 2: The evolution of the initial condition in terms of the Green functions. 3. Line 3: The evolution of the boundary conditions in terms of the Green functions.\nSo if we can get those Green functions, we’re in business, right?\n\nWhat are Green functions?\nIn the context of the heat equation, Green functions are simply functions what solve the non-homogeneous heat equation, with a very special source term that is written in terms of the Dirac Delta Function: \\[\n\\frac{\\partial G(\\vec{x},t;\\vec{x}',t')}{\\partial t} - \\nabla^2 G(\\vec{x},t;\\vec{x}',t') = \\delta^3\\left(\\vec{x}-\\vec{x}'\\right)\\delta(t-t')\n\\] along with the same boundary conditions as the problem that you are interested in. After many pages of algebraic manipulations, and doing some advanced mathematical gymnastics, you can determine the Green functions: \\[\nG(\\vec{x},t;\\vec{x}',t') = \\sum_n \\frac{\\phi_n(\\vec{x}) \\phi_n(\\vec{x}') \\exp\\left(-\\lambda_n(t-t')\\right)}{\\lVert\\phi_n\\rVert^2}\n\\] where the functions \\(\\phi_n(\\vec{x})\\) solve a sort of eigenvalue equation: \\[\n\\nabla^2\\phi_n(\\vec{x}) = -\\lambda_n \\phi_n(\\vec{x})\n\\] and the term in the denominator is a sort of normalizing factor defined as: \\[\n\\lVert\\phi_n\\rVert^2 = \\int_{\\Omega} \\lvert\\phi_n(\\vec{\\xi})\\rvert^2 d^3\\xi\n\\]\nThe issue is becoming what I like to call a whack-a-mole problem. Math is awesome, they’ve invented functions for just about everything. But these functions are often quite complicated. And using them to inform physical models can also be difficult. Let’s see if I can demonstrate.\n\n\nThe first solution to the heat equation\nLet’s consider the Dirichelet problem found in most textbooks that consider PDEs:\n\nModel a 1D object that has a length of 1, with a uniform initial temperature \\(T_0\\). Each end of the rod will be held at a temperature of 0. Assume no heat escapes along the length of the rod. There are no external heat sources or sinks.\n\nThe answer, outlined in the linked document is: \\[\nu(x,t) = \\sum_{n=1}^{\\infty} \\frac{2T_0}{(2n-1)\\pi}\\sin\\left((2n-1)\\pi x\\right) e^{-(2n-1)^2\\pi^2t}\n\\]\nLet’s note a few things: 1. This is the “easy” problem, and we are already dealing with an infinite series of \\(\\sin\\) functions. 2. The physical world really obeys Robin boundary conditions most often. (This is “convection”)."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEquationReset.html#a-more-realistic-system",
    "href": "posts/heatEqnReset/HeatEquationReset.html#a-more-realistic-system",
    "title": "Using the Heat Equation to model a real-world system (Part 1)",
    "section": "A more realistic system",
    "text": "A more realistic system\nSo let’s imagine the easiest system that we could model that has Robin Boundary conditions.\n(Cue Mission: Impossible music)\n\nYour mission, should you choose to accept it, is to model a 1D object that has a length of 1, with a uniform initial temperature \\(T_0\\). The exterior temperature at each end of the rod is 0. Assume no heat escapes along the length of the rod.\n\nOk, let’s bite. We have the three elements that we need:\n\nThe (1D) Heat Equation: \\[\n\\frac{\\partial u(x,t)}{\\partial t} - \\frac{\\partial^2 u(x,t)}{\\partial x^2} = 0\n\\]\nThe Initial Condition: \\(u(x,0)=T_0\\).\nThe Boundary conditions, one for each end at \\(x=0\\) and \\(x=1\\) \\[\nu(0,t) + \\left. \\frac{\\partial u(x,t)}{\\partial x}\\right|_{x=0} = 0 \\qquad \\text{and} \\qquad u(1,t) - \\left. \\frac{\\partial u(x,t)}{\\partial x}\\right|_{x=1} = 0\n\\]\n\nThe method that we use is separation of variables (as usual), except in 1D this time: \\[\nu(x,t) = X(x) T(t)\n\\] This means that we can write the PDE as: \\[\n\\frac{T'(t)}{T(t)} = \\frac{X''(x)}{X(x)} = -\\lambda\n\\] as before. This allows us to rewrite our boundary conditions as: \\[\nX(0) + X'(0) = 0 \\quad\\text{and}\\quad X(1) - X'(1) = 0\n\\] Consider some cases:\n\nCase 1: \\(\\lambda=0\\)\nIf \\(\\lambda=0\\) then we can say: \\[\nX''(x) = 0 \\quad T'(t)=0 \\implies X(x) = ax+b \\quad T(t) = c\n\\] where \\(a,b,c\\) are arbitrary constants. Let’s apply the boundary condition at \\(x=0\\): \\[\n\\begin{align*}\n0 &= X(0) + X'(0) \\\\\n&= (a \\cdot 0+b) + a \\\\\n&=a+b \\implies b=-a \\implies X(x) = a(x-1)\n\\end{align*}\n\\] Now apply at \\(x=1\\): \\[\n\\begin{align*}\n0 &= X(1) - X'(1) \\\\\n&= a(1-1) - a \\\\\n&= -a \\implies a=0 \\implies X(x) = 0\n\\end{align*}\n\\] This is, what I like to call the boring solution. So we throw it out.\n\n\nCase 2: \\(\\lambda &gt; 0 \\implies \\lambda = k^2\\)\nIf \\(\\lambda=k^2\\) (for some \\(k&gt;0\\)) then we can say: \\[\nX''(x) = -k^2 X(x) \\quad T'(t) = -k^2 T(t) \\implies X(x) = a\\sin(kx)+b\\cos(kx) \\quad T(t) = ce^{-k^2t}\n\\] where \\(a,b,c\\) are arbitrary constants. Let’s apply the boundary condition at \\(x=0\\): \\[\n\\begin{align*}\n0 &= X(0) + X'(0) \\\\\n&= (a \\sin 0 + b \\cos 0) + k(a\\cos 0 - b\\sin 0) \\\\\n&= b+ka \\implies b=-ka \\implies X(x) = a\\left(\\sin(kx) - k \\cos(kx)\\right)\n\\end{align*}\n\\] Now apply at \\(x=1\\): \\[\n\\begin{align*}\n0 &= X(1) - X'(1) \\\\\n&= a\\left(\\sin k - k \\cos k\\right) - ka\\left(\\cos k + k\\sin k \\right) \\\\\n&= a\\sin k \\left(1-k^2\\right) - 2ak\\cos k \\implies \\tan k = \\frac{2k}{1-k^2}\n\\end{align*}\n\\] This is good news/bad news. The good news is that \\(a\\) is a free parameter, so we care about these solutions. If you graph \\[\n\\tan k = \\frac{2k}{1-k^2}\n\\] you will see that there are infinitely many \\(k\\) values that solve this problem. However, there is no analytic solution.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nk = np.linspace(0.1,10*np.pi,1000)\ny1 = np.tan(k)\ny2 = 2*k/(1-k**2)\n\n## Use this to hide the jump discontinuities\ny1[abs(y1)&gt;10] = np.nan\ny2[abs(y2)&gt;10] = np.nan\n\ntol=0.02\nks = k[np.abs(y1-y2)&lt;tol]\nys = y1[np.abs(y1-y2)&lt;tol]\n\nticklabs = ['0',r\"$\\pi$\", r\"$2\\pi$\", r\"$3\\pi$\", r\"$4\\pi$\", r\"$5\\pi$\", r\"$6\\pi$\"\n  , r\"$7\\pi$\", r\"$8\\pi$\", r\"$9\\pi$\", r\"$10\\pi$\"]\n\nfig, ax = plt.subplots()\nfig.suptitle(r\"Finding the $k_n$'s for the Robin condition\")\nax.axhline(color='black',lw=0.5)\nax.set_xlabel(r\"$k$\")\nax.set_ylim([-5,5])\nax.plot(k,y1,label=r\"$\\tan k$\")\nax.plot(k,y2,label=r\"$\\frac{2k}{1-k^2}$\")\nax.plot(ks,ys,'o',color='black',label=r\"$k_n$\")\nax.grid()\nax.set_xticks(np.linspace(0,10*np.pi,11))\nax.set_xticklabels(ticklabs)\nax.set_yticks(np.linspace(-5,5,5))\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nCase 3: \\(\\lambda &lt; 0 \\implies \\lambda = -\\kappa^2\\)\nThese solutions are also trivial and can be ignored. I will leave that proof up to the intrepid reader."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEquationReset.html#why-stop-now",
    "href": "posts/heatEqnReset/HeatEquationReset.html#why-stop-now",
    "title": "Using the Heat Equation to model a real-world system (Part 1)",
    "section": "Why stop now?",
    "text": "Why stop now?\nOk, so this is a problem. In general, it’s best to focus on one hard thing at a time when solving problems, and a purely analytic method will not generalize well to more complex boundary conditions, especially if we respect the physically appropriate boundary condition. Also (and this has really tried my soul), I haven’t thought about practical things like actual units. If I want to model a real-world system, SI units are really helpful for that. Plus, specs for real world materials are available. And if I have to convert something like cubic freedom units per minute to an SI unit, I can do that.\nSo in my next post, I’m going to generate a numerical model solving the Robin problem, and compare it to the Dirichelet problem that I solved previously."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinSlab.html",
    "href": "posts/heatEqnReset/HeatEqnRobinSlab.html",
    "title": "Using the Heat Equation to model a real-world system (Part 5)",
    "section": "",
    "text": "I’m going to model a simple 3D slab with convection. For now, I’m not including any power generation, and this slab is going to have thermal properties that make the visualization look well enough. Rather than including all of the code in this post, I’m going to point you to my Github Repository where the code exists. Here I will grab bits of the new code that I found difficult to figure out and discuss the lessons I’ve learned (or sometimes, would like to learn). This is also useful, since much of the code is the same as the previous code.\nOur slab has the following properties.\n\nLength and height are both 1 (insert arbitrary length unit)\nWidth is 2 (insert arbitrary length unit)\nInitial temp is 10 (arbitrary temperature units)\nExternal temp is 0 (arbitrary temperature units)\n\nMy next post will talk about units and do some physics."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinSlab.html#modeling-a-3d-slab-with-convection",
    "href": "posts/heatEqnReset/HeatEqnRobinSlab.html#modeling-a-3d-slab-with-convection",
    "title": "Using the Heat Equation to model a real-world system (Part 5)",
    "section": "",
    "text": "I’m going to model a simple 3D slab with convection. For now, I’m not including any power generation, and this slab is going to have thermal properties that make the visualization look well enough. Rather than including all of the code in this post, I’m going to point you to my Github Repository where the code exists. Here I will grab bits of the new code that I found difficult to figure out and discuss the lessons I’ve learned (or sometimes, would like to learn). This is also useful, since much of the code is the same as the previous code.\nOur slab has the following properties.\n\nLength and height are both 1 (insert arbitrary length unit)\nWidth is 2 (insert arbitrary length unit)\nInitial temp is 10 (arbitrary temperature units)\nExternal temp is 0 (arbitrary temperature units)\n\nMy next post will talk about units and do some physics."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinSlab.html#building-a-3d-domain",
    "href": "posts/heatEqnReset/HeatEqnRobinSlab.html#building-a-3d-domain",
    "title": "Using the Heat Equation to model a real-world system (Part 5)",
    "section": "Building a 3D domain",
    "text": "Building a 3D domain\nThe first challenge is to build a 3D domain. Fortunately, FENICSx has a function for that, and my code looks like this:\n\nL = 1.0  # Length of the slab\nW = 2.0  # Width of the slab \nH = 1.0  # Height of the slab \ndl = 0.05 # Element size for the mesh\nnx, ny, nz = int(L/dl), int(W/dl), int(H/dl)  # Number of elements in each direction\n\n# Define the mesh and function space\nbottom_back_left = np.array([0.0, 0.0, 0.0])  # Bottom back corner of the slab\ntop_front_right = np.array([L, W, H])  # Top front corner of the slab\n# Create a 3D domain representing the slab\ndomain = mesh.create_box(\n    MPI.COMM_WORLD,  # MPI communicator\n    [bottom_back_left,top_front_right],  # Coordinates of the corners of the rectangle\n    [nx, ny, nz],  # Number of elements in each direction\n    mesh.CellType.tetrahedron,  # Type of elements \n    ghost_mode=mesh.GhostMode.shared_facet  # Ghost mode for shared facets\n)\n\nI struggled to get this right for longer than I would like to admit. For some reason, when I was building the domain and generating the appropriate function spaces, my code was failing when I was building the interpolating the initial condition into the appropriate function space. I finally added the ghost_mode=mesh.GhostMode.shared_facet line to the above and it started working. As near as I can tell, this is why that is required:\n\nFENICSx, in general, is designed for computationally intensive calculations. So it takes advantage of parallelization.\nOne common parallelization scheme is to divide the computation into bits, operate them independantly, and then pull them back together. For example, if you have a group homework assignment with 10 questions and a group of 5 people, you assign 2 problems to everyone, then staple them together at the end. Parallel computing, effectively, does this with processors.\nHowever, sometimes the problems aren’t fully independant. Suppose that one needs the answer to question 1 in order to answer questions 2, 3, and 4 in my homework assignment example above. Somehow, the answer to question 1 needs to be provided for the persons doing questions 2, 3, and 4. For parallel computing with FENICSx, this is done with the ghost mode. So by not specifying a ghost mode, I found that the default ghost mode didn’t work for the mesh/functionspace that I defined.\n\nThe above is a very hand-wavy explanation, and is enough for me (for now anyway). So, I then created the function space as usual, and defined the parameters that are important for this problem.\n\nV = functionspace(domain, (\"Lagrange\", 1))\ntdim = domain.topology.dim  # Topological dimension of the domain\n\nx = SpatialCoordinate(domain)  # Spatial coordinates of the domain\ntempExt = lambda x: extTemp  # External temperature function (constant in this case)\ns = tempExt(x)  # External temperature at the boundary\nf = Constant(domain, PETSc.ScalarType(0))  # Source term (zero in this case)\nh = Constant(domain, PETSc.ScalarType(0.1))  # Robin boundary condition coefficient\nkappa = Constant(domain, PETSc.ScalarType(1.0))  # Thermal conductivity \n\n#########################################\n# Set up the initial condition\ndef initial_condition(x, Temp=T0, a=0):\n    return Temp * np.exp(-a * (x[0]**2 + x[1]**2 + x[2]**2))  # Initial temperature T0 defined elsewhere\n\nuPrev = Function(V)\nuPrev.name = \"uPrev\"\nuPrev.interpolate(initial_condition)  # Interpolate the initial condition into the function space\n\nI found that if I left the * np.exp(-a * (x[0]**2 + x[1]**2 + x[2]**2)) expression out of the return statement, there was an error message stating that the arguments were the wrong shape, and the interpolation didn’t work. I tried tracking it down, but ultimately came up with this hacky solution."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinSlab.html#finally-a-pretty-picture",
    "href": "posts/heatEqnReset/HeatEqnRobinSlab.html#finally-a-pretty-picture",
    "title": "Using the Heat Equation to model a real-world system (Part 5)",
    "section": "Finally, a pretty picture",
    "text": "Finally, a pretty picture\nThe rest of the computation proceeded as usual. I was able to make a gif of the output using pyvista. The time-step parameters were chosen so that there was a change, and it was visible."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnRobinSlab.html#next-steps",
    "href": "posts/heatEqnReset/HeatEqnRobinSlab.html#next-steps",
    "title": "Using the Heat Equation to model a real-world system (Part 5)",
    "section": "Next steps",
    "text": "Next steps\n\nDo some physics. These arbitrary length, temperature, and time units simply will not do!\nPut the slab in the sun.\nMake prettier visualizations using pyvista and/or ParaView.\n\nNote, ParaView is a separate program used for 3D visualizations, not a Python package. This is also part of the rationale behind building the github repository. I’ll need to create visualizations outside of a Quarto doc (like a majority of my other posts) and have to build visualizations elsewhere, then link to them."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset3.html",
    "href": "posts/heatEqnReset/HeatEqnReset3.html",
    "title": "Using the Heat Equation to model a real-world system (Part 3)",
    "section": "",
    "text": "If you have been following my recent series of posts, I’ve been talking about why solving the heat equation for a real problem is hard, and then I did some tedious Linear Algebra. All to solve a simple 1D heat equation problem. Now the plan is to repeat this analysis for the Dirichlet boundary condition using the FENICSx software.\nI’m not going to re-create the math, but, if you follow what I have done previously, you will see that we can define the bilinear form: \\[\na(u^k, v) = \\int_\\Omega \\left(u^k(\\vec{x})v(\\vec{x}) + \\Delta t \\nabla u^k(\\vec{x}) \\cdot \\nabla v(\\vec{x})\\right) d^3x  + \\sum_l \\int_{\\Gamma_R^l} h_l^k u^k(\\vec{x}) v(\\vec{x}) ds\n\\] and the linear form: \\[\n\\begin{align*}\nL(v) = &\\int_\\Omega \\left(u^{k-1}(\\vec{x})v(\\vec{x}) + \\Delta t f^k(\\vec{x}) v(\\vec{x})\\right)d^3x \\\\\n&+ \\sum_l \\int_{\\Gamma_R^l} h_l^k s^k_l(\\vec{x}) v(\\vec{x}) ds + \\sum_j \\int_{\\Gamma_N^j} g_j^k v(\\vec{x}) ds\n\\end{align*}\n\\] of the heat equation.\nAt this point in the previous analysis, we set up a mesh and converted the hard integral problem into a Linear algebra problem. For example, we defined a function: \\[\n\\varphi_m(x,y,z) =\n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_i\\right|}{h}\\right) \\left(1-\\frac{\\left|y-y_j\\right|}{h}\\right) \\left(1-\\frac{\\left|z-z_k\\right|}{h}\\right) &\\left|x-x_i\\right|\\leq h\n\\left|y-y_j\\right|\\leq h \\left|z-x_k\\right|\\leq h \\\\\n0 &\\text{else}\n\\end{cases}\n\\] where \\[\n\\vec{x}_m = (x_i, y_j, z_k)\n\\] Then we chose: \\[\nv(\\vec{x}) = \\varphi_n(\\vec{x})\n\\] and \\[\nu^k(\\vec{x}) = \\sum_m u^k_m \\varphi_m(\\vec{x})\n\\] But each of these choices has consequences about the accuracy and stability of the computation. For example, mesh size/shape are known to be important, especially if the solution is likely to vary a great deal in a region. The beauty of FENICSx is that they do the crazy math that I did by hand last time, and they handle all the boundaries too.\nThe upside of using FENICSx (or a similar framework) is that the code does the tedious parts for me. This allows me to focus on the physical aspects of the problem. And, all of the other kinds of systems that I would want to model are able to be described using appropriate meshes and/or geometries. The downside is that in addition to needing to know/understand all of the modeling bits that we’ve done already, you need to have an understanding of the weak formulation, informing you why this approach is needed and works to solve the problem. Merely wrapping my head around this has (in part) explained the gap between my first heat equation post and this more recent series.\nIn some sense, by solving the Dirichlet rod problem with FENICSx, I’m brining a nuke to a fist fight. Ok, so I’ll “win”. But learning how to build a nuke is only worthwhile if I am going to model more complex things. Which, if we go to the way-back machine, we’ll remember that my goal was to figure out why my house was so daggone hot even though my AC was on full blast all summer. So (to continue the analogy) the nuke is warranted. This has been, and continues to be, part of a long process for me to learn “nuclear physics” so my model is worthwhile."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset3.html#finally-lets-use-some-software-to-do-this",
    "href": "posts/heatEqnReset/HeatEqnReset3.html#finally-lets-use-some-software-to-do-this",
    "title": "Using the Heat Equation to model a real-world system (Part 3)",
    "section": "",
    "text": "If you have been following my recent series of posts, I’ve been talking about why solving the heat equation for a real problem is hard, and then I did some tedious Linear Algebra. All to solve a simple 1D heat equation problem. Now the plan is to repeat this analysis for the Dirichlet boundary condition using the FENICSx software.\nI’m not going to re-create the math, but, if you follow what I have done previously, you will see that we can define the bilinear form: \\[\na(u^k, v) = \\int_\\Omega \\left(u^k(\\vec{x})v(\\vec{x}) + \\Delta t \\nabla u^k(\\vec{x}) \\cdot \\nabla v(\\vec{x})\\right) d^3x  + \\sum_l \\int_{\\Gamma_R^l} h_l^k u^k(\\vec{x}) v(\\vec{x}) ds\n\\] and the linear form: \\[\n\\begin{align*}\nL(v) = &\\int_\\Omega \\left(u^{k-1}(\\vec{x})v(\\vec{x}) + \\Delta t f^k(\\vec{x}) v(\\vec{x})\\right)d^3x \\\\\n&+ \\sum_l \\int_{\\Gamma_R^l} h_l^k s^k_l(\\vec{x}) v(\\vec{x}) ds + \\sum_j \\int_{\\Gamma_N^j} g_j^k v(\\vec{x}) ds\n\\end{align*}\n\\] of the heat equation.\nAt this point in the previous analysis, we set up a mesh and converted the hard integral problem into a Linear algebra problem. For example, we defined a function: \\[\n\\varphi_m(x,y,z) =\n\\begin{cases}\n\\left(1-\\frac{\\left|x-x_i\\right|}{h}\\right) \\left(1-\\frac{\\left|y-y_j\\right|}{h}\\right) \\left(1-\\frac{\\left|z-z_k\\right|}{h}\\right) &\\left|x-x_i\\right|\\leq h\n\\left|y-y_j\\right|\\leq h \\left|z-x_k\\right|\\leq h \\\\\n0 &\\text{else}\n\\end{cases}\n\\] where \\[\n\\vec{x}_m = (x_i, y_j, z_k)\n\\] Then we chose: \\[\nv(\\vec{x}) = \\varphi_n(\\vec{x})\n\\] and \\[\nu^k(\\vec{x}) = \\sum_m u^k_m \\varphi_m(\\vec{x})\n\\] But each of these choices has consequences about the accuracy and stability of the computation. For example, mesh size/shape are known to be important, especially if the solution is likely to vary a great deal in a region. The beauty of FENICSx is that they do the crazy math that I did by hand last time, and they handle all the boundaries too.\nThe upside of using FENICSx (or a similar framework) is that the code does the tedious parts for me. This allows me to focus on the physical aspects of the problem. And, all of the other kinds of systems that I would want to model are able to be described using appropriate meshes and/or geometries. The downside is that in addition to needing to know/understand all of the modeling bits that we’ve done already, you need to have an understanding of the weak formulation, informing you why this approach is needed and works to solve the problem. Merely wrapping my head around this has (in part) explained the gap between my first heat equation post and this more recent series.\nIn some sense, by solving the Dirichlet rod problem with FENICSx, I’m brining a nuke to a fist fight. Ok, so I’ll “win”. But learning how to build a nuke is only worthwhile if I am going to model more complex things. Which, if we go to the way-back machine, we’ll remember that my goal was to figure out why my house was so daggone hot even though my AC was on full blast all summer. So (to continue the analogy) the nuke is warranted. This has been, and continues to be, part of a long process for me to learn “nuclear physics” so my model is worthwhile."
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset3.html#fenicsx-solution",
    "href": "posts/heatEqnReset/HeatEqnReset3.html#fenicsx-solution",
    "title": "Using the Heat Equation to model a real-world system (Part 3)",
    "section": "FENICSx Solution",
    "text": "FENICSx Solution\nLet’s build this solution using FENICSx. Start by importing some libraries that are going to be required.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mc\nimport matplotlib.cm as cm\n## FENICSx assumes that you are going to be doing some heavy computations and will take advantage of parallel \n## processing capabilities. The PETSC and MPI packages allow you to do this.\nfrom petsc4py import PETSc\nfrom mpi4py import MPI\n## These allow you to generate meshes and do the finite element method.\nfrom dolfinx import mesh, fem\nimport ufl\nfrom dolfinx.fem.petsc import assemble_vector, assemble_matrix, create_vector, apply_lifting, set_bc\nfrom uDiricheletExact import *\n\nSet up the simulation parameters. Define the mesh and function space. Under the hood, the fem.functionspace command is creating a polynomial basis function under the hood.\n\nt = 0 \nfinal_time = 1.0  # Final time for the simulation\ndt = 0.01  # Time step size\nnum_steps = int((final_time - t) / dt)  \nT0 = 10.0  # Initial temperature distribution along the rod\ntPlot = np.linspace(0, final_time, num_steps+1)  # Time points for plotting\n\n# Define the mesh \nn_elements = 32\n# Create a 1D domain representing the rod from 0 to 1\ndomain = mesh.create_interval(\n    MPI.COMM_WORLD,  # MPI communicator\n    n_elements,  # Number of elements in the mesh\n    [0.0, 1.0]  # Interval from 0 to 1 (the length of the rod)\n)\n\n# Create a function space for the finite element method\nV = fem.functionspace( \n    domain, ('Lagrange',1) # Linear Lagrange elements (polynomials)\n)\n\nSet up the initial condition u_n and set up a “working solution” uh.\n\ndef initial_condition(x):\n  return np.full(x.shape[1], T0, dtype=np.float64)  # Initial temperature T0\n\nu_n = fem.Function(V)\nu_n.name = \"u_n\"  # Name the function for clarity\nu_n.interpolate(initial_condition)  # Interpolate the initial condition into the function space\n\n# Define solution variable\nuh = fem.Function(V)\nuh.name = \"uh\"  # Name the function for clarity \nuh.interpolate(initial_condition)\n\nSet up the (Dirichlet) boundary conditions for the problem:\n\nuD = fem.Constant(domain, PETSc.ScalarType(0))  # u(0,t) = 0 and u(1,t) = 0\n# Create facet to cell connectivity required to determine boundary facets\nfdim = domain.topology.dim - 1\n# Locate the boundary facets of the mesh\nboundary_facets = mesh.locate_entities_boundary(\n  domain, # Domain mesh\n  fdim,  # Dimension of the facets (1D for a rod)\n  lambda x: np.full(x.shape[1], True, dtype=bool)  # All facets are boundary facets\n)\nboundary_dofs = fem.locate_dofs_topological(V, fdim, boundary_facets)\nbc = fem.dirichletbc(uD, boundary_dofs, V)\n\nSet up the required functions for the variational problem including the source term (which is zero in this case). Then, define the \\(a(u,v)\\) and \\(L(v)\\) in terms of these functions, and convert to a form suitable for FENICSx.\n\nu = ufl.TrialFunction(V)  # Trial function for the finite element method\nv = ufl.TestFunction(V)  # Test function for the finite element method\nf = fem.Constant(domain, PETSc.ScalarType(0))  # Source term (zero in this case)\n\na = u * v * ufl.dx + dt * ufl.inner(ufl.grad(u), ufl.grad(v)) * ufl.dx\nL = (u_n + dt * f) * v * ufl.dx\nbilinear_form = fem.form(a)\nlinear_form = fem.form(L)\n\nDo the Linear Algebra required\n\n# Assemble the Linear Algebra structures\nA = assemble_matrix(bilinear_form, bcs=[bc])\nA.assemble()  # Assemble the matrix A\nb = create_vector(linear_form)  # Create a vector for the right-hand side\n\n# Create a linear solver\nsolver = PETSc.KSP().create(domain.comm)\nsolver.setOperators(A)  # Set the matrix A for the solver\nsolver.setType(PETSc.KSP.Type.PREONLY)  # Use a preconditioner\nsolver.getPC().setType(PETSc.PC.Type.LU)  # Use LU preconditioner\n\nAnd prepare to make a plot. I’ll make a 3D surface plot and the variable Uc is my computational solution.\n\nxMesh = domain.geometry.x[: ,0]\nTc, Xc = np.meshgrid(tPlot, xMesh)  # Create a mesh grid for plotting\nUc = np.zeros_like(Tc)\nUc[:, 0] = u_n.x.array  # Initial condition for plotting\n\nNow, repeat the process for each time-step, filling in the Uc array as we go:\n\nfor i in range(num_steps):\n  t += dt  # Current time\n\n  # Update the RHS reusing the previous solution\n  with b.localForm() as loc_b:\n    loc_b.set(0.0)\n  \n  assemble_vector(b, linear_form)\n  apply_lifting(b, [bilinear_form], [[bc]])  # Apply boundary conditions\n  b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)  # Update ghost values\n  set_bc(b, [bc])  # Set the boundary conditions\n\n  # Solve linear problem\n  solver.solve(b, uh.x.petsc_vec)\n  uh.x.scatter_forward()\n\n  # Update the solution at the current time step for plotting\n  Uc[:, i+1] = uh.x.array\n  \n  # Update solution at previous time step (u_n)\n  u_n.x.array[:] = uh.x.array\n\n\nMake a pretty picture\nSo, let’s see how this computation compares to the exact solution.\n\nx_exact = np.linspace(0, 1, 100)  # Points along the rod for exact solution\nTe, Xe = np.meshgrid(tPlot, x_exact)  # Create a mesh grid for exact solution\nUe = uDiricheletExact(Te, Xe, T0)  # Compute the exact solution at time t\n\ncnorm = mc.Normalize(vmin=0,vmax=T0)\ncbar = cm.ScalarMappable(norm=cnorm)\n\nfig, ax = plt.subplots(ncols=2, subplot_kw={'projection': '3d'},figsize=(14,7) ) # Create a 3D plot\nax[0].plot_surface(Xc, Tc, Uc, cmap='viridis', edgecolor='none')  # Plot the FENICS solution\nax[0].set_title('FENICS Solution')  # Title for FENICS solution\nax[0].set_xlabel('Position along the rod (x)')  # X-axis label\nax[0].set_ylabel('Time (t)')  # Y-axis label\nax[0].set_zlabel('Temperature')  # Z-axis label\nax[1].plot_surface(Xe, Te, Ue, cmap='viridis', edgecolor='none')  # Plot the exact solution\nax[1].set_title('Exact Solution')  # Title for exact solution\nax[1].set_xlabel('Position along the rod (x)')  # X-axis label\nax[1].set_ylabel('Time (t)')  # Y-axis label\nax[1].set_zlabel('Temperature')  # Z-axis label\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.suptitle('Dirichlet Problem for a Unit Rod')  # Overall title for the plot\nplt.subplots_adjust(top=0.9)  # Adjust the top margin to fit\nghLogo = u\"\\uf09b\"\nliLogo = u\"\\uf08c\"\ntxt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\nfig.subplots_adjust(bottom=0.05,right=0.85)\nplt.figtext(0.75,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\ncbar_ax = fig.add_axes([0.9, 0.1, 0.02, 0.7])\nfig.colorbar(cbar, cax=cbar_ax,label='Temperature [arb. units]')\nplt.show()  # Show the plot\n\n\n\n\n\n\n\n\nWooHoo!"
  },
  {
    "objectID": "posts/heatEqnReset/HeatEqnReset3.html#conclusion",
    "href": "posts/heatEqnReset/HeatEqnReset3.html#conclusion",
    "title": "Using the Heat Equation to model a real-world system (Part 3)",
    "section": "Conclusion",
    "text": "Conclusion\nOk, now that I have kicked the tires on FENICSx, I’m going to call it a day. My next step will be to replicate my Robin Condition. Then I’ll go to 3D and make a model for a sweatbox. I’ll need to fold back in my solar radiation work to make this happen. And I’ll have to think about the physics (because I just haven’t been thinking about things like space/time/temperature units since the reboot).\nI also know that I’ve only touched on the edges of this software suite. My plans are to figure out more complex meshes. (For example, if I want to model a house, I’ll need to make walls and windows and stuff like that.) I will also need to figure out PyVista - software that they use to make nice visualizations, especially for 3D objects."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html",
    "href": "posts/heatEqn2/heatEqn2.html",
    "title": "Modeling Heat Flow - Part 2",
    "section": "",
    "text": "Previously, I modeled a “hot box”, but ignored the effects of the sun. As anyone who has had to get into a car that has sat outside for a while on a hot summer day, the inside of the car is warmer than the outside air temperature, and my previous model didn’t allow that. So the sun is important. Consider the following information from The Humane Society.\n\nIt doesn’t have to be that warm outside for a car to become dangerously hot inside.\n\nWhen it’s 72 degrees Fahrenheit outside, the temperature inside your car can heat up to 116 degrees Fahrenheit within an hour.\nWhen it’s 80 degrees Fahrenheit outside, the temperature inside your car can heat up to 99 degrees Fahrenheit within 10 minutes.\nRolling down the windows has been shown to have little effect on the temperature inside a car.\n\n\nLet’s translate these temperatures to Celsius and Kelvin\n\nWhen it’s 22 degrees Celsius outside, the temperature inside your car can heat up to 47 degrees Celsius within an hour.\nWhen it’s 27 degrees Celsius outside, the temperature inside your car can heat up to 37 degrees Celsius within 10 minutes.\n\nMy plan for this post is to assume that my heat box will heat up similarly to the above generic car, and see what sort of parameters I need to make that work."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#background",
    "href": "posts/heatEqn2/heatEqn2.html#background",
    "title": "Modeling Heat Flow - Part 2",
    "section": "",
    "text": "Previously, I modeled a “hot box”, but ignored the effects of the sun. As anyone who has had to get into a car that has sat outside for a while on a hot summer day, the inside of the car is warmer than the outside air temperature, and my previous model didn’t allow that. So the sun is important. Consider the following information from The Humane Society.\n\nIt doesn’t have to be that warm outside for a car to become dangerously hot inside.\n\nWhen it’s 72 degrees Fahrenheit outside, the temperature inside your car can heat up to 116 degrees Fahrenheit within an hour.\nWhen it’s 80 degrees Fahrenheit outside, the temperature inside your car can heat up to 99 degrees Fahrenheit within 10 minutes.\nRolling down the windows has been shown to have little effect on the temperature inside a car.\n\n\nLet’s translate these temperatures to Celsius and Kelvin\n\nWhen it’s 22 degrees Celsius outside, the temperature inside your car can heat up to 47 degrees Celsius within an hour.\nWhen it’s 27 degrees Celsius outside, the temperature inside your car can heat up to 37 degrees Celsius within 10 minutes.\n\nMy plan for this post is to assume that my heat box will heat up similarly to the above generic car, and see what sort of parameters I need to make that work."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#previous-work",
    "href": "posts/heatEqn2/heatEqn2.html#previous-work",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Previous work",
    "text": "Previous work\nAs before, I’ll model the system as a simple box, however, this time it will be car-sized, and I’ll use thermal properties that are common for metals like aluminum, rather than parameters used for building materials.\n\n\nCode\nimport numpy as np\n\n# Heat parameters\nthermalDiffusivity = 22.39e-6 # meters^2/s for air\nheatTransferCoef = 1 # For a typical metal to air W/m^2K\nthermalConductivity = 50 # For a typical metal W/mK\nspecificHeat = 1000 # for aluminum J/kg K\nwallDensity = 3000 # kg/m^3 for aluminum\nsolarIntensity = 1000 # W/m^2\n\n# Length parameters (meters)\nL = 3\nW = 2\nH = 1.5\n\nDeltax = 0.05\nxmax = int(L/Deltax)\nymax = int(W/Deltax)\nzmax = int(H/Deltax)\n\nxmid = xmax // 2\nymid = ymax // 2\nzmid = zmax // 2\n\nxgrid = np.linspace(0,L,xmax+1)\nygrid = np.linspace(0,W,ymax+1)\nzgrid = np.linspace(0,H,zmax+1)\n\nu0 = np.empty((xmax,ymax,zmax))"
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#heat-equation",
    "href": "posts/heatEqn2/heatEqn2.html#heat-equation",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Heat Equation",
    "text": "Heat Equation\nThe heat equation is:\n\\[\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2u + \\text{Internal Power Generation Term} + \\text{Convection on the boundary}\n\\]\nWhere \\(\\alpha=\\frac{k}{c\\rho}\\) is the thermal diffusivity of the material, and \\(k\\) is the thermal conductivity, \\(c\\) is the specific heat, and \\(\\rho\\) is the density. The internal power generation term is going to be related to heat generation due to the absorption of sunlight, and will only be important on surfaces exposed to sunlight. The Boundary convection term will be, again only important on the exterior of the object being modeled. I’ll describe these terms in more detail later in this post.\nWhen working numerically, it is common to employ a finite mesh of points and determine the system temperature at each of these points in space as follows: \\[\nu(x,y,z,t) \\rightarrow u(x_i,y_j,z_k,t) = u_{i,j,k}(t)\n\\]\nI will create this 3D array of functions in time, rather than a 4D array, with one of the dimensions being the evolution in time because when solving differential equations, it is often important to adjust the time step to suit the numerical needs of the system. This way, I will be able to use numerical differential equation solvers as I tackle this problem.\n\nInternal Power Generation\nThis should be proportional to the solar intensity. At the surface of the earth, the intensity of sunlight on a clear day is about 1000 \\(\\text{W}/\\text{m}^2\\). For now, I will model it as:\n\\[\nA I_{\\text{sun}} f(x,y,z)\n\\]\nwhere \\(A\\) is a constant that I will determine empirically. For this model, I will assume:\n\\[\nf(x,y,z) =\n\\begin{cases}\n1 &z=H \\\\\n0 &\\text{else}\n\\end{cases}\n\\]\nThis has the meaning that for this model, the sun is directly overhead, and sunlight is only incident on the top of the box. The constant \\(A\\) should depend on material properties like specific heat and density as follows:\n\\[\nA = \\frac{1}{c\\rho\\delta_{\\text{eff}}}\n\\]\nwhere \\(\\delta_{\\text{eff}}\\) is an effective depth that the sunlight penetrates.\n\n\nCode\ndef powerGen(umat, t, intensity, A):\n    powerGen = np.zeros_like(umat)\n\n    powerDensity = A*intensity\n    powerGen[:,:,-1].fill(powerDensity)\n\n    return powerGen\n\n\n\n\nBoundary convection\nThe power exchange per unit volume due to convection is proportional to the difference in temperature of air and the temperature at the boundary:\n\\[\nB \\left(T_{\\text{air}}-u(x_S,y_S,z_S,t)\\right)\n\\]\nfor points \\((x_S,y_S,z_S)\\) on the boundary of the object (assuming a uniform air temperature). Again, \\(B\\) is a constant that I will determine empirically. However, the constant \\(B\\) should depend on material properties like specific heat, density, and the heat transfer coefficient as follows:\n\\[\nB = \\frac{h}{c\\rho\\Delta_{\\text{eff}}}\n\\]\nwhere \\(\\Delta_{\\text{eff}}\\) is an effective thickness of the convection surface.\n\n\nCode\ndef bdryConv(umat, t, Tair, B):\n\n    bdryTemp = np.zeros_like(umat)\n    uSurf = np.zeros_like(umat)\n\n    bdryTemp[0,:,:].fill(Tair)\n    bdryTemp[:,0,:].fill(Tair)\n    bdryTemp[:,:,0].fill(Tair)\n    bdryTemp[-1,:,:].fill(Tair)\n    bdryTemp[:,-1,:].fill(Tair)\n    bdryTemp[:,:,-1].fill(Tair)\n\n    uSurf[0,:,:] = umat[0,:,:]\n    uSurf[:,0,:] = umat[:,0,:]\n    uSurf[:,:,0] = umat[:,:,0]\n    uSurf[-1,:,:] = umat[-1,:,:]\n    uSurf[:,-1,:] = umat[:,-1,:]\n    uSurf[:,:,-1] = umat[:,:,-1]\n\n    duConvdt = B*(bdryTemp - uSurf)\n    return duConvdt  \n\n\n\n\nLaplacian\nLastly I have to deal with the Laplacian in the following cases:\n\nInterior points\nBoundary surfaces\nBoundary edges\nBoundary corners\n\nIn the finite difference method, the Laplacian is proportional to the average deviation of the current point from the nearest neighbors. I’ll show how this is calculated in later sections for surfaces, edges and corners. All in all this is quite tedious, and if you want to skip the math, navigate to the Analysis Plan section through the menu at the right.\n\nHeat Equation on the interior of the box\nThe heat equation on the interior of the box has none of the contributions from the boundary terms: \\[\n\\frac{\\partial u(x,y,z,t)}{\\partial t} = \\alpha\\nabla^2 u(x,y,z,t)\n\\]\nWhen we apply the finite element approximation, we get the following:\n\\[\\begin{align*}\n  \\nabla^2 u(x,y,z,t) \\rightarrow \\frac{1}{\\Delta x\\Delta y\\Delta z}\n                        &\\left(\\Delta y \\Delta z \\frac{u_{i-1,j,k}(t) + u_{i+1,j,k}(t) -\n                        2 u_{i,j,k}(t)}{\\Delta x} \\right.\\\\\n                       &\\quad + \\Delta x \\Delta z \\frac{u_{i,j-1,k}(t) + u_{i,j+1,k}(t) - 2\n                        u_{i,j,k}(t)}{\\Delta y} \\\\\n                       &\\qquad \\left. + \\Delta x \\Delta y \\frac{u_{i,j,k-1}(t) + u_{i,j,k+1}(t)\n                         - 2 u_{i,j,k}(t)}{\\Delta z}\\right) \\\\\n\\end{align*}\\]\nThis simplifies to: \\[\\begin{align*}\n  \\nabla^2 u(x,y,z,t)\n       &\\rightarrow \\frac{u_{i-1,j,k}(t) + u_{i+1,j,k}(t) - 2 u_{i,j,k}(t)}{\\Delta x^2} \\\\\n       &\\quad +\\frac{u_{i,j-1,k}(t) + u_{i,j+1,k}(t) - 2 u_{i,j,k}(t)}{\\Delta y^2} \\\\\n       & \\qquad + \\frac{u_{i,j,k-1}(t) + u_{i,j,k+1}(t) - 2 u_{i,j,k}(t)}{\\Delta z^2}\n\\end{align*}\\]\nIf we generate our grid with \\(\\Delta x = \\Delta y = \\Delta z\\), we obtain:\n\\[\n\\nabla^2 u_{i,j,k} =  \\frac{u_{i-1,j,k} + u_{i+1,j,k} + u_{i,j-1,k} + u_{i,j+1,k} + u_{i,j,k-1} + u_{i,j,k+1} - 6 u_{i,j,k}}{\\Delta x^2} \\\\\n\\]\n\n\nHeat Equation on a boundary surface\nSo if we are considering the \\(x=0, i=0\\) surface: \\[\n\\frac{du_{0,j,k}(t)}{\\partial t} = \\alpha \\nabla^2 u_{0,j,k}(t) + f_{0jk}(t) + \\frac{h}{c\\rho}(T_{\\text{air}}-u_{0,j,k})\n\\] where\n\\[\\begin{align*}\n\\nabla^2 u_{0,j,k}(t) &= \\frac{1}{\\Delta x\\Delta y\\Delta z} \\left(\\Delta y \\Delta z\n                        \\frac{u_{1,j,k}(t) - u_{0,j,k}(t)}{\\Delta x} \\right. \\\\\n            &\\qquad + \\frac{\\Delta x}{2} \\Delta z \\frac{u_{0,j-1,k}(t) + u_{0,j+1,k}(t) - 2 u_{0,j,k}(t)}{\\Delta y} \\\\\n            &\\qquad \\left. + \\frac{\\Delta x}{2} \\Delta y \\frac{u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 2\n              u_{0,j,k}(t)}{\\Delta z}\\right)\n\\end{align*}\\]\nThis simplifies to:\n\\[\\begin{align*}\n  \\nabla^2 u_{0,j,k}(t) = \\frac{1}{2} &\\left(\\frac{2 u_{1,j,k}(t) - 2 u_{0,j,k}(t)}{\\Delta x^2}\\right. \\\\\n            &\\qquad + \\frac{u_{0,j-1,k}(t) + u_{0,j+1,k}(t) - 2 u_{0,j,k}(t)}{\\Delta y^2} \\\\\n            &\\qquad + \\left. \\frac{u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 2 u_{0,j,k}(t)}{\\Delta\n              z^2} \\right) \\\\\n\\end{align*}\\]\nAgain, with a uniform grid, this becomes: \\[\n\\nabla^2 u_{0,j,k}(t) = \\frac{2 u_{1,j,k}(t) + u_{0,j-1,k}(t) + u_{0,j+1,k}(t) + u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 6 u_{0,j,k}(t)}{2 \\Delta x^2}\n\\]\nFollowing a similar method we can find for all 6 surfaces:\n\\[\\begin{align*}\n\\nabla^2 u_{0,j,k}(t) &= \\frac{2 u_{1,j,k}(t) + u_{0,j-1,k}(t) + u_{0,j+1,k}(t) + u_{0,j,k-1}(t) + u_{0,j,k+1}(t) - 6 u_{0,j,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{I,j,k}(t) &= \\frac{2 u_{I-1,j,k}(t) + u_{I,j-1,k}(t) + u_{I,j+1,k}(t) + u_{I,j,k-1}(t) + u_{I,j,k+1}(t) - 6 u_{I,j,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,0,k}(t) &= \\frac{2 u_{i,1,k}(t) + u_{i-1,0,k}(t) + u_{i+1,0,k}(t) + u_{i,0,k-1}(t) + u_{i,0,k+1}(t) - 6 u_{i,0,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,J,k}(t) &= \\frac{2 u_{i,J-1,k}(t) + u_{i-1,J,k}(t) + u_{i+1,J,k}(t) + u_{i,J,k-1}(t) + u_{i,J,k+1}(t) - 6 u_{i,J,k}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,j,0}(t) &= \\frac{2 u_{i,j,1}(t) + u_{i-1,j,0}(t) + u_{i+1,j,0}(t) + u_{i,j-1,0}(t) + u_{i,j+1,0}(t) - 6 u_{i,j,0}(t)}{2 \\Delta x^2} \\\\\n\\nabla^2 u_{i,j,K}(t) &= \\frac{2 u_{i,j,K-1}(t) + u_{i,j-1,K}(t) + u_{i,j+1,K}(t) + u_{i,j,K}(t) + u_{i,j,k+1}(t) - 6 u_{i,j,K}(t)}{2 \\Delta x^2} \\\\\n\\end{align*}\\]\n\n\nHeat equation on a boundary edge\nSo if we are considering the \\(x=0, i=0\\), \\(y=0, j=0\\) edge: \\[\n\\frac{du_{0,0,k}(t)}{\\partial t} = \\alpha \\nabla^2 u_{0,0,k}(t) + f_{0,0,k}(t) + \\frac{h}{c\\rho}(T_{\\text{air}}-u_{0,0,k})\n\\] where\n\\[\\begin{align*}\n\\nabla^2 u_{0,0,k}(t) &= \\frac{1}{\\Delta x\\Delta y\\Delta z} \\left(\\frac{\\Delta y}{2} \\Delta z\n                        \\frac{u_{1,0,k}(t) - u_{0,0,k}(t)}{\\Delta x} \\right. \\\\\n            &\\qquad + \\frac{\\Delta x}{2} \\Delta z \\frac{u_{0,1,k}(t) - u_{0,0,k}(t)}{\\Delta y} \\\\\n            &\\qquad \\left. + \\frac{\\Delta x}{2} \\frac{\\Delta y}{2} \\frac{u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 2 u_{0,0,k}(t)}{\\Delta z}\\right) \\\\\n\\end{align*}\\]\nThis simplifies to:\n\\[\\begin{align*}\n  \\nabla^2 u_{0,0,k}(t) &= \\frac{1}{4} \\left(\\frac{2u_{1,0,k}(t) - 2u_{0,0,k}(t)}{\\Delta x^2} \\right. \\\\\n            &\\qquad + \\frac{2u_{0,1,k}(t) - 2u_{0,0,k}(t)}{\\Delta y^2} \\\\\n            &\\qquad \\left. + \\frac{u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 2 u_{0,0,k}(t)}{\\Delta z^2}\\right) \\\\\n\\end{align*}\\]\nAgain, with a uniform grid, this becomes: \\[\n\\nabla^2 u_{0,0,k}(t) = \\frac{2 u_{1,0,k}(t) +  2 u_{0,1,k}(t) + u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 6 u_{0,0,k}(t)}{4 \\Delta x^2}\n\\]\nFollowing a similar method we can find for all 12 edges:\n\\[\\begin{align*}\n    \\nabla^2 u_{0,0,k}(t) &= \\frac{2 u_{1,0,k}(t) +  2 u_{0,1,k}(t) + u_{0,0,k-1}(t) + u_{0,0,k+1}(t) - 6 u_{0,0,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,J,k}(t) &= \\frac{2 u_{1,J,k}(t) +  2 u_{0,J-1,k}(t) + u_{0,J,k-1}(t) + u_{0,J,k+1}(t) - 6 u_{0,J,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,j,0}(t) &= \\frac{2 u_{1,j,0}(t) +  2 u_{0,j,1}(t) + u_{0,j-1,0}(t) + u_{0,j+1,0}(t) - 6 u_{0,j,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,j,K}(t) &= \\frac{2 u_{1,j,K}(t) +  2 u_{0,j,K-1}(t) + u_{0,j-1,K}(t) + u_{0,j+1,0}(t) - 6 u_{0,j,K}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,0,k}(t) &= \\frac{2 u_{I-1,0,k}(t) +  2 u_{I,1,k}(t) + u_{I,0,k-1}(t) + u_{I,0,k+1}(t) - 6 u_{I,0,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,J,k}(t) &= \\frac{2 u_{I-1,J,k}(t) +  2 u_{I,J-1,k}(t) + u_{I,J,k-1}(t) + u_{I,J,k+1}(t) - 6 u_{I,J,k}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,j,0}(t) &= \\frac{2 u_{I-1,j,0}(t) +  2 u_{I,j,1}(t) + u_{I,j-1,0}(t) + u_{I,j+1,0}(t) - 6 u_{I,j,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,j,K}(t) &= \\frac{2 u_{I-1,j,K}(t) +  2 u_{I,j,K-1}(t) + u_{I,j-1,K}(t) + u_{I,j+1,K}(t) - 6 u_{I,j,K}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,0,0}(t) &= \\frac{2 u_{i,0,1}(t) +  2 u_{i,1,0}(t) + u_{i-1,0,0}(t) + u_{i+1,0,0}(t) - 6 u_{i,0,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,0,K}(t) &= \\frac{2 u_{i,0,K-1}(t) +  2 u_{i,1,K}(t) + u_{i-1,0,K}(t) + u_{i+1,0,K}(t) - 6 u_{i,0,K}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,J,0}(t) &= \\frac{2 u_{i,J,1}(t) +  2 u_{i,J-1,0}(t) + u_{i-1,J,0}(t) + u_{i+1,J,0}(t) - 6 u_{i,J,0}(t)}{4 \\Delta x^2} \\\\\n    \\nabla^2 u_{i,J,K}(t) &= \\frac{2 u_{i,J,K-1}(t) +  2 u_{i,J-1,K}(t) + u_{i-1,J,K}(t) + u_{i+1,J,K}(t) - 6 u_{i,J,K}(t)}{4 \\Delta x^2} \\\\\n\\end{align*}\\]\n\n\nHeat equation on a boundary corner\nSo if we are considering the \\(x=0, i=0\\), \\(y=0, j=0\\), \\(z=0, k=0\\) corner: \\[\n\\frac{du_{0,0,0}(t)}{\\partial t} = \\alpha \\nabla^2 u_{0,0,0}(t) + f_{0,0,0}(t) + \\frac{h}{c\\rho}(T_{\\text{air}}-u_{0,0,0})\n\\] where\n\\[\\begin{align*}\n  \\nabla^2 u_{0,0,0}(t) &= \\frac{1}{\\Delta x\\Delta y\\Delta z} \\left(\\frac{\\Delta y}{2} \\frac{\\Delta z}{2} \\frac{u_{1,0,0}(t) - u_{0,0,0}(t)}{\\Delta x} \\right.\\\\\n                        &\\qquad + \\frac{\\Delta x}{2} \\frac{\\Delta z}{2} \\frac{u_{0,1,0}(t) - u_{0,0,0}(t)}{\\Delta y} \\\\\n                        &\\qquad \\left. + \\frac{\\Delta x}{2} \\frac{\\Delta y}{2} \\frac{u_{0,0,1}(t) - 2 u_{0,0,0}(t)}{\\Delta z}\\right) \\\\\n\\end{align*}\\]\nThis simplifies to:\n\\[\n  \\nabla^2 u_{0,0,0}(t) = \\frac{1}{4} \\left(\\frac{u_{1,0,0}(t) - u_{0,0,0}(t)}{\\Delta x^2}\n            + \\frac{u_{0,1,0}(t) - u_{0,0,0}(t)}{\\Delta y^2}\n            + \\frac{u_{0,0,1}(t) - u_{0,0,0}(t)}{\\Delta z^2}\\right)\n\\]\nAgain, with a uniform grid, this becomes: \\[\n\\nabla^2 u_{0,0,0}(t) = \\frac{u_{1,0,0}(t) +  u_{0,1,0}(t) + u_{0,0,1}(t) - 3 u_{0,0,0}(t)}{2 \\Delta x^2}\n\\]\nFollowing a similar method we can find for all 8 corners:\n\\[\\begin{align*}\n    \\nabla^2 u_{0,0,0}(t) &= \\frac{u_{1,0,0}(t) +  u_{0,1,0}(t) + u_{0,0,1}(t) - 3 u_{0,0,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,0,0}(t) &= \\frac{u_{I-1,0,0}(t) +  u_{I,1,0}(t) + u_{I,0,1}(t) - 3 u_{I,0,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,J,0}(t) &= \\frac{u_{1,J,0}(t) +  u_{0,J-1,0}(t) + u_{0,J,1}(t) - 3 u_{0,J,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,0,K}(t) &= \\frac{u_{1,0,K}(t) +  u_{0,1,K}(t) + u_{0,0,K-1}(t) - 3 u_{0,0,K}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,J,0}(t) &= \\frac{u_{I-1,J,0}(t) +  u_{I,J-1,0}(t) + u_{I,J,1}(t) - 3 u_{I,J,0}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,0,K}(t) &= \\frac{u_{I-1,0,K}(t) +  u_{I,1,K}(t) + u_{I,0,K-1}(t) - 3 u_{I,0,K}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{0,J,K}(t) &= \\frac{u_{1,J,K}(t) +  u_{0,J-1,K}(t) + u_{0,J,K-1}(t) - 3 u_{0,J,K}(t)}{2 \\Delta x^2} \\\\\n    \\nabla^2 u_{I,J,K}(t) &= \\frac{u_{I-1,J,K}(t) +  u_{I,J-1,K}(t) + u_{I,J,K-1}(t) - 3 u_{I,J,K}(t)}{2 \\Delta x^2} \\\\\n\\end{align*}\\]\nThese are all coded into the function below.\n\n\nCode\ndef lap3DFE(umat,dx):\n    lap = np.empty_like(umat)\n\n    # Interior elements:\n    lap[1:-1,1:-1,1:-1] = (umat[:-2, 1:-1, 1:-1] + umat[2:, 1:-1, 1:-1] + umat[1:-1, :-2, 1:-1] + \n                           umat[1:-1, 2:, 1:-1] + umat[1:-1,1:-1,:-2] + umat[1:-1,1:-1,2:] - 6*umat[1:-1,1:-1,1:-1]) / dx**2\n\n    # Surface elements:\n    lap[0,1:-1,1:-1] = (2*umat[1, 1:-1, 1:-1] + umat[0, :-2, 1:-1] + umat[0, 2:, 1:-1] + umat[0, 1:-1, :-2] + umat[0, 1:-1, 2:] - \n        6*umat[0, 1:-1, 1:-1]) / (2*dx**2)\n    lap[-1,1:-1,1:-1] = (2* umat[-2, 1:-1, 1:-1] + umat[-1, :-2, 1:-1] + umat[-1, 2:, 1:-1] + umat[-1, 1:-1, :-2] + umat[-1, 1:-1, 2:] -\n        6*umat[-1, 1:-1, 1:-1]) / (2*dx**2)\n    lap[1:-1,0,1:-1] = (2* umat[1:-1, 1, 1:-1] + umat[:-2, 0, 1:-1] + umat[2:, 0, 1:-1] + umat[1:-1, 0, :-2] + umat[1:-1, 0, 2:] - \n        6*umat[1:-1, 0, 1:-1]) / (2*dx**2)\n    lap[1:-1,-1,1:-1] = (2* umat[1:-1, -2, 1:-1] + umat[:-2, -1, 1:-1] + umat[2:, -1, 1:-1] + umat[1:-1, -1, :-2] + umat[1:-1, -1, 2:] - \n        6*umat[1:-1, -1, 1:-1]) / (2*dx**2)\n    lap[1:-1,1:-1,0] = (2* umat[1:-1, 1:-1, 1] + umat[:-2, 1:-1, 0] + umat[2:, 1:-1, 0] + umat[1:-1, :-2, 0] + umat[1:-1, 2:, 0] - \n        6*umat[1:-1, 1:-1, 0]) / (2*dx**2)\n    lap[1:-1,1:-1,-1] = (2* umat[1:-1, 1:-1, -2] + umat[:-2, 1:-1, -1] + umat[2:, 1:-1, -1] + umat[1:-1, :-2, -1] + umat[1:-1, 2:, -1] - \n        6*umat[1:-1, 1:-1, -1]) / (2*dx**2)\n\n    # Edge Elements:\n    lap[0,0,1:-1] = (2 * umat[1, 0, 1:-1] + 2 * umat[0, 1, 1:-1] + umat[0, 0, :-2] + umat[0, 0, 2:] - 6*umat[0, 0, 1:-1]) / (4*dx**2)\n    lap[0,-1,1:-1] = (2 * umat[1, -1, 1:-1] + 2 * umat[0, -2, 1:-1] + umat[0, -1, :-2] + umat[0, -1, 2:] - 6*umat[0, -1, 1:-1]) / (4*dx**2)\n    lap[-1,0,1:-1] = (2 * umat[-2, 0, 1:-1] + 2 * umat[-1, 1, 1:-1] + umat[-1, 0, :-2] + umat[-1, 0, 2:] - 6*umat[-1, 0, 1:-1]) / (4*dx**2)\n    lap[-1,-1,1:-1] = (2 * umat[-2, -1, 1:-1] + 2 * umat[-1, -2, 1:-1] + umat[-1, -1, :-2] + umat[-1, -1, 2:] - 6*umat[-1, -1, 1:-1]) / (4*dx**2)\n    lap[0,1:-1,0] = (2 * umat[1, 1:-1, 0] + 2 * umat[0, 1:-1, 1] + umat[0, 2:, 0] + umat[0, :-2, 0] - 6*umat[0, 1:-1, 0]) / (4*dx**2)\n    lap[0,1:-1,-1] = (2 * umat[1, 1:-1, -1] + 2 * umat[0, 1:-1, -2] + umat[0, 2:, -1] + umat[0, :-2, -1] - 6*umat[0, 1:-1, -1]) / (4*dx**2)\n    lap[-1,1:-1,0] = (2 * umat[-2, 1:-1, 0] + 2 * umat[-1, 1:-1, 1] + umat[-1, 2:, 0] + umat[-1, :-2, 0] - 6*umat[-1, 1:-1, 0]) / (4*dx**2)\n    lap[-1,1:-1,-1] = (2 * umat[-2, 1:-1, -1] + 2 * umat[-1, 1:-1, -2] + umat[-1, 2:, -1] + umat[-1, :-2, -1] - 6*umat[-1, 1:-1, -1]) / (4*dx**2)\n    lap[1:-1,0,0] = (2 * umat[1:-1, 1, 0] + 2 * umat[1:-1, 0, 1] + umat[:-2, 0, 0] + umat[2:, 0, 0] - 6*umat[1:-1, 0, 0]) / (4*dx**2)\n    lap[1:-1,0,-1] = (2 * umat[1:-1, 1, -1] + 2 * umat[1:-1, 0, -2] + umat[:-2, 0, -1] + umat[2:, 0, -1] - 6*umat[1:-1, 0, -1]) / (4*dx**2)\n    lap[1:-1,-1,0] = (2 * umat[1:-1, -2, 0] + 2 * umat[1:-1, -1, 1] + umat[:-2, -1, 0] + umat[2:, -1, 0] - 6*umat[1:-1, -1, 0]) / (4*dx**2)\n    lap[1:-1,-1,-1] = (2 * umat[1:-1, 2, -1] + 2 * umat[1:-1, -1, -2] + umat[:-2, -1, -1] + umat[2:, -1, -1] - 6*umat[1:-1, -1, -1]) / (4*dx**2)    \n    \n    # Corner Elements:\n    lap[0,0,0] = (umat[1, 0, 0] + umat[0, 1, 0] + umat[0, 0, 1] - 3*umat[0, 0, 0]) / (2*dx**2)\n    lap[-1,0,0] = (umat[-2, 0, 0] + umat[-1, 1, 0] + umat[-1, 0, 1] - 3*umat[-1, 0, 0]) / (2*dx**2)\n    lap[0,-1,0] = (umat[1, -1, 0] + umat[0, -2, 0] + umat[0, -1, 1] - 3*umat[0, -1, 0]) / (2*dx**2)\n    lap[0,0,-1] = (umat[1, 0, -1] + umat[0, 1, -1] + umat[0, 0, -2] - 3*umat[0, 0, -1]) / (2*dx**2)\n    lap[0,-1,-1] = (umat[1, -1, -1] + umat[0, -2, -1] + umat[0, -1, -2] - 3*umat[0, -1, -1]) / (2*dx**2)\n    lap[-1,0,-1] = (umat[-2, 0, -1] + umat[-1, 1, -1] + umat[-1, 0, -2] - 3*umat[-1, 0, -1]) / (2*dx**2)\n    lap[-1,-1,0] = (umat[2, -1, 0] + umat[-1, -2, 0] + umat[-1, -1, 1] - 3*umat[-1, -1, 0]) / (2*dx**2)\n    lap[-1,-1,-1] = (umat[-2, -1, -1] + umat[-1, -2, -1] + umat[-1, -1, -2] - 3*umat[-1, -1, -1]) / (2*dx**2)\n\n    return lap\n\n\n\n\n\nFinal Heat equation function\n\ndef dudt(t,u, alpha, intensity, dx, Tair, A, B):\n    dudt = alpha*lap3DFE(u,dx) + powerGen(u, t, intensity, A) + bdryConv(u, t, Tair, B)\n    return dudt\n\nI will have to flatten things as solve_ivp only solves a vector system of differential equations rather than the higher dimenionality matrix system that I’ve created.\n\ndef dudtFlat(t,uflat, alpha, intensity, dx, Tair, A, B):\n    u = uflat.reshape(xmax,ymax,zmax)\n    return dudt(t,u, alpha, intensity, dx, Tair, A, B).flatten()"
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#analysis-plan",
    "href": "posts/heatEqn2/heatEqn2.html#analysis-plan",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Analysis plan",
    "text": "Analysis plan\nI will begin by choosing parameters \\(A\\) and \\(B\\) based on an initial guess, and then I will adjust those parameters to minimize the absolute difference between the result that I obtain and the target temperatures noted in these statements\n\nWhen it’s 22 degrees Celsius outside, the temperature inside your car can heat up to 47 degrees Celsius within an hour.\nWhen it’s 27 degrees Celsius outside, the temperature inside your car can heat up to 37 degrees Celsius within 10 minutes.\n\n\nCalculation 1:\nFor parameters \\(A\\) and \\(B\\) (described above) find the difference between the average box temperature after an hour and 47 deg C, assuming an air temperature of 22 deg C.\n\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\ndef calc1(A,B):\n    oneHour = 3600\n    airTemp = 22\n    hotCarTemp = 47\n    u0.fill(airTemp)\n    time = np.arange(0,oneHour,10)\n    \n    oneHourCalc = solve_ivp(dudtFlat, t_span=[0,oneHour], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(oneHourCalc.y,axis=0)\n\n    finalAvgTemp = avgBoxTempCalc[-1]\n    tempDiff = finalAvgTemp - hotCarTemp\n\n    return tempDiff\n\n\n\nCalculation 2:\nFor parameters \\(A\\) and \\(B\\) (described above) find the difference between the average box temperature after 10 minutes and 37 deg C, assuming an air temperature of 27 deg C.\n\ndef calc2(A,B):\n    tenMin = 60*10\n    airTemp = 27\n    hotCarTemp = 37\n    u0.fill(airTemp)\n    time = np.arange(0,tenMin,10)\n    \n    tenMinCalc = solve_ivp(dudtFlat, t_span=[0,tenMin], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(tenMinCalc.y,axis=0)\n\n    finalAvgTemp = avgBoxTempCalc[-1]\n    tempDiff = finalAvgTemp - hotCarTemp\n\n    return tempDiff\n\n\n\nOptimization\nNow I will find the parameters \\(A\\) and \\(B\\) that correctly model the statements given in the opening section of this post.\n\nfrom scipy.optimize import minimize\nfrom scipy.optimize import Bounds\n\nbounds = ((0, None), (0, None))\n\ndef totalTempDiff(x):\n    A, B = x\n    diff1 = np.abs(calc1(A,B))\n    diff2 = np.abs(calc2(A,B))\n    diff = diff1+diff2\n    return diff\n\nestA = 1/(specificHeat*wallDensity*(Deltax/10))\nestB = heatTransferCoef/(specificHeat*wallDensity*(Deltax/1000))\nx0 = np.array([estA,estB])\n\nres = minimize(totalTempDiff,x0,bounds=bounds)\n\nA,B = res.x\ndiff1 = np.abs(calc1(A,B))\ndiff2 = np.abs(calc2(A,B))\n\nprint(f'The temperature differences are {diff1:.3f} deg C for calculation 1 and {diff2:.3f} deg C for calculation 2')\n\nThe temperature differences are 0.000 deg C for calculation 1 and 0.030 deg C for calculation 2\n\n\nSince we can interpret the parameters \\(A\\) and \\(B\\) through the properties of materials, as described above, we find:\n\nprint(f'A = {res.x[0]:2e} m^2K/Ws and B= {res.x[1]:2e} 1/s')\n\nD = 1/(specificHeat*wallDensity*res.x[0])\nDelta = heatTransferCoef/(specificHeat*wallDensity*res.x[1])\nprint(f'δ = {D:.5f} m and Δ = {Delta:.5f} m.')\n\nA = 1.117617e-03 m^2K/Ws and B= 6.666691e-03 1/s\nδ = 0.00030 m and Δ = 0.00005 m.\n\n\n\n\nPlot the time evolution of the temperature\nFinally, I’ll plot the time evolution of the average temperature for these systems.\n\n\nCode\ndef plot1(A,B):\n    oneHour = 3600\n    airTemp = 22\n    hotCarTemp = 47\n    u0.fill(airTemp)\n    time = np.arange(0,oneHour,10)\n    \n    oneHourCalc = solve_ivp(dudtFlat, t_span=[0,oneHour], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(oneHourCalc.y,axis=0)\n\n    plt.plot(time,avgBoxTempCalc,label='Avg Car Temp')\n    plt.axhline(y=airTemp,label='Air Temp',ls='--',color='green')\n    plt.axhline(y=hotCarTemp,label='Danger Temp',ls='--',color='red')\n    plt.title(f'Average car temperature when air temp is {airTemp:.0f} C.') \n    plt.xlabel('Time (s)')\n    plt.ylabel('Temperature (C)')\n    plt.legend()\n    plt.show()\n\ndef plot2(A,B):\n    tenMin = 60*10\n    airTemp = 27\n    hotCarTemp = 37\n    u0.fill(airTemp)\n    time = np.arange(0,tenMin,10)\n    \n    tenMinCalc = solve_ivp(dudtFlat, t_span=[0,tenMin], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    \n    avgBoxTempCalc = np.mean(tenMinCalc.y,axis=0)\n\n    plt.plot(time,avgBoxTempCalc,label='Avg Car Temp')\n    plt.axhline(y=airTemp,label='Air Temp',ls='--',color='green')\n    plt.axhline(y=hotCarTemp,label='Danger Temp',ls='--',color='red')\n    plt.title(f'Average car temperature when air temp is {airTemp:.0f} C.') \n    plt.xlabel('Time (s)')\n    plt.ylabel('Temperature (C)')\n    plt.legend()\n    plt.show()\n\nA,B = res.x\nplot1(A,B)\nplot2(A,B)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis makes sense. In both systems the rate of heating decreases with time, suggesting that there is an upper limit to the temperature that the box will approach. Note that we need to put the ratio of the area of the top surface to the total surface area of the box in front of the solar generation term as the box is only gaining area through the top surface in this model, while convection is occurring everywhere on the surface of the box.\n\\[\n\\frac{du}{dt} = \\alpha\\nabla^2u + AI_s + B(T_{\\text{air}}-u) \\longrightarrow 0 = 0 + \\frac{A_{\\text{top}}}{A_{\\text{box}}} AI_s + B(T_{\\text{air}}-u_0)\n\\] Solving for the equilibrium temperature, we find: \\[\n\\implies u_0 = T_{\\text{air}} + \\left(\\frac{A_{\\text{top}}}{A_{\\text{box}}}\\right) \\frac{AI_s}{B}\n\\]\nGiven the system that I’m modeling, and values for \\(A\\) and \\(B\\) that I have found, we can calculate the difference between air temperature and the steady-state box temperature.\n\ntopArea = L*W\nboxArea = 2*(L*W + L*H + W*H)\nsolarBoost = A * solarIntensity/B * topArea/boxArea\nprint(f'The temperature after a long time should approach a value that is {solarBoost:.2f} deg C warmer than the air temperature.')\n\nThe temperature after a long time should approach a value that is 37.25 deg C warmer than the air temperature.\n\n\nLet’s verify this calculation by simulating this system for 10 hours.\n\ndef simSystem(A,B):\n    oneHour = 3600\n    airTemp = 27\n    eqTemp = airTemp + A*solarIntensity/B * L*W/(2*(L*W + L*H + W*H))\n    u0.fill(airTemp)\n    time = np.arange(0,10*oneHour,100)\n    \n    oneHourCalc = solve_ivp(dudtFlat, t_span=[0,10*oneHour], y0=u0.flatten(), t_eval= time, \n                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n    return oneHourCalc\n\nlongCalc = simSystem(A,B)    \n\nAnd then I will plot the average temperature as a function of time, as well as the average temperature at a range of heights.\n\ndef plotTemperature(uflat):\n    oneHour = 3600\n    airTemp = 27\n    eqTemp = airTemp + A*solarIntensity/B * L*W/(2*(L*W + L*H + W*H))\n    time = np.arange(0,10*oneHour,100)\n    avgBoxTempCalc = np.mean(uflat,axis=0)\n    avgBoxTempZ = np.empty((len(time),zmax))\n    \n    for l in range(len(time)):\n      umat = uflat[:, l].reshape((xmax,ymax,zmax))\n      for k in range(zmax):\n        avgBoxTempZ[l,k] = np.mean(umat[:,:,k])\n      \n\n    plt.plot(time,avgBoxTempCalc,label='Avg Car Temp')\n    for k in reversed(range(0, zmax, 5)):\n      zdim = k * Deltax\n      labText = f'z = {zdim:.3f} m'\n      plt.plot(time, avgBoxTempZ[:,k],label=labText,ls='dotted')\n    plt.axhline(y=airTemp,label='Air Temp',ls='--',color='green')\n    plt.axhline(y=eqTemp,label='Equilibrium Temp',ls='--',color='red')\n    plt.title(f'Average car temperature when air temp is {airTemp:.0f} C.') \n    plt.xlabel('Time (s)')\n    plt.ylabel('Temperature (C)')\n    plt.legend(bbox_to_anchor=(1.05,0.75))\n    plt.show()\n    \nplotTemperature(longCalc.y)\n\n\n\n\n\n\n\n\nAs we see that the temperature is not uniform at every point in the hot box, it becomes clear that assumption of uniform temperature is not appropriate. Since we see there is still a temperature gradient along the z-direction, conduction is still important in this system, and contributes to the equilibrium. Still this rough approximation gave a good intuition about the dynamics of the system even if it wasn’t numerically accurate.\nNote, this assumes that the sun stays at “high noon” for at least 10 hours, so it isn’t representative of a real car on the surface of the earth. As such, it’s not worth exploring this further, except for the purposes of developing better visualizations."
  },
  {
    "objectID": "posts/heatEqn2/heatEqn2.html#coming-soon",
    "href": "posts/heatEqn2/heatEqn2.html#coming-soon",
    "title": "Modeling Heat Flow - Part 2",
    "section": "Coming soon",
    "text": "Coming soon\nSo far, this has been lots of equations, and not enough pictures. But this is a complex system, and I need to add one feature at a time to ensure that it is working correctly. My first order of business will be to make a surface heat map of what is going on so that it is easier to talk about and show everyone what is going on.\nI also need to develop code which allows for the sun to change it’s position. And I’ll deal with other issues such as seasonal changes/the varying length of day/night. As well as deal with latitude. I’ve been fiddling with the math on the back of napkins, and that should work nicely with some pretty pictures. Then we can compare hot boxes in higher latitudes to those with lower latitudes."
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html",
    "href": "posts/summerMovies/summerMovies.html",
    "title": "Summer Movies",
    "section": "",
    "text": "This week we’re exploring “summer” movies: movies with summer in their title!\nThe data this week comes from the Internet Movie Database.\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(showtext)\nlibrary(janitor)\nlibrary(ggdist)\nlibrary(ggrepel)\nlibrary(scales)\nlibrary(paletteer)\n\nload('summerMovie.RData')"
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html#popularity-of-movie-by-year",
    "href": "posts/summerMovies/summerMovies.html#popularity-of-movie-by-year",
    "title": "Summer Movies",
    "section": "Popularity of movie by year",
    "text": "Popularity of movie by year\nIn some sense how well-known or popular a movie is should depend on the year. I’m guessing that very old movies may not have as many votes in the IMDB system. This could also bias the ratings\n\nggplot(summer_movies, aes(x=year,y=num_votes)) +\n  geom_point(color=oneCol) + \n  labs(\n    x = \"Year movie released\",\n    y = \"Number of ratings\",\n    caption = caption_text\n  ) + theme_simple()\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nI can definitely see that there is a volume bias towards newer movies. Let’s explore if this shows up in the ratings.\n\nggplot(summer_movies, aes(x=num_votes, y=average_rating, color=year)) +\n  geom_point() + \n  scale_x_log10(breaks = trans_breaks(\"log10\", function(x) 10^x),\n                labels = trans_format(\"log10\", math_format(10^.x))) +\n  scale_y_continuous(limits = c(0,10)) + \n  scale_color_paletteer_c(col_pal_cont) +\n  labs(\n    x = \"Number of ratings\",\n    y = \"Average rating\",\n    color = \"Year\",\n    caption = caption_text\n  ) + theme_simple()\n\n\n\n\n\n\n\n\nI’d say that there are no truly universally bad summer movies (for example with everyone scoring it a 0 or 1 out of 10). Despite the recency bias in the rating volume, it would seem that movies can be rated poorly or highly regardless of the year the movie was released. It also seems like there is a “reversion to the mean” effect for movies that have more votes, although this could simply be the result of sparse data. By “reversion to the mean” I am referring to the vaguely triangular shape of the blob of points, suggesting that as a movie is rated more and more, the diversity of opinion forces the mean rating to tend away from extreme values."
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html#re-imagining-other-work",
    "href": "posts/summerMovies/summerMovies.html#re-imagining-other-work",
    "title": "Summer Movies",
    "section": "Re-imagining other work",
    "text": "Re-imagining other work\nAs I’m doing this a bit late in the game, I can take advantage of the work some others have done. I saw this plot, and thought it would be good to replicate here, with a subtle twist.\n\nRather than plotting mean values for each genre, I thought I’d make a box plot instead of plotting the average rating. So I will tidy up the data. Furthermore, since I’m creating a box plot, I’m going to remove genres with fewer than \\(N=5\\) ratings.\n\nglobalMedian = median(summer_movies$average_rating, na.rm = TRUE)\ngDat &lt;- summer_movies |&gt; separate_longer_delim(cols = genres, delim = \",\") |&gt;\n  group_by(genres) \n\nnewGenre &lt;-  gDat |&gt;\n  summarise(\n    count = n(),\n    rating = median(average_rating, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\ndata4plot = full_join(newGenre,gDat,by=\"genres\") |&gt;\n  mutate(\n      genre_count = str_glue(\"{genres} ({count})\"),\n      genre_count = fct_reorder(genre_count, rating, .desc = FALSE),\n      highlight = ifelse(rating &gt;= globalMedian, \"yes\",\"no\")\n      ) |&gt;\n  filter(count&gt;=5)\n\nAnd finally, the plot.\n\nggplot(data4plot, aes(x=average_rating, y=genre_count, fill=highlight)) +\n  geom_vline(\n    xintercept = globalMedian,\n    linewidth = .5,\n    color = 'gray'\n    ) +\n  geom_boxplot() +\n  labs(\n    x = \"Rating\",\n    y = \"Movie Genre (count)\",\n    caption = caption_text\n  ) +\n  scale_x_continuous(breaks = seq(2,10,by=1), limits=c(2,10)) +\n  scale_y_discrete() +\n  scale_fill_paletteer_d(col_pal_dis) +\n  coord_cartesian(clip='off') + theme_catY()"
  },
  {
    "objectID": "posts/summerMovies/summerMovies.html#final-notes",
    "href": "posts/summerMovies/summerMovies.html#final-notes",
    "title": "Summer Movies",
    "section": "Final notes",
    "text": "Final notes\nI just found out about #TidyTuesday, just this week, and I want to participate. So the purpose of this post is mostly to get a blog going, and I hope to update approximately monthly. Now that this post is written, we’ll see if I can get this onto Github Pages. 😄\n[Edit: Phew! That worked!]"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html",
    "href": "posts/heatEqn1/modelHeatFlow.html",
    "title": "Modeling Heat Flow",
    "section": "",
    "text": "I have a house, and I need to improve the heating/cooling in it. Essentially, the problem is that my house is a long and narrow, and the air return is not able to sufficiently draw the cold/hot air from rooms on the far side of the house. Essentially, the air return/exchange system is not sufficient. As a result, half of my house is really hot in the summer/extra chilly in the winter.\nThere is some ducting in place intended to aid circulation, but it is ineffective as it doesn’t draw any air from the hot/cold room, relying on diffusion only to drive circulation. Furthermore, it is located in a bedroom rather than the living room which is significantly larger, more distant from the return, and–as a result–has the largest temperature problem. I am planning on installing a duct fan, which will help solve this problem. But that leaves these questions:\n\nHow strong should my duct fan be?\nWill the existing return be enough to alleviate the problem by simply adding in a duct fan?\nIf the answer to the previous question is no, where should I put another vent to make the biggest impact?\n\nI figure I can use my physics brain, and a little code to analyze this problem. So I’m going to spend some time figuring out how to implement the heat equation with appropriate boundary conditions applying them to scenarios that are progressively more complex, until I feel that I can apply them to my own house."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#personal-motivation-for-this-post",
    "href": "posts/heatEqn1/modelHeatFlow.html#personal-motivation-for-this-post",
    "title": "Modeling Heat Flow",
    "section": "",
    "text": "I have a house, and I need to improve the heating/cooling in it. Essentially, the problem is that my house is a long and narrow, and the air return is not able to sufficiently draw the cold/hot air from rooms on the far side of the house. Essentially, the air return/exchange system is not sufficient. As a result, half of my house is really hot in the summer/extra chilly in the winter.\nThere is some ducting in place intended to aid circulation, but it is ineffective as it doesn’t draw any air from the hot/cold room, relying on diffusion only to drive circulation. Furthermore, it is located in a bedroom rather than the living room which is significantly larger, more distant from the return, and–as a result–has the largest temperature problem. I am planning on installing a duct fan, which will help solve this problem. But that leaves these questions:\n\nHow strong should my duct fan be?\nWill the existing return be enough to alleviate the problem by simply adding in a duct fan?\nIf the answer to the previous question is no, where should I put another vent to make the biggest impact?\n\nI figure I can use my physics brain, and a little code to analyze this problem. So I’m going to spend some time figuring out how to implement the heat equation with appropriate boundary conditions applying them to scenarios that are progressively more complex, until I feel that I can apply them to my own house."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#heat-equation",
    "href": "posts/heatEqn1/modelHeatFlow.html#heat-equation",
    "title": "Modeling Heat Flow",
    "section": "Heat Equation",
    "text": "Heat Equation\nAll of this starts by understanding heat flow. The heat equation is:\n\\[\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2u\n\\]\nwhere \\(u = u(x,y,z,t)\\) is a function describing the temperature at every point in space and time in the region of interest and \\(\\alpha\\) is the Thermal Diffusivity of the material (which can depend on position as well). There are many boundary conditions that can be applied, but I will apply Robin Conditions which generally apply to convection/conduction.\n\\[\nk \\left. \\frac{\\partial u}{\\partial n}\\right|_{S} = h \\left(u(S,t) - v(S, t)\\right)\n\\]\nHere \\(n\\) is the direction of the outward normal of the boundary surface, \\(S\\) indicates a spatial point on the boundary surface, \\(k\\) is the thermal conductivity, \\(h\\) is the heat transfer coefficient, and \\(v\\) is the temperature on the other side of the boundary. This is the “Newton’s law of cooling” that you may have heard about in an introductory calculus class, although, it is usually presented as:\n\\[\n\\frac{dT}{dt} = -a(T-T_0)\n\\] where \\(a\\) is some sort of constant, and \\(T_0\\) is the temperature of the surroundings. What this means is that the steady-state behavior of this system is that it tends towards the temperature of the surroundings. This has limitations which I will discuss later."
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#simple-system",
    "href": "posts/heatEqn1/modelHeatFlow.html#simple-system",
    "title": "Modeling Heat Flow",
    "section": "Simple system",
    "text": "Simple system\nAs a “simple” 3D system, I’ll model a “hot box” or “sweatbox” used by some for torture. This is not, nor should it be construed as an endorsement of torture. It’s just a simple box, and it gives me some intuitive knobs to use as I work this problem. Also, given the boundary condition that I previously mentioned, this means that the box can never be warmer than the surroundings. This isn’t fully realistic yet, as anyone who has seen a PSA about leaving kids/pets in a hot car even on a “cool” day. But there’s enough here to get me to start writing code.\n\nBox dimensions\nI will model this as a box with length \\(L\\), width \\(W\\), and height \\(H\\). I’ll orient my coordinate system so that the origin is in a lower corner and points \\((x,y,z)\\) in the region of interest are bounded by the following: \\(0\\leq x\\leq L\\), \\(0\\leq y \\leq W\\), and \\(0\\leq z \\leq H\\).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Length and time parameters (meters)\nL = 2\nW = 1\nH = 1\noneDay = 24*60*60 # seconds\nT = 10*oneDay # Let this run for several days\n\n\n\nThermal properties of the box\nI will assume that the box is uniform. That means no windows or ventilation. So \\(h\\) and \\(k\\) are constant and uniform on the boundary. According to Wikipedia, the thermal diffusivity of air is \\(1.9\\times 10^{-7}\\) m\\(^2\\)/s. According to this article by Jayamaha et.al., the heat transfer coefficient for walls varies from 6 to 10 \\(\\frac{\\text{W}}{\\text{m}^2 \\text{K}}\\). Looking at the greenspec.co.uk website it would seem that the thermal conductivity of most building materials is on the order of 0.02-0.04 \\(\\frac{\\text{W}}{\\text{m K}}\\).\n\n# Heat parameters\nalpha = 1.9e-7 # meters^2/s for air\nh = 10 # From Jayamaha\nk = 0.04 # From Greenspec\n\n\n\nModeling exterior temperature\nI’m going to assume the air temperature is time-dependent, and takes the form:\n\\[\nv^{\\text{air}}(t) = T_0 - \\Delta T \\cos\\left(\\Omega t\\right)\n\\]\nwhere \\(T_0\\) is the average temperature of the day, and \\(\\Delta T\\) represents the range of temperature. On the ground, I’ll assume the temperature is constant at \\(T_G\\). So \\(t=0\\) is sunrise. Making these parameters functions is overkill for now, but will be helpful as I get more complicated.\n\n# Temperature parameters\nT0 = 33\nDT = 6\nTG = 35\n\ndef vair(T0,DT,t):\n  Omega = 2*np.pi/oneDay\n  vair = T0 - DT * np.cos(Omega * t)\n  return vair\n\ndef vground(TG, t):\n  return TG"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#going-from-differential-equations-to-matrix-equations",
    "href": "posts/heatEqn1/modelHeatFlow.html#going-from-differential-equations-to-matrix-equations",
    "title": "Modeling Heat Flow",
    "section": "Going from differential equations to matrix equations",
    "text": "Going from differential equations to matrix equations\nThis is going to get a bit technical, and if you want to skip the details of the math behind the algorithm you can skip to the results in Section 5.\nEssentially, the basis for all numerical methods involving systems that evolve in space and time is to replace continuous space and time values with a discrete mesh of space and time values. For this system, we are looking for the temperature at every location in space and time. So we will do this on a reduced space/time grid. Instead of having a function of \\((x,y,z,t)\\) we will have a 4-dimensional matrix that I will denote as follows:\n\\[\nu(x,y,z,t) \\rightarrow u(x_i,y_j,z_k,t_l) = u^l_{ijk}\n\\]\nFor this I will define:\n\\[\n\\begin{align*}\nx_i &= i \\Delta x \\\\\ny_j &= j \\Delta y \\\\\nz_k &= k \\Delta z \\\\\nt_l &= l \\Delta t \\\\\n\\end{align*}\n\\]\nwhere \\(\\Delta x, \\Delta y, \\Delta z,\\) and \\(\\Delta t\\) are computational choices. Indeed, this freedom will allow me to choose \\(\\Delta x = \\Delta y = \\Delta z\\). I will choose \\(\\Delta x = 5\\) cm and \\(\\Delta t = 15\\) minutes. I’ll also define the max indices for this system, and also set up values for the grid. I will also set up the \\(u^l_{ijk}\\) grid, and fill it with a constant value. Actually, I will do this for two different initial temperatures. If my code is working correctly, the initial temperature of the box should not matter if we let the simulation run for long enough. Think about it this way: Imagine that you have two identical coolers, one filled with ice and the other empty. Now, let the coolers sit for a year in your yard. After that year, the coolers will no longer have a different temperature.\n\n# Computational parameters (time step and mesh size)\nDeltat = 60*15 # 15 minutes in seconds\nDeltax = 0.05  # 5 cm in meters\n\nxmax = int(L/Deltax)\nymax = int(W/Deltax)\nzmax = int(H/Deltax)\ntmax = int(T/Deltat)\n\nxmid = xmax // 2\nymid = ymax // 2\nzmid = zmax // 2\n\nt = np.linspace(0,T,tmax)\nxgrid = np.linspace(0,L,xmax+1)\nygrid = np.linspace(0,W,ymax+1)\nzgrid = np.linspace(0,H,zmax+1)\n\n# Initialize the array(s) with a few different initial temperatures.\nu = np.empty((tmax,xmax,ymax,zmax))\nuAlt = np.empty((tmax,xmax,ymax,zmax))\nu_init = T0-DT\nu.fill(u_init)\nuAlt_init = (T0+TG)/2\nuAlt.fill(uAlt_init)\n\n\nApplying the Finite difference method to the boundary condition\nThe boundary condition for conduction/convection states that the gradient of the temperature function at the boundary is proportional to the temperature difference across that boundary. For example on the surface where \\(x=0\\) (or \\(i=0\\)), the outward normal direction is in the \\(-x\\) direction: \\[\n\\left. k\\frac{\\partial u}{\\partial x}\\right|_{x=0} = h(u(x=0,y,z,t) - v(x=0,y,z,t))\n\\] I will apply the finite difference method to find the spatial derivatives. \\[\n\\begin{align*}\n\\frac{\\partial u}{\\partial x} &= \\frac{u^l_{i+1 jk}-u^l_{ijk}}{\\Delta x}   \\\\\n\\frac{\\partial u}{\\partial y} &= \\frac{u^l_{ij+1 k}-u^l_{ijk}}{\\Delta y}   \\\\\n\\frac{\\partial u}{\\partial z} &= \\frac{u^l_{ijk+1}-u^l_{ijk}}{\\Delta z}   \\\\\n\\end{align*}\n\\]\nTherefore, for \\(i=0\\) (the \\(x=0\\) boundary) we get: \\[\nu^l_{1jk} - u^l_{0jk} = \\frac{h\\Delta x}{k} \\left(u^l_{0jk} - v^l_{jk}\\right)\n\\] Solve for \\(u^l_{0jk}\\): \\[\nu^l_{0jk} = \\frac{u^l_{1jk} + \\beta v^l_{jk}}{1+\\beta}\n\\]\nwhere I have defined: \\[\n\\beta = \\frac{h \\Delta x}{k}\n\\] Note that if \\(\\beta = 0\\) boundary has an infinite thermal conductivity and \\(u^l_{0jk} = u^l_{1jk}\\) or \\(\\frac{\\partial u}{\\partial n} = 0\\). This is the Neumann Boundary Condition. If \\(\\beta\\rightarrow\\infty\\), we find \\(u^l_{0jk} = v^l_{jk}\\) and the temperature at the boundary is equal to the exterior temperature. This is the Dirichelet Boundary Condition.\nPlugging in some numbers, I’ll assume that the proportionality constant \\(\\beta\\) for heat exchange with the ground is 10 times larger than the same constant for heat exchange with the air.\nLet’s put this into code and apply the boundary condition to the initial array:\n\nbeta = h*Deltax/k\nbetaG = 5*beta\n\ndef applyBC(umat, tl):\n  t = tl*Deltat\n  umat[tl, 0, :, :] = (umat[tl, 1, :, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, xmax-1, :, :] = (umat[tl, xmax-2, :, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, :, 0, :] = (umat[tl, :, 1, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, :, ymax-1, :] = (umat[tl, :, ymax-2, :] + beta * vair(T0,DT,t))/(1+beta)\n  umat[tl, :, :, 0] = (umat[tl, :, :, 1] + betaG * vground(TG,t))/(1+betaG)\n  umat[tl, :, :, zmax-1] = (umat[tl, :, :, zmax-2] + beta * vair(T0,DT,t))/(1+beta)\n  \n  return umat\n## Apply BCs at t=0 to finish initializing array\nu = applyBC(u, 0)\nuAlt = applyBC(uAlt,0)\n\n\n\nApplying the finite difference method to the heat equation: \\(\\dot{u} = \\alpha\\nabla^2u\\)\nI will again apply the finite difference method to find the derivatives. The first derivative in time is: \\[\n\\frac{\\partial u}{\\partial t} = \\frac{u^{l+1}_{ijk} - u^{l}_{ijk}}{\\Delta t}\n\\]\nAnother aspect of this method is that the Laplacian at any point can be calculated through the average of the difference between the nearest neighbors of that point and the point itself: \\[\n\\nabla^2 u(x,y,z,t) = \\frac{u^l_{i+1 jk} + u^l_{i-1 jk} +\n    u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk}}{(\\Delta x)^2}\n\\]\nThe heat equation becomes: \\[\nu^{l+1}_{ijk} = u^l_{ijk} + \\frac{\\alpha \\Delta t}{\\Delta x^2}\n    \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n\\] Basically, this equation gives us a method for finding the temperature after a time step given the temperature at the previous time step. I will define the dimensionless constant \\(\\gamma\\) as follows:\n\\[\n\\gamma = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n\\]\nso we finally obtain: \\[\nu^{l+1}_{ijk} = u^l_{ijk} + \\gamma \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} +\n      u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n\\]\nNow I will convert this to code:\n\ngamma = alpha*Deltat/Deltax**2\ndef calcHeatEqn(umat):\n    tm, xm, ym, zm = umat.shape\n    # Apply BCs\n    umat = applyBC(umat, 0)\n    for l in range(0,tm-1):\n      for i in range(1, xm-1):\n        for j in range(1, ym-1):\n          for k in range(1, zm-1):\n            umat[l+1,i,j,k] = umat[l,i,j,k] + gamma * (umat[l,i+1,j,k] + \n                  umat[l,i-1,j,k] + umat[l,i,j+1,k] + umat[l,i,j-1,k] + \n                  umat[l,i,j,k+1] + umat[l,i,j,k-1] - 6 * umat[l,i,j,k])\n      umat = applyBC(umat, l+1)\n    return umat\n\n\n\nVisualizing the temperature:\nThe grid will probably be too fine to visualize well on a 3d heatmap. So I’ll settle for some cross sections. The function plotheatmaps will plot heat maps inside the box for a given time in 3 perpendicular planes.\n\n\nCode\ndef plotheatmaps(umat,l,i,j,k):\n  Tmin = np.min([u.min(),T0-DT])\n  Tmax = np.max([u.max(),T0+DT])\n  \n  xSlice = umat[l,i,:,:].transpose()\n  ySlice = umat[l,:,j,:].transpose()\n  zSlice = umat[l,:,:,k].transpose()\n  \n  time = Deltat*l\n  tMins = time // 60\n  theMinutes = tMins % 60\n  \n  tHours = tMins // 60\n  theDays = tHours // 24\n  theHours = tHours % 24\n  \n  theTime = str(theDays) + \" days \" + str(theHours) + \" hrs \"  + str(theMinutes) + \" min\"\n\n  xC, yC, zC = [Deltax*i, Deltax*j, Deltax*k]\n  \n  fig, (ax0,ax1,ax2) = plt.subplots(ncols=3,width_ratios=[ymax,xmax,xmax],\n              figsize=(8,3))\n    \n  fig.suptitle(f\"Heatbox Temp at {theTime} \\n Outdoor Temp = {vair(T0,DT,time):.2f} C \\n Ground Temp = {vground(TG,time):.0f} C\")\n    \n  im0 = ax0.pcolormesh(ygrid, zgrid, xSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax0.set_aspect(1)\n  ax0.set_title(f\"x = {xC:.3f} m\")\n  ax0.set_xlabel(\"y\")\n  ax0.set_ylabel(\"z\")\n\n  im1 = ax1.pcolormesh(xgrid, zgrid, ySlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax1.set_aspect(1)\n  ax1.set_title(f\"y = {yC:.3f} m\")\n  ax1.set_xlabel(\"x\")\n  ax1.set_ylabel(\"z\")\n  \n  im2 = ax2.pcolormesh(xgrid, ygrid, zSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n  ax2.set_aspect(1)\n  ax2.set_title(f\"z = {zC:.3f} m\")\n  ax2.set_xlabel(\"x\")\n  ax2.set_ylabel(\"y\")\n  \n  fig.tight_layout()\n  \n  cax = fig.add_axes([ax0.get_position().x0,ax0.get_position().y0-0.2,\n                ax2.get_position().x1 - ax0.get_position().x0, 0.02])\n  fig.colorbar(im2, cax = cax, orientation='horizontal')\n\n\nSo the initial condition has the following heatmap:\n\nplotheatmaps(u,0,xmid,ymid,zmid)\nplotheatmaps(uAlt,0,xmid,ymid,zmid)"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#sec-results",
    "href": "posts/heatEqn1/modelHeatFlow.html#sec-results",
    "title": "Modeling Heat Flow",
    "section": "Results",
    "text": "Results\nFinally, we will compute the time evolution of the temperature for the two scenarios.\n\nu = calcHeatEqn(u)\nuAlt = calcHeatEqn(uAlt)\n\n\nDifferent initial condition comparison\nI’m going to start by comparing the behavior of the system given different initial conditions for the starting temperature within the box. The hidden code below crunches the average temperatures for the plots in this and the following sections.\n\n\nCode\n## Calculate averages at every time step\nairTemp = np.zeros(tmax)\ngroundTemp = np.zeros(tmax)\nboxTemp = np.zeros(tmax)\nbtErr = np.zeros(tmax)\nboxTempAlt = np.zeros(tmax)\nbtaErr = np.zeros(tmax)\nboxTempZ = np.zeros((tmax,zmax))\nbtzErr = np.zeros((tmax,zmax))\nfor l in range(tmax):\n  airTemp[l] = vair(T0,DT,t[l])\n  groundTemp[l] = vground(TG,t[l])\n  ul = u[l, :, :, :]\n  ulAlt = uAlt[l, :, :, :]\n  boxTemp[l] = np.mean(ul)\n  boxTempAlt[l] = np.mean(ulAlt)\n  btErr[l] = np.std(ul)\n  btaErr[l] = np.std(ulAlt)\n  for k in range(zmax):\n    ulk = ul[:,:,k]\n    boxTempZ[l,k] = np.mean(ulk)\n    btzErr[l,k] = np.std(ulk)\n\n## Calcs for temp in the day\nstepsInDay = int(oneDay/Deltat)\ndays = int(T/oneDay)\nday = np.arange(0,days)\n\nboxTempDay = np.zeros(days)\nbtdErr = np.zeros(days)\nboxTempDayAlt = np.zeros(days)\nbtdaErr = np.zeros(days)\nboxTempDayZ = np.zeros((days,zmax))\nbtdzErr = np.zeros((days,zmax))\nfor d in range(days):\n    lmin = int(d*stepsInDay)\n    lmax = int((d+1)*stepsInDay)\n    ul = u[lmin:lmax, :, :, :]\n    boxTempDay[d] = np.mean(u[lmin:lmax, :, :, :])\n    boxTempDayAlt[d] = np.mean(uAlt[lmin:lmax, :, :, :])\n    btdErr[d] = np.std(u[lmin:lmax, :, :, :])\n    btdaErr[d] = np.std(uAlt[lmin:lmax, :, :, :])\n    for k in range(zmax):\n        boxTempDayZ[d,k] = np.mean(ul[:,:,:,k])\n        btdzErr[d,k] = np.std(ul[:,:,:,k])\n\n\nAs noted previously, after a long enough time, I expect two identical boxes to exhibit the same behavior regardless of their initial conditions–much in the way that the long-term behavior of a Damped-Driven Oscillator is independent of the initial conditions. Let’s check that out here:\n\nfig, (ax0, ax1) = plt.subplots(1,2,figsize=(8,4),sharey=True)\nax0.plot(t,boxTemp, '-', label=rf\"$T_i=${u_init:.0f}\")\nax0.plot(t,boxTempAlt, '--', label=rf\"$T_i=${uAlt_init:.0f}\")\nax0.set_xlabel('Time (s)')\nax0.set_ylabel('Temperature (deg C)')\nax0.legend()\n\nax1.plot(day,boxTempDay, 'o', label=rf\"$T_i=${u_init:.0f}\")\nax1.plot(day,boxTempDayAlt, 's', label=rf\"$T_i=${uAlt_init:.0f}\")\nax1.set_xlabel('Time (days)')\nax1.set_ylabel('Temperature (deg C)')\nax1.legend()\nplt.show()\n\n\n\n\n\n\n\n\nIt would seem that the 10 days that I have simulated is long enough for these systems to reach this “steady state” solution.\n\n\nCompare interior temperature to exterior temp\nI’m going to plot the external (air) temperature and compare it to the average temperature in the box, as well as consider the average temperature in horizontal slices as the change in time.\n\nplt.figure(figsize=(6.5,4))\nplt.plot(t,airTemp,label=\"Air Temp\",ls='dashed',linewidth=0.5)\nplt.errorbar(t,boxTemp,yerr=btErr, label=\"Avg. Box Temp\",linewidth=2, capsize=2, errorevery=24)\nplt.xlabel('Time (s)')\nplt.ylabel('Temperature (deg C)')\nfor k in reversed(range(0,zmax,zmax//5)):\n    zval = k*Deltax\n    labString = f\"Avg Temp at z={zval:.2f} m\"\n    plt.plot(t,boxTempZ[:,k],label=labString, linewidth=1)\n    \nplt.plot(t,groundTemp,label=\"Ground Temp\",ls=\"dashed\",linewidth=0.5)\nplt.legend(loc=\"center left\", bbox_to_anchor=(1.04,0.5))\nplt.show()\n\n\n\n\n\n\n\n\nJust to see that this is stabilizing, and to get an idea of how fast this stabilizes, I’m going to find a daily average temperature as above.\n\nplt.figure(figsize=(8,4))\nplt.errorbar(day,boxTempDay,yerr=btdErr, marker='o', label=\"Avg. Box Temp\",capsize=2,linewidth=2)\nplt.xlabel('Time (days)')\nplt.ylabel('Temperature (deg C)')\nfor k in reversed(range(0,zmax,zmax//5)):\n    zval = k*Deltax\n    labString = f\"Avg Temp at z={zval:.2f} m\"\n    plt.plot(day,boxTempDayZ[:,k], marker='o', label=labString) \n    \nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nHeatmaps\nLet’s view the middle cross sections every few hours on the last day:\n\nfor s in range(lmin,lmax,int(stepsInDay/12)):\n  plotheatmaps(u,s,xmid,ymid,zmid)"
  },
  {
    "objectID": "posts/heatEqn1/modelHeatFlow.html#summary",
    "href": "posts/heatEqn1/modelHeatFlow.html#summary",
    "title": "Modeling Heat Flow",
    "section": "Summary",
    "text": "Summary\nThis is working as a proof of concept. Job 1: Done. But there’s more to be done.\n\nNext step\nAs a torture device, this leaves much to be desired. Right now, it’s no more effective than a chain-link fence from a temperature perspective. I’ll be working on adding in solar radiation in the next post.\n\n\nMy future plans:\nAs I seek to make this model more complex. I plan to do things that will slowly make my boring box look more like a house. Things like:\n\nMaking the box house sized and adding an appropriate number of windows.\nAdd in interior walls.\nAdd in heating and cooling."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Steven Wolf - Data World",
    "section": "",
    "text": "A new project: Cross Country Data Viz\n\n\n\nCross Country Data\n\nR\n\nPython\n\n\n\nVisualizing Cross Country results.\n\n\n\n\n\nSep 3, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the Heat Equation to model a real-world system (Part 5)\n\n\n\nHeat Equation\n\nModeling\n\nBringing a nuke to a fist-fight\n\n3D Model\n\n\n\nBringing a nuke to a fist-fight\n\n\n\n\n\nJul 30, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the Heat Equation to model a real-world system (Part 4)\n\n\n\nHeat Equation\n\nModeling\n\nBringing a nuke to a fist-fight\n\n\n\nBringing a nuke to a fist-fight\n\n\n\n\n\nJul 24, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the Heat Equation to model a real-world system (Part 3)\n\n\n\nHeat Equation\n\nModeling\n\nBringing a nuke to a fist-fight\n\n\n\nBringing a nuke to a fist-fight\n\n\n\n\n\nJul 21, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the Heat Equation to model a real-world system (Part 2)\n\n\n\nHeat Equation\n\nModeling\n\nClassroom Models vs Realistic Models\n\n\n\nWhy is this so gosh-darn hard sometimes?\n\n\n\n\n\nJul 14, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the Heat Equation to model a real-world system (Part 1)\n\n\n\nHeat Equation\n\nModeling\n\nClassroom Models vs Realistic Models\n\nYapping\n\n\n\nWhy is this so gosh-darn hard sometimes?\n\n\n\n\n\nJul 13, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nPuck, meet stick\n\n\n\nPython\n\nModeling\n\nClasses\n\nMotion\n\nRotation\n\nManim\n\n\n\nA story involving getting Manim to work to produce a visualization of motion.\n\n\n\n\n\nApr 26, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nReady, Aim, Compute!\n\n\n\nPython\n\nModeling\n\nClasses\n\nMotion\n\n\n\nPhysics 1 physics vs. real world physics. Sorry, the world isn’t filled with spherical cows in a vacuum\n\n\n\n\n\nMar 6, 2025\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nModeling Heat Flow - Part 2b\n\n\n\nHeat Equation\n\nPython\n\nModeling\n\n3D system\n\nFinite Difference Method\n\nAnimating Plots\n\n\n\nVisualizing a (toy) hot box\n\n\n\n\n\nDec 10, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nModeling Heat Flow - Part 2\n\n\n\nHeat Equation\n\nPython\n\nModeling\n\n3D system\n\nFinite Difference Method\n\n\n\nTurning up the heat on the Heatbox\n\n\n\n\n\nDec 9, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nModeling Heat Flow\n\n\n\nHeat Equation\n\nPython\n\nModeling\n\n3D system\n\nFinite Difference Method\n\n\n\nTorture is bad. Also, half of my house gets too warm/cold, and that’s not my favorite.\n\n\n\n\n\nNov 3, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nStack Overflow Annual Developer Survey\n\n\n\nTidyTuesday\n\nR\n\n\n\nWhere are Stack Overflow users working from? Let’s find out.\n\n\n\n\n\nSep 5, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nEnglish Monarchy\n\n\n\nTidyTuesday\n\nR\n\n\n\n\n\n\n\n\n\nAug 20, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nWorld’s Fairs\n\n\n\nTidyTuesday\n\nR\n\nMaps\n\n\n\nI’ve always wanted to play with making a map-based visualization\n\n\n\n\n\nAug 14, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nScraping Weather Data-Proof of concept\n\n\n\nWeather\n\nPython\n\nWeb-scraping\n\n\n\nScraping weather data near Zebulon, NC\n\n\n\n\n\nAug 8, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nOlympic countries: Fun facts and visualizations\n\n\n\nTidyTuesday\n\nR\n\n\n\nCountries by participation and medal count\n\n\n\n\n\nAug 7, 2024\n\n\nSteven Wolf\n\n\n\n\n\n\n\n\n\n\n\n\nSummer Movies\n\n\n\nTidyTuesday\n\nR\n\n\n\nAnalyzing the IMDB for movies with ‘summer’ in the title\n\n\n\n\n\nAug 2, 2024\n\n\nSteven Wolf\n\n\n\n\n\nNo matching items"
  }
]