{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Puck, meet stick\"\n",
        "description: \"A story involving getting Manim to work to produce a visualization of motion.\"\n",
        "author: \"Steven Wolf\"\n",
        "date: \"4/26/2025\"\n",
        "number-sections: false\n",
        "categories:\n",
        "  - Python\n",
        "  - Modeling\n",
        "  - Classes\n",
        "  - Motion\n",
        "  - Rotation\n",
        "  - Manim\n",
        "execute: \n",
        "  messages: false\n",
        "  warning: false\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "# The end:\n",
        "\n",
        "I can make this pretty video using Manim!\n",
        "\n",
        "\n",
        "{{< video collisionViz/media/videos/puckStickCollision/1080p60/puckStickCollision.mp4 >}}\n",
        "\n",
        "\n",
        "\n",
        "# The beginning:\n",
        "\n",
        "I've been making some visualizations for my physics classes. I've used VPython/Glowscript in the past however, that wasn't working for me, and I couldn't track the bugs. I've been meaning to play with [Manim](https://www.manim.community/). So, I've done that!\n",
        "\n",
        "# The physics:\n",
        "## First, set up the problem\n",
        "For this calculation, I'll be working in the LAB frame (with the initial velocity, and initial angular velocity of the stick equal to zero).\n",
        "\n",
        "![](puckStickDemo.png)\n",
        "\n",
        "After the collision is complete, I will define:\n",
        "\n",
        "- $\\vec{v}_1 = (v_1, 0)$ is the velocity of the puck.  During the collision, we'll assume that the force that the stick exerts on the puck is purely horizontal. Therefore, the final velocity of the puck will be also in the $x-$direction.\n",
        "- $\\vec{v}_2 = (v_2, 0)$ is the velocity of the stick's *center of mass*.  During the collision, the puck's force on the stick is purely horizontal. Therefore, the final velocity of the stick's center of mass will be also in the $x-$direction.\n",
        "- $\\omega_2$ is the z-component of the angular velocity of the stick about it's center of mass.\n",
        "\n",
        "\n",
        "## Now, do the collision physics\n",
        "\n",
        "Conservation of momentum in the $x-$direction:\n",
        "\n",
        "$$\n",
        "m_1 u_1 = m_1 v_1 + m_2 v_2\n",
        "$$\n",
        "\n",
        "Conservation of angular momentum in the $z-$direction:\n",
        "$$\n",
        "m_1 u_1 b = m_1 v_1 b + I\\omega_2\n",
        "$$\n",
        "where $I$ is the moment of inertia of a stick with length $L$ about it's center of mass: $I = \\frac{1}{12}m_2 L^2$.\n",
        "\n",
        "### Coefficient of restitution\n",
        "The coefficient of restitution is generally defined as the \"bounciness\" of a collision. The coefficient of restitution has the following properties\n",
        "\n",
        "- $\\varepsilon = 1$ for *Elastic collisions*\n",
        "- $\\varepsilon < 1$ for *Inelastic collisions*\n",
        "- $\\varepsilon = 0$ for *Totally inelastic collisions* (This is when the objects stick together)\n",
        "\n",
        "The coefficient of restitution is defined as:\n",
        "$$\n",
        "\\varepsilon = \\frac{\\left|\\text{final relative velocity}\\right|}{\\left|\\text{initial relative velocity}\\right|} \n",
        "$$\n",
        "For collisions between point particles, we define:\n",
        "$$\n",
        "\\varepsilon = \\frac{\\left|\\vec{v}_2-\\vec{v}_1\\right|}{\\left|\\vec{u}_2-\\vec{u}_1\\right|} \n",
        "$$\n",
        "where $\\vec{u}_1, \\vec{u}_2$ are the initial velocities, and $\\vec{v}_1, \\vec{v}_2$ are the final velocities of the two objects.\n",
        "\n",
        "For extended systems, we need to calculate this using the relative velocities of the impact points. For this system, we can define:\n",
        "$$\n",
        "\\varepsilon = \\frac{\\left|v_2^* - v_1\\right|}{\\left|u_1\\right|}\n",
        "$$\n",
        "\n",
        "where, $v_2^* = v_2 + \\omega_2 b$ is the velocity of the impact point on the stick.  This is a common technique used in subsequent mechanics courses.  For this calculation, I will force $\\varepsilon \\neq 0$ because if the puck \"sticks\" to the stick like a totally inelastic collision, the motion after will be of a composite object, rather than a separate puck and stick.\n",
        "\n",
        "## Solve this system of equations\n",
        "The above 3 conditions provide us with 3 equations relating 3 unknowns $(v_1, v_2, \\omega_2)$ in terms of known quantities. I could try to solve these symbolically, but I really don't feel the need to do so. Rather I'll use a numerical technique using the python function `fsolve` in the `scipy` library. To accomplish this, I need to rearrange these equations so that they all equal zero:\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        "    0 &= m_1 v_1 + m_2 v_2 - m_1 u_1\\\\\n",
        "    0 &= m_1 v_1 b + I \\omega_2 - m_1 u_1 b\\\\\n",
        "    0 &= \\left|v_2 + b \\omega_2 - v_1\\right| - \\varepsilon\\left|u_1\\right|\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "# The code\n",
        "I put all of this together in the code [linked here](collisionViz/puckStickCollision.py) and reproduced below. In order for it to work, you'll need to have manim installed on your computer.\n"
      ],
      "id": "747e320f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "##################################################################\n",
        "##\n",
        "## puckStickCollision.py\n",
        "## Author: SF Wolf\n",
        "##\n",
        "## This script simulates a collision between a puck and a stick. \n",
        "## Initially the stick is still and the puck is moving towards \n",
        "## the stick perpendicular to its length.\n",
        "##################################################################\n",
        "\n",
        "from manim import *\n",
        "import numpy as np \n",
        "from scipy.optimize import fsolve\n",
        "\n",
        "def doCollision(params):\n",
        "  '''\n",
        "  This function does the physics for the 1D collision. It assumes normal incidence, \n",
        "  and that the stick is stationary in the reference frame initially. No unit system\n",
        "  is assumed in this calculation\n",
        "  \n",
        "  params = a vector containing\n",
        "    m1 - puck mass in desired mass unit\n",
        "    m2 - stick mass in desired mass unit\n",
        "    L - stick length in desired length unit\n",
        "    b - impact parameter of the collision in desired length unit\n",
        "    u1 - initial velocity of the stick (x-component) in desired speed unit\n",
        "    cor - coefficient of restitution (dimensionless)\n",
        "    rad - puck radius (for visualization purposes only) in desired length unit\n",
        "    thk - stick thickness (for visualization purposes only) in desired length unit\n",
        "  '''\n",
        "  # Parameters\n",
        "  m1, m2, L, b, u1, cor, rad, thk = params\n",
        "  I = 1/12 * m2 * L**2\n",
        "  v1eC = (m1-m2)/(m1+m2) * u1\n",
        "  v2eC = 2 * m1/(m1+m2) * u1\n",
        "  \n",
        "  def equations(vars):\n",
        "    v1, v2, omega2 = vars\n",
        "    eq1 = m1*v1 + m2*v2 - m1*u1\n",
        "    eq2 = m1*v1*b + I*omega2 - m1*u1*b\n",
        "    eq3 = np.abs(v2+b*omega2-v1) - cor*np.abs(u1)\n",
        "    return [eq1, eq2, eq3]\n",
        "\n",
        "  init_guess = [v1eC,v2eC,0]\n",
        "  \n",
        "  sol = fsolve(equations, init_guess)\n",
        "\n",
        "  return sol\n",
        "\n",
        "class Puck(Circle):\n",
        "  '''\n",
        "  Create a \"puck\" object with appropriate mass and radius.\n",
        "  '''\n",
        "  def __init__(self,mass,radius):\n",
        "    self.radius = radius\n",
        "    self.mass = mass\n",
        "    Circle.__init__(self, radius=self.radius,color=WHITE)\n",
        "    self.set_fill(color=WHITE, opacity=1)\n",
        "        \n",
        "class Stick(Rectangle):\n",
        "  '''\n",
        "  Create a \"stick\" object with appropriate mass, length, thickness and angle.\n",
        "  '''\n",
        "  def __init__(self,mass,length,thickness,angle):\n",
        "    self.mass = mass\n",
        "    self.length = length\n",
        "    self.thickness = thickness\n",
        "    self.angle = angle\n",
        "    Rectangle.__init__(self, height=self.length, width = self.thickness,color=BLUE)\n",
        "    self.rotate(self.angle, about_point=self.get_center())\n",
        "    self.set_fill(color=BLUE, opacity=1)\n",
        "    \n",
        "class puckStickCollision(Scene):\n",
        "  '''\n",
        "  Create the collision visualization\n",
        "  '''\n",
        "  def construct(self):\n",
        "    # Create axes and number plane for visualization purposes\n",
        "    ax = Axes(\n",
        "        tips=False,\n",
        "        axis_config={\"include_numbers\": False}\n",
        "    )\n",
        "    # The axes are used to place objects on the screen with standard 2D units\n",
        "    numPlane = NumberPlane(\n",
        "        background_line_style={\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_opacity\":0.2\n",
        "        }\n",
        "    )\n",
        "    # Only add the number plane so that I don't have to worry about  \n",
        "    # different scales between the axes and number plane\n",
        "    self.add(numPlane)\n",
        "    \n",
        "    ##########################################################\n",
        "    ## puck-stick properties for collision \n",
        "    ## ADJUST THESE TO CREATE DIFFERENT INITIAL CONDITIONS\n",
        "    m1 = 1\n",
        "    m2 = 2\n",
        "    u1 = 2\n",
        "    b = 2\n",
        "    L = 6\n",
        "    cor = 0.5\n",
        "    rad = 0.1\n",
        "    thk = 0.2\n",
        "    ##########################################################\n",
        "    params = m1, m2, L, b, u1, cor, rad, thk \n",
        "    ## calculate the final velocity for the collision\n",
        "    v1, v2, omega2 = doCollision(params)\n",
        "\n",
        "    ## Put objects on screen\n",
        "    puck = Puck(mass=m1,radius=rad)\n",
        "    puck.x, puck.y = [-4, -b] # Initial position\n",
        "    puck.vx, puck.vy = [u1, 0] # Initial velocity\n",
        "    puck.omega = 0 # Initial angular velocity\n",
        "    puck.shift(ax.coords_to_point(puck.x, puck.y)) # Place on screen\n",
        "    puck.coll = False # Indicator if collision has happened yet\n",
        "      \n",
        "    stick = Stick(mass=m2,length=L,thickness=thk,angle=0)\n",
        "    stick.x, stick.y = [0,0] # Initial position of stick CM\n",
        "    stick.vx, stick.vy = [0,0] # Initial velocity of stick CM\n",
        "    stick.omega = 0 # Initial angular velocity of stick around CM\n",
        "    stick.shift(ax.coords_to_point(stick.x, stick.y)) # Place on screen\n",
        "    stick.coll = False # Indicator if collision has happened yet\n",
        "\n",
        "    ## To help guide the eye, and answer questions about how the CM changes for \n",
        "    ## different collisions, I will also draw the center of mass\n",
        "    BRIGHTGREEN = ManimColor('#66FF00')\n",
        "    cm = Dot(color=BRIGHTGREEN,radius=0.04)\n",
        "    # Calculate the position and velocity\n",
        "    cm.x = (puck.mass * puck.x + stick.mass*stick.x)/(puck.mass+stick.mass)\n",
        "    cm.y = (puck.mass * puck.y + stick.mass*stick.y)/(puck.mass+stick.mass)\n",
        "    cm.vx = (puck.mass * puck.vx + stick.mass*stick.vx)/(puck.mass+stick.mass)\n",
        "    cm.vy = (puck.mass * puck.vy + stick.mass*stick.vy)/(puck.mass+stick.mass)\n",
        "    cm.omega = 0\n",
        "    cm.shift(ax.coords_to_point(cm.x, cm.y)) # Place on screen\n",
        "    cm.coll = False # Indicator if collision has happened yet\n",
        "\n",
        "    def update(mob,dt):\n",
        "      '''\n",
        "      Update the position of each mobject. Since there are no external forces or \n",
        "      torques, all motion is constant linear/angular velocity motion\n",
        "      '''\n",
        "      dx, dy = [mob.vx * dt, mob.vy*dt]\n",
        "      mob.shift(ax.coords_to_point(dx, dy))\n",
        "      mob.rotate(mob.omega*dt,about_point=mob.get_center())\n",
        "      ## Test to see if there is a collusion during the next time step\n",
        "      handle_collision(mob)\n",
        "\n",
        "    def handle_collision(mob):\n",
        "      '''\n",
        "      Since my doCollision function assumes the stick is at rest, I need to \n",
        "      only allow the collision to happen once\n",
        "      '''\n",
        "      if not mob.coll:  \n",
        "        # Calculate stick CM coords\n",
        "        x0, y0 = ax.point_to_coords(stick.get_center())\n",
        "        # and puck position\n",
        "        xp, yp = ax.point_to_coords(puck.get_center())\n",
        "        theta = stick.angle\n",
        "        # buffer is the minimum distance between puck and stick impact point\n",
        "        buffer = stick.thickness + puck.radius\n",
        "        \n",
        "        # Determine the position of the impact point on the stick relative to the CM\n",
        "        A = np.array([[1, np.tan(theta)],[np.tan(theta), -1]])\n",
        "        B = np.array([x0-y0*np.tan(theta), xp*np.tan(theta) - yp])\n",
        "        X, Y = np.linalg.solve(A,B)\n",
        "        # Calculate current distance between puck and impact point\n",
        "        dist = np.linalg.norm(np.array([X-xp, Y-yp]))\n",
        "        if dist <= buffer:\n",
        "          # Update the velocities\n",
        "          puck.vx = v1\n",
        "          stick.vx = v2\n",
        "          stick.omega = omega2\n",
        "          cm.vx = (puck.mass * puck.vx + stick.mass*stick.vx)/(puck.mass+stick.mass)\n",
        "          # Show that the collision has occured\n",
        "          puck.coll=True\n",
        "          stick.coll=True\n",
        "          cm.coll=True\n",
        "            \n",
        "    ## Add the update function to each mobject so that the position of these are updated.\n",
        "    puck.add_updater(update)\n",
        "    stick.add_updater(update)\n",
        "    cm.add_updater(update)\n",
        "\n",
        "    # Annotations for the video\n",
        "    corText = Tex(rf\"Coefficient of Restitution $\\varepsilon =${cor:.2f}\").scale(0.5)\n",
        "    corText.to_corner(DOWN + RIGHT)\n",
        "    sText = Text(f\"Stick has mass {m2:.1f} kg\",color=BLUE).scale(0.3)\n",
        "    pText = Text(f\"Puck has mass {m1:.1f} kg\",color=WHITE).scale(0.3)\n",
        "    pText.next_to(sText, DOWN)\n",
        "    cmText = Text(\"Center of mass marked in green\",color=BRIGHTGREEN).scale(0.3)\n",
        "    cmText.next_to(pText, DOWN)\n",
        "\n",
        "    legend = Group(sText,pText,cmText)\n",
        "    legend.to_corner(UP + LEFT)\n",
        "    self.add(puck,stick,cm,corText,legend)\n",
        "\n",
        "    \n",
        "    self.wait(5)\n",
        "\n",
        "# To render video run the following in a terminal:\n",
        "# manim -pql puckStickCollision.py puckStickCollision"
      ],
      "id": "627ba807",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/usr/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}