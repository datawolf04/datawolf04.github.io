{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Modeling Heat Flow - Part 3\"\n",
        "description: \"Modeling the sun\"\n",
        "author: \"Steven Wolf\"\n",
        "date: \"12/13/2024\"\n",
        "number-sections: false\n",
        "categories:\n",
        "  - Heat Equation\n",
        "  - Astrophysics\n",
        "  - Python\n",
        "  - Modeling\n",
        "  - 3D system\n",
        "  - Finite Difference Method\n",
        "  - Animating Plots\n",
        "execute: \n",
        "  messages: false\n",
        "  warning: false\n",
        "jupyter: python3\n",
        "draft:\n",
        "  true\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "I've been in the weeds on this for a while, so it's time to zoom back to the big picture. Specifically, I'm working on a model of heat flow in my house because it gets hot in parts of my house during the summer even with the AC going full blast.  I've written a series of posts [introducing the heat equation](../heatEqn1/modelHeatFlow.qmd), [modeling solar heat generation](../heatEqn2/heatEqn2.qmd), and [visualizing the dynamics of a simple system](../heatEqn2/hotBoxViz.qmd). However, the limiting approximation being made was that the sun's rays were directly incident on the top surface **at all times**. This made the calculation easy, but is clearly not realistic.  This is going to be a little mathy, but I can make some pictures to support the mathematics.\n",
        "\n",
        "## Locating the sun\n",
        "\n",
        "The location of the sun is important because the power deposited into a surface from any light source is related to the angle of incidence. Consider the figure below:\n",
        "\n",
        "![](surface.png){fig-align=\"center\" width=400} \n",
        "\n",
        "The orange ray indicates the direction of the sunlight at the surface, and the dotted line indicates the direction of the line that is perpendicular to the surface. The power generated in the surface due to sunlight will be:\n",
        "$$\n",
        "P = I_{\\text{Sun}} A \\cos^2\\beta\n",
        "$$\n",
        "where $I_\\text{sun}$ is the intensity of the sunlight and $A$ is the area of the surface.  This assumes things like the size of the surface is much smaller than the distance from that surface to the sun. But this angle depends on the following:\n",
        "\n",
        "- The orientation of the surface relative to the surface of the earth. For example is it horizontal or vertical? And if it is vertical (like a wall) is it facing north or east?\n",
        "- The time of day. As we learn in grade school, the sun rises in the east and sets in the west.\n",
        "- The latitude of the surface.\n",
        "- The time of year.\n",
        "\n",
        "Given all of these things, it is not as simple as stating that the sun starts at $\\beta=-90\\deg$ at sunrise and sets at $\\beta=+90\\deg$.  So I'm going to develop a framework for calculating this.\n",
        "\n",
        "### Terrestrial coordinate system\n",
        "I'm going to develop a terrestrial coordinate system so that I can calculate the angle of incidence.  I'll begin by considering the tilt of the earth's rotation axis relative to the direction of sunlight. In the figures below, sunlight is in the direction of the yellow rays, the earth is at the origin of the coordinate system, and the z direction is the earth's rotation axis. (I'm indicating the poles by the white blobs on the sphere, and the north pole has the red arrow representing the +z axis poking through it).\n",
        "\n",
        "![](seasons.png){fig-align=\"center\" width=800} \n",
        "\n",
        "We know that seasons change because the sun's ray's are more/less direct at different latitudes, and this changes because the angle of the earth's rotation axis changes relative to the direction of sunlight.  I've labeled this angle $\\alpha$ in the figure above. We know that it varies from $+23.5 \\deg$ to $-23.5 \\deg$ on the winter solstice and the summer solstice respectively. On the equinoxes, $\\alpha=0 \\deg$ as depicted above.  We can write a function for $\\alpha$ as follows:\n",
        "\n",
        "$$\n",
        "\\alpha(T) = \\alpha_0 \\cos(\\Omega_y T)\n",
        "$$\n",
        "where $T$ is the number of days after the winter solstice, and $\\Omega_y = \\frac{2\\pi}{1\\,\\text{yr}}$ is the angular frequency of 1 year. Below, I will create a function `axisTilt` for calculating this angle based on the fraction of a year that has passed since the winter solstice.\n"
      ],
      "id": "edaa71c0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def axisTilt(T):\n",
        "  maxTilt = 23.5\n",
        "  omegaYear = 2*np.pi\n",
        "  axisTilt = maxTilt * np.cos(omegaYear*T)"
      ],
      "id": "79be9f04",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Since we need to account for changing $\\alpha$, I will need to include as a variable, this is done on the figure below. I will now use this to determine the direction of the sun's rays $\\hat{R}$ in terms of the earth's coordinate system. To aid in this, I will choose the $xz$ plane to be in the plane of the drawing, and the sun's rays will be along the unit vectors in the $x$ and $z$ directions as follows:\n",
        "\n",
        "$$\n",
        "\\hat{R} = \\cos\\alpha \\hat{i} + \\sin\\alpha \\hat{k}\n",
        "$$\n",
        "\n",
        "![](earthViz.png){fig-align=\"center\" width=600} \n",
        "\n",
        "If we consider a point on the surface of the earth, it will be useful to use spherical coordinates.  The unit vectors in the $\\hat{r}$ and $\\hat{\\theta}$ directions are depicted on the drawing above ($\\hat{\\phi}$ is into the screen at the location given).  We know that the spherical unit vectors are:\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        "  \\hat{r} &= \\sin\\theta\\cos\\phi \\hat{i} + \\sin\\theta\\sin\\phi \\hat{j} + \\cos\\theta \\hat{k} \\\\\n",
        "  \\hat{\\theta} &= \\cos\\theta\\cos\\phi \\hat{i} + \\cos\\theta\\sin\\phi \\hat{j} -\\sin\\theta\\hat{k} \\\\\n",
        "  \\hat{\\phi} &= -\\sin\\phi \\hat{i} + \\cos\\phi\\hat{j} \\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "Using this coordinate system allows us to interpret several things. First, the polar angle is related to the angle of latitude.\n",
        "$$\n",
        "\\theta = 90\\deg - \\theta_{L}\n",
        "$$\n",
        "where $\\theta_L$ is the angle of Latitude at the location of interest (North latitude is positive, South latitude is negative.) Yes, I'm using degrees. Yes, it feels kind of wrong to use degrees. I like using the most natural units I can ($\\hbar=c=1$ anyone?). I'll have to convert to radians when I code, but when I look up latitudes on the map, I get degrees.  As I tell my students, knowing what units you have is more important that putting everything into SI units. But I digress.  The relationship between the polar angle and the angle of latitude has the meaning that:\n",
        "$$\n",
        "\\sin{\\theta} = \\cos\\theta_L \\quad \\text{and} \\cos\\theta = \\sin\\theta_L\n",
        "$$\n",
        "\n",
        "Next, the time of day can be related to the azimuthal angle:\n",
        "$$\n",
        "\\phi = \\Omega t\n",
        "$$\n",
        "where $\\Omega = \\frac{2\\pi}{1 \\text{ day}}$ is the angular frequency of the earth's rotation. So $\\phi=0$ implies $t=0$, which is solar midnight. (No need to standardize clocks across the planet for this.)\n",
        "\n",
        "Finally, we can also state that the unit vectors noted above are related to the cardinal directions and the local vertical. That is $\\hat{r}$ is the local vertical direction, $\\hat{\\theta}$ points South, and $\\hat{\\phi}$ points East.\n",
        "\n",
        "### Day/night\n",
        "Consider the dot product:\n",
        "$$\n",
        "\\hat{R}\\cdot\\hat{r} = \\cos\\alpha\\cos\\theta_L\\cos(\\Omega t) + \\sin\\alpha\\sin\\theta_L\n",
        "$$\n",
        "If this product is positive, the point of interest is on the night-side of the planet, and if negative, the point of interest is on the day-side of the planet. If this product is 0, then that point is at sunrise or sunset. Let's turn this into a function to determine if it is daytime given the time of day, latitude, and axis tilt. I won't actually use this function, but this suggests a method of determining when a surface is exposed to sunlight.\n"
      ],
      "id": "b2a1a03a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def isDaylight(t,axisTilt,thetaLatitude):\n",
        "  oneDay = 24*60*60 # seconds\n",
        "  Omega = 2*np.pi/oneDay\n",
        "  alpha = axisTilt*np.pi/180\n",
        "  thetaL = thetaLatitude*np.pi/180\n",
        "  rDotR = np.cos(alpha)*np.cos(thetaL)*np.cos(Omega*t) + np.sin(alpha)*np.sin(thetaL)\n",
        "  if rDotR > 0:\n",
        "    isDay = False\n",
        "  else:\n",
        "    isDay = True\n",
        "  \n",
        "  return isDay"
      ],
      "id": "d810a228",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note, that we can determine the sunrise/sunset times if we set the dot product above equal to zero and solve the following equation for $t$:\n",
        "$$\n",
        "\\cos(\\Omega t) = - \\tan\\alpha \\tan\\theta_L\n",
        "$$\n",
        "Implicitly, we are restricting $t$ to be less than one solar day.  Below, I will use this to determine the length of the summer and winter solstice days here in Greenville, NC (Latitude = $35.6 \\deg$ N).\n"
      ],
      "id": "0261a07a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "def dayCalc():\n",
        "  oneDay = 24 # hours\n",
        "  Omega = 2 * np.pi / oneDay\n",
        "  alphaMax = 23.5*np.pi/180\n",
        "  greenvilleLatitude = 35.6*np.pi/180\n",
        "  \n",
        "  winterSolTime = 24-2*np.arccos(-np.tan(+alphaMax)*np.tan(greenvilleLatitude))/Omega\n",
        "  summerSolTime = 24-2*np.arccos(-np.tan(-alphaMax)*np.tan(greenvilleLatitude))/Omega\n",
        "  print(f'The summer solstice has {summerSolTime:.1f} hours of sunlight in Greenville, NC.')\n",
        "  print(f'The winter solstice has {winterSolTime:.1f} hours of sunlight in Greenville, NC.')\n",
        "  \n",
        "dayCalc()"
      ],
      "id": "c404f0de",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Temperature cycle\n",
        "Now that we can put all of these together, I'm going to make decisions about modeling air temperature.  I will make some assumptions.\n",
        "\n",
        "1. The daily low temperature occurs at sunrise, the daily high temperature occurs at sunset.\n",
        "2. Temperature will smoothly increase (like a cosine) during the daylight and smoothly decrease (also like a cosine) during the nighttime.\n"
      ],
      "id": "8dceb2d6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "\n",
        "def getSunriseSunset(axisTilt,thetaLatitude):\n",
        "  oneDay = 24*60*60 # seconds\n",
        "  Omega = 2*np.pi/oneDay\n",
        "  alpha = axisTilt*np.pi/180\n",
        "  thetaL = thetaLatitude*np.pi/180\n",
        "  tSunrise = np.arccos(-np.tan(alpha)*np.tan(thetaL))/Omega\n",
        "  tSunset = oneDay - tSunrise\n",
        "  return [tSunrise, tSunset]\n",
        "\n",
        "def airTemp(t,lowT, highT, axisTilt, thetaLatitude):\n",
        "  oneDay = 24*60*60 # seconds\n",
        "  avgTemp = (lowT+highT)/2\n",
        "  tempDiff = (highT-lowT)/2\n",
        "  tRise, tSet = getSunriseSunset(axisTilt,thetaLatitude)\n",
        "  tDaylight = tSet-tRise\n",
        "  OmegaDay = np.pi/tDaylight\n",
        "  OmegaNight = np.pi/(oneDay-tDaylight)\n",
        "  \n",
        "  if(t < tRise):\n",
        "    airTemp = avgTemp - tempDiff * np.cos(OmegaNight * (t-tRise))\n",
        "  elif(t < tSet):\n",
        "    airTemp = avgTemp - tempDiff * np.cos(OmegaDay * (t-tRise))\n",
        "  else:\n",
        "    airTemp = avgTemp + tempDiff * np.cos(OmegaNight * (t-tSet))\n",
        "  \n",
        "  return airTemp\n",
        "  \n",
        "def makeTempPlot(lowT, highT, axisTilt, thetaLatitude):\n",
        "  oneDay = 24*60*60 # seconds\n",
        "  t = np.linspace(0,oneDay,24*60)\n",
        "  temp = np.zeros(len(t))\n",
        "  for i in range(len(t)):\n",
        "    temp[i] = airTemp(t[i],lowT, highT, axisTilt, thetaLatitude)\n",
        "  T = getSunriseSunset(axisTilt,thetaLatitude)\n",
        "  hrs = np.linspace(0,24,25).astype(int)\n",
        "  plt.plot(t,temp)\n",
        "  plt.axvline(T[0], linestyle='dashed',color='darkgrey')\n",
        "  plt.axvline(T[1], linestyle='dashed',color='darkgrey')\n",
        "  plt.xticks(ticks=np.linspace(0,oneDay,25),labels=hrs)\n",
        "  plt.xticks(ticks=[],minor=True)\n",
        "  plt.xlabel('Time of day (hr)')\n",
        "  plt.ylabel('Temp (deg C)')\n",
        "  plt.show()\n",
        "\n",
        "makeTempPlot(22,30,-22,35.6)"
      ],
      "id": "0c5b6f0a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Returning to the box\n",
        "Let's integrate all of this astrophysics into our box.\n",
        "\n",
        "### Solar power generation on a box\n",
        "So back to the simple box system, I can set up my box so that it has two faces in the N/S direction, and two faces in the E/W direction.  I will set things up much as I have done before:\n"
      ],
      "id": "41739ddc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Heat parameters\n",
        "thermalDiffusivity = 22.39e-6 # meters^2/s for air\n",
        "heatTransferCoef = 1 # For a typical metal to air W/m^2K\n",
        "thermalConductivity = 50 # For a typical metal W/mK\n",
        "specificHeat = 1000 # for aluminum J/kg K\n",
        "wallDensity = 3000 # kg/m^3 for aluminum\n",
        "solarIntensity = 1000 # W/m^2\n",
        "\n",
        "## Results from previous optimization\n",
        "optA = 1.117617e-03\n",
        "optB = 6.666691e-03\n",
        "solarThickness = 1/(specificHeat*wallDensity*optA) # m\n",
        "conductionThickness = heatTransferCoef/(specificHeat*wallDensity*optB) \n",
        "\n",
        "# Length parameters (meters)\n",
        "L = 2\n",
        "W = 1\n",
        "H = 1\n",
        "\n",
        "Deltax = 0.05\n",
        "xmax = int(L/Deltax)\n",
        "ymax = int(W/Deltax)\n",
        "zmax = int(H/Deltax)\n",
        "\n",
        "xmid = xmax // 2\n",
        "ymid = ymax // 2\n",
        "zmid = zmax // 2\n",
        "\n",
        "xgrid = np.linspace(0,L,xmax+1)\n",
        "ygrid = np.linspace(0,W,ymax+1)\n",
        "zgrid = np.linspace(0,H,zmax+1)\n",
        "\n",
        "u0 = np.empty((xmax,ymax,zmax))"
      ],
      "id": "714bcc0f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now let's create an improved power generation function. The parameters are:\n",
        "\n",
        "- `umat` The existing temperature matrix (in Celsius)\n",
        "- `t` The current time (in seconds)\n",
        "- `startDay` The number of days since the winter solstice that we are starting with\n",
        "- `thetaLatitude` The latitude (in degrees) of the system\n",
        "- `intensity` The intensity of sunlight at the earth's surface (about 1000 W/m^2 on a clear day)\n",
        "- `c` The specific heat of the material making up the system's walls\n",
        "- `rho` The density of the material making up the system's walls\n",
        "- `penDepth` The effective penetration depth of sunlight into the surface\n"
      ],
      "id": "a19e42eb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def powerGen(t, umat, startDay, thetaLatitude, intensity, c, rho, penDepth):\n",
        "  topFrac = 0\n",
        "  northFrac = 0\n",
        "  southFrac = 0\n",
        "  eastFrac = 0\n",
        "  westFrac = 0\n",
        "  powerGen = np.zeros_like(umat)\n",
        "  topPowerGen = powerGen\n",
        "  northPowerGen = powerGen\n",
        "  southPowerGen = powerGen\n",
        "  eastPowerGen = powerGen\n",
        "  westPowerGen = powerGen\n",
        "  A = 1/(c*rho*penDepth)\n",
        "  oneDay = 24*60*60 # seconds\n",
        "  Omega = 2*np.pi/oneDay\n",
        "  daysSinceWinterSolstice = startDay + t // oneDay\n",
        "  tiltAngleRad = axisTilt(daysSinceWinterSolstice)*np.pi/180\n",
        "  thetaL = thetaLatitude*np.pi/180\n",
        "  rDotR = np.cos(tiltAngleRad)*np.cos(thetaL)*np.cos(Omega*t) + np.sin(tiltAngleRad)*np.sin(thetaL)\n",
        "  # If it is daytime, need to add power, else, no power added\n",
        "  if rDotR <=0:\n",
        "    topPowerGen[:,:,-1].fill(A * rDotR**2 * intensity)\n",
        "    # How much power to add to each wall?\n",
        "    thetaDotR = np.cos(tiltAngleRad)*np.sin(thetaL)*np.cos(Omega*t) + np.sin(tiltAngleRad)*np.cos(thetaL)\n",
        "    phiDotR = -np.cos(tiltAngleRad)*np.sin(Omega*t)\n",
        "    # If southern exposure add to south wall, otherwise, there is northern exposure\n",
        "    if thetaDotR <= 0: \n",
        "      southPowerGen[:,0,:].fill(A * thetaDotR**2 * intensity)\n",
        "    else:\n",
        "      northPowerGen[:,-1,:].fill(A * thetaDotR**2 * intensity)\n",
        "    # If eastern exposure add to east wall, otherwise, there is western exposure\n",
        "    if phiDotR <= 0: \n",
        "      eastPowerGen[0,:,:].fill(A * phiDotR**2 * intensity)\n",
        "    else:\n",
        "      westPowerGen[0,:,:].fill(A * phiDotR**2 * intensity)\n",
        "  powerGen = topPowerGen + northPowerGen + southPowerGen + eastPowerGen + westPowerGen\n",
        "  return powerGen"
      ],
      "id": "4d54f51f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Boundary convection\n",
        "\n",
        "This can be integrated with the existing code with a few modifications. Specifically, in the boundary convection function, I will use the heat transfer coefficient, specific heat, and density of the system's walls, as well as the effective thickness of the convection boundary. I will also allow the ground to be a different temperature than the air\n"
      ],
      "id": "ac8c9011"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "def bdryConv(t, umat, Tair, Tground, heatTransferCoef, c, rho, convThickness):\n",
        "  Bair = heatTransferCoef/(c*rho*convThickness)\n",
        "  Bground = Bair/100\n",
        "  \n",
        "  bdryTemp = np.zeros_like(umat)\n",
        "  uSurf = np.zeros_like(umat)\n",
        "  duConvdt = np.zeros_like(umat)\n",
        "\n",
        "  bdryTemp[0,:,:].fill(Tair)\n",
        "  bdryTemp[:,0,:].fill(Tair)\n",
        "  bdryTemp[:,:,0].fill(Tground)\n",
        "  bdryTemp[-1,:,:].fill(Tair)\n",
        "  bdryTemp[:,-1,:].fill(Tair)\n",
        "  bdryTemp[:,:,-1].fill(Tair)\n",
        "\n",
        "  uSurf[0,:,:] = umat[0,:,:]\n",
        "  uSurf[:,0,:] = umat[:,0,:]\n",
        "  uSurf[:,:,0] = umat[:,:,0]\n",
        "  uSurf[-1,:,:] = umat[-1,:,:]\n",
        "  uSurf[:,-1,:] = umat[:,-1,:]\n",
        "  uSurf[:,:,-1] = umat[:,:,-1]\n",
        "\n",
        "  # Heat transfer with the air\n",
        "  duConvdt[:,:,1:] = Bair*(bdryTemp[:,:,1:] - uSurf[:,:,1:])\n",
        "  # Heat transfer with the ground\n",
        "  duConvdt[:,:,0] = Bground*(bdryTemp[:,:,0] - uSurf[:,:,0])\n",
        "  \n",
        "  return duConvdt    \n",
        "\n",
        "def lap3DFE(umat,dx):\n",
        "    lap = np.empty_like(umat)\n",
        "\n",
        "    # Interior elements:\n",
        "    lap[1:-1,1:-1,1:-1] = (umat[:-2, 1:-1, 1:-1] + umat[2:, 1:-1, 1:-1] + umat[1:-1, :-2, 1:-1] + \n",
        "                           umat[1:-1, 2:, 1:-1] + umat[1:-1,1:-1,:-2] + umat[1:-1,1:-1,2:] - 6*umat[1:-1,1:-1,1:-1]) / dx**2\n",
        "\n",
        "    # Surface elements:\n",
        "    lap[0,1:-1,1:-1] = (2* umat[1, 1:-1, 1:-1] + \n",
        "                        umat[0, :-2, 1:-1] + umat[0, 2:, 1:-1] + umat[0, 1:-1, :-2] + umat[0, 1:-1, 2:] - 6*umat[0, 1:-1, 1:-1]) / (2*dx**2)\n",
        "    lap[-1,1:-1,1:-1] = (2* umat[-2, 1:-1, 1:-1] + \n",
        "                        umat[-1, :-2, 1:-1] + umat[-1, 2:, 1:-1] + umat[-1, 1:-1, :-2] + umat[-1, 1:-1, 2:] - 6*umat[-1, 1:-1, 1:-1]) / (2*dx**2)\n",
        "    lap[1:-1,0,1:-1] = (2* umat[1:-1, 1, 1:-1] + \n",
        "                        umat[:-2, 0, 1:-1] + umat[2:, 0, 1:-1] + umat[1:-1, 0, :-2] + umat[1:-1, 0, 2:] - 6*umat[1:-1, 0, 1:-1]) / (2*dx**2)\n",
        "    lap[1:-1,-1,1:-1] = (2* umat[1:-1, -2, 1:-1] + \n",
        "                        umat[:-2, -1, 1:-1] + umat[2:, -1, 1:-1] + umat[1:-1, -1, :-2] + umat[1:-1, -1, 2:] - 6*umat[1:-1, -1, 1:-1]) / (2*dx**2)\n",
        "    lap[1:-1,1:-1,0] = (2* umat[1:-1, 1:-1, 1] + \n",
        "                        umat[:-2, 1:-1, 0] + umat[2:, 1:-1, 0] + umat[1:-1, :-2, 0] + umat[1:-1, 2:, 0] - 6*umat[1:-1, 1:-1, 0]) / (2*dx**2)\n",
        "    lap[1:-1,1:-1,-1] = (2* umat[1:-1, 1:-1, -2] + \n",
        "                        umat[:-2, 1:-1, -1] + umat[2:, 1:-1, -1] + umat[1:-1, :-2, -1] + umat[1:-1, 2:, -1] - 6*umat[1:-1, 1:-1, -1]) / (2*dx**2)\n",
        "\n",
        "    # Edge Elements:\n",
        "    lap[0,0,1:-1] = (2 * umat[1, 0, 1:-1] + 2 * umat[0, 1, 1:-1] + umat[0, 0, :-2] + umat[0, 0, 2:] - 6*umat[0, 0, 1:-1]) / (4*dx**2)\n",
        "    lap[0,-1,1:-1] = (2 * umat[1, -1, 1:-1] + 2 * umat[0, -2, 1:-1] + umat[0, -1, :-2] + umat[0, -1, 2:] - 6*umat[0, -1, 1:-1]) / (4*dx**2)\n",
        "    lap[-1,0,1:-1] = (2 * umat[2, 0, 1:-1] + 2 * umat[-1, 1, 1:-1] + umat[-1, 0, :-2] + umat[-1, 0, 2:] - 6*umat[-1, 0, 1:-1]) / (4*dx**2)\n",
        "    lap[-1,-1,1:-1] = (2 * umat[2, -1, 1:-1] + 2 * umat[-1, -2, 1:-1] + umat[-1, -1, :-2] + umat[-1, -1, 2:] - 6*umat[-1, -1, 1:-1]) / (4*dx**2)\n",
        "    lap[0,1:-1,0] = (2 * umat[1, 1:-1, 0] + 2 * umat[0, 1:-1, 1] + umat[0, 2:, 0] + umat[0, :-2, 0] - 6*umat[0, 1:-1, 0]) / (4*dx**2)\n",
        "    lap[0,1:-1,-1] = (2 * umat[1, 1:-1, -1] + 2 * umat[0, 1:-1, -2] + umat[0, 2:, -1] + umat[0, :-2, -1] - 6*umat[0, 1:-1, -1]) / (4*dx**2)\n",
        "    lap[-1,1:-1,0] = (2 * umat[-2, 1:-1, 0] + 2 * umat[-1, 1:-1, 1] + umat[-1, 2:, 0] + umat[-1, :-2, 0] - 6*umat[-1, 1:-1, 0]) / (4*dx**2)\n",
        "    lap[-1,1:-1,-1] = (2 * umat[-2, 1:-1, -1] + 2 * umat[-1, 1:-1, -2] + umat[-1, 2:, -1] + umat[-1, :-2, -1] - 6*umat[-1, 1:-1, -1]) / (4*dx**2)\n",
        "    lap[1:-1,0,0] = (2 * umat[1:-1, 1, 0] + 2 * umat[1:-1, 0, 1] + umat[:-2, 0, 0] + umat[2:, 0, 0] - 6*umat[1:-1, 0, 0]) / (4*dx**2)\n",
        "    lap[1:-1,0,-1] = (2 * umat[1:-1, 1, -1] + 2 * umat[1:-1, 0, -2] + umat[:-2, 0, -1] + umat[2:, 0, -1] - 6*umat[1:-1, 0, -1]) / (4*dx**2)\n",
        "    lap[1:-1,-1,0] = (2 * umat[1:-1, -2, 0] + 2 * umat[1:-1, -1, 1] + umat[:-2, -1, 0] + umat[2:, -1, 0] - 6*umat[1:-1, -1, 0]) / (4*dx**2)\n",
        "    lap[1:-1,-1,-1] = (2 * umat[1:-1, 2, -1] + 2 * umat[1:-1, -1, -2] + umat[:-2, -1, -1] + umat[2:, -1, -1] - 6*umat[1:-1, -1, -1]) / (4*dx**2)    \n",
        "    \n",
        "    # Corner Elements:\n",
        "    lap[0,0,0] = (umat[1, 0, 0] + umat[0, 1, 0] + umat[0, 0, 1] - 3*umat[0, 0, 0]) / (2*dx**2)\n",
        "    lap[-1,0,0] = (umat[-2, 0, 0] + umat[-1, 1, 0] + umat[-1, 0, 1] - 3*umat[-1, 0, 0]) / (2*dx**2)\n",
        "    lap[0,-1,0] = (umat[1, -1, 0] + umat[0, -2, 0] + umat[0, -1, 1] - 3*umat[0, -1, 0]) / (2*dx**2)\n",
        "    lap[0,0,-1] = (umat[1, 0, -1] + umat[0, 1, -1] + umat[0, 0, -2] - 3*umat[0, 0, -1]) / (2*dx**2)\n",
        "    lap[0,-1,-1] = (umat[1, -1, -1] + umat[0, -2, -1] + umat[0, -1, -2] - 3*umat[0, -1, -1]) / (2*dx**2)\n",
        "    lap[-1,0,-1] = (umat[-2, 0, -1] + umat[-1, 1, -1] + umat[-1, 0, -2] - 3*umat[-1, 0, -1]) / (2*dx**2)\n",
        "    lap[-1,-1,0] = (umat[2, -1, 0] + umat[-1, -2, 0] + umat[-1, -1, 1] - 3*umat[-1, -1, 0]) / (2*dx**2)\n",
        "    lap[-1,-1,-1] = (umat[-2, -1, -1] + umat[-1, -2, -1] + umat[-1, -1, -2] - 3*umat[-1, -1, -1]) / (2*dx**2)\n",
        "\n",
        "    return lap\n",
        "  \n",
        "def dudt(t, u, alpha, dx, startDay, thetaLatitude, intensity, penDepth, c, rho, Tair, heatTransferCoef, convThickness):\n",
        "  dudt = alpha*lap3DFE(u,dx) + powerGen(t, umat, startDay, thetaLatitude, intensity, c, rho, penDepth) + bdryConv(t, umat, Tair, heatTransferCoef, c, rho, convThickness)\n",
        "  return dudt\n",
        "\n",
        "def dudtFlat(t, uflat, alpha, dx, startDay, thetaLatitude, intensity, penDepth, c, rho, \n",
        "          Tair, heatTransferCoef, convThickness):\n",
        "    u = uflat.reshape(xmax,ymax,zmax)\n",
        "    dudt3d = dudt(t, u, alpha, dx, startDay, thetaLatitude, intensity, penDepth, c, rho, \n",
        "          Tair, heatTransferCoef, convThickness)\n",
        "    return dudt3d.flatten()"
      ],
      "id": "b035690b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Simulating a hot box\n",
        "Ok, so it's time to simulate this system. First we will need to make some decisions. First, we need to decide where the system is. I will put it where I'm currently living, Greenville, NC (Latitude = $35.6 \\deg$ N). Next, we need to decide what day of the year it is. Let's say it is \n",
        "\n",
        "\n",
        "Now we can finally run the model:\n"
      ],
      "id": "4ab9d54e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def simToyHotBox(A,B,tmax, nt):\n",
        "    oneHour = 3600\n",
        "    airTemp = 27\n",
        "    eqTemp = airTemp + A*solarIntensity/B * L*W/(2*(L*W + L*H + W*H))\n",
        "    u0.fill(airTemp)\n",
        "    time = np.arange(0,tmax,nt)\n",
        "    \n",
        "    hotBoxSim = solve_ivp(dudtFlat, t_span=[0,10*oneHour], y0=u0.flatten(), t_eval= time, \n",
        "                            args=[thermalDiffusivity,solarIntensity,Deltax,airTemp,A,B])\n",
        "\n",
        "    return hotBoxSim"
      ],
      "id": "653a723d",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/usr/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}