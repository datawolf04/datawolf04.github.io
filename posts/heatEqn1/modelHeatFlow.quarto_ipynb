{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Modeling Heat Flow\"\n",
        "description: \"Torture is bad. Also, half of my house gets too warm/cold, and that's not my favorite.\"\n",
        "author: \"Steven Wolf\"\n",
        "date: \"11/3/2024\"\n",
        "number-sections: false\n",
        "categories:\n",
        "  - Heat Equation\n",
        "  - Python\n",
        "  - Modeling\n",
        "  - 3D system\n",
        "  - Finite Difference Method\n",
        "execute: \n",
        "  messages: false\n",
        "  warning: false\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "## Personal Motivation for this post\n",
        "I have a house, and I need to improve the heating/cooling in it. Essentially, the problem is that my house is a long and narrow, and the air return is not able to sufficiently draw the cold/hot air from rooms on the far side of the house. Essentially, the air return/exchange system is not sufficient. As a result, half of my house is really hot in the summer/extra chilly in the winter. \n",
        "\n",
        "There is some ducting in place intended to aid circulation, but it is ineffective as it doesn't draw any air from the hot/cold room, relying on diffusion only to drive circulation. Furthermore, it is located in a bedroom rather than the living room which is significantly larger, more distant from the return, and--as a result--has the largest temperature problem. I am planning on installing a duct fan, which will help solve this problem. But that leaves these questions:\n",
        "\n",
        "1. How strong should my duct fan be?\n",
        "2. Will the existing return be enough to alleviate the problem by simply adding in a duct fan?\n",
        "3. If the answer to the previous question is no, where should I put another vent to make the biggest impact?\n",
        "\n",
        "I figure I can use my physics brain, and a little code to analyze this problem. So I'm going to spend some time figuring out how to implement the heat equation with appropriate boundary conditions applying them to scenarios that are progressively more complex, until I feel that I can apply them to my own house.\n",
        "\n",
        "## Heat Equation\n",
        "All of this starts by understanding heat flow. The heat equation is:\n",
        "\n",
        "$$\n",
        "\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2u\n",
        "$$\n",
        "\n",
        "where $u = u(x,y,z,t)$ is a function describing the temperature at every point in space and time in the region of interest and $\\alpha$ is the Thermal Diffusivity of the material (which can depend on position as well).  There are many boundary conditions that can be applied, but I will apply _Robin Conditions_ which generally apply to convection/conduction.\n",
        "\n",
        "$$\n",
        "k \\left. \\frac{\\partial u}{\\partial n}\\right|_{S} = h \\left(u(S,t) - v(S, t)\\right)\n",
        "$$\n",
        "\n",
        "Here $n$ is the direction of the outward normal of the boundary surface, $S$ indicates a spatial point on the boundary surface, $k$ is the thermal conductivity, $h$ is the heat transfer coefficient, and $v$ is the temperature on the other side of the boundary.  This is the \"Newton's law of cooling\" that you may have heard about in an introductory calculus class, although, it is usually presented as:\n",
        "\n",
        "$$\n",
        "\\frac{dT}{dt} = -a(T-T_0)\n",
        "$$\n",
        "where $a$ is some sort of constant, and $T_0$ is the temperature of the surroundings. What this means is that the steady-state behavior of this system is that it tends towards the temperature of the surroundings. This has limitations which I will discuss later.\n",
        "\n",
        "## Simple system\n",
        "As a \"simple\" 3D system, I'll model a [\"hot box\" or \"sweatbox\" used by some for torture](https://en.wikipedia.org/wiki/Box_(torture)). This is not, nor should it be construed as an endorsement of torture. It's just a simple box, and it gives me some intuitive knobs to use as I work this problem. Also, given the boundary condition that I previously mentioned, this means that the box can never be warmer than the surroundings. This isn't fully realistic yet, as anyone who has seen a PSA about leaving kids/pets in a hot car even on a \"cool\" day. But there's enough here to get me to start writing code.\n",
        "\n",
        "### Box dimensions\n",
        "I will model this as a box with length $L$, width $W$, and height $H$. I'll orient my coordinate system so that the origin is in a lower corner and points $(x,y,z)$ in the region of interest are bounded by the following: $0\\leq x\\leq L$, $0\\leq y \\leq W$, and $0\\leq z \\leq H$.  "
      ],
      "id": "f3d0c47a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Length and time parameters (meters)\n",
        "L = 2\n",
        "W = 1\n",
        "H = 1\n",
        "oneDay = 24*60*60 # seconds\n",
        "T = 10*oneDay # Let this run for several days"
      ],
      "id": "34346da1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Thermal properties of the box\n",
        "I will assume that the box is uniform. That means no windows or ventilation. So $h$ and $k$ are constant and uniform on the boundary.  According to Wikipedia, the thermal diffusivity of air is $1.9\\times 10^{-7}$ m$^2$/s. According to [this article by Jayamaha *et.al.*](https://doi.org/10.1016/0360-1323(96)00014-5), the heat transfer coefficient for walls varies from 6 to 10 $\\frac{\\text{W}}{\\text{m}^2 \\text{K}}$. Looking at the [greenspec.co.uk website](https://www.greenspec.co.uk/building-design/insulation-materials-thermal-properties/) it would seem that the thermal conductivity of most building materials is on the order of 0.02-0.04 $\\frac{\\text{W}}{\\text{m K}}$."
      ],
      "id": "a468ba0d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Heat parameters\n",
        "alpha = 1.9e-7 # meters^2/s for air\n",
        "h = 10 # From Jayamaha\n",
        "k = 0.04 # From Greenspec"
      ],
      "id": "9d97850c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Modeling exterior temperature\n",
        "\n",
        "I'm going to assume the air temperature is time-dependent, and takes the form:\n",
        "\n",
        "$$\n",
        "v^{\\text{air}}(t) = T_0 - \\Delta T \\cos\\left(\\Omega t\\right)\n",
        "$$\n",
        "\n",
        "where $T_0$ is the average temperature of the day, and $\\Delta T$ represents the range of temperature.  On the ground, I'll assume the temperature is constant at $T_G$. So $t=0$ is sunrise. Making these parameters functions is overkill for now, but will be helpful as I get more complicated."
      ],
      "id": "f50f6640"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Temperature parameters\n",
        "T0 = 33\n",
        "DT = 6\n",
        "TG = 35\n",
        "\n",
        "def vair(T0,DT,t):\n",
        "  Omega = 2*np.pi/oneDay\n",
        "  vair = T0 - DT * np.cos(Omega * t)\n",
        "  return vair\n",
        "\n",
        "def vground(TG, t):\n",
        "  return TG"
      ],
      "id": "160579e9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Going from differential equations to matrix equations\n",
        "This is going to get a bit technical, and if you want to skip the details of the math behind the algorithm you can skip to the results in @sec-results.\n",
        "\n",
        "Essentially, the basis for all numerical methods involving systems that evolve in space and time is to replace continuous space and time values with a discrete mesh of space and time values. For this system, we are looking for the temperature at every location in space and time. So we will do this on a reduced space/time grid. Instead of having a function of $(x,y,z,t)$ we will have a 4-dimensional matrix that I will denote as follows:\n",
        "\n",
        "$$\n",
        "u(x,y,z,t) \\rightarrow u(x_i,y_j,z_k,t_l) = u^l_{ijk}\n",
        "$$\n",
        "\n",
        "For this I will define:\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        "x_i &= i \\Delta x \\\\\n",
        "y_j &= j \\Delta y \\\\\n",
        "z_k &= k \\Delta z \\\\\n",
        "t_l &= l \\Delta t \\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "where $\\Delta x, \\Delta y, \\Delta z,$ and $\\Delta t$ are computational choices.  Indeed, this freedom will allow me to choose $\\Delta x = \\Delta y = \\Delta z$. I will choose $\\Delta x = 5$ cm and $\\Delta t = 15$ minutes. I'll also define the max indices for this system, and also set up values for the grid. I will also set up the $u^l_{ijk}$ grid, and fill it with a constant value. Actually, I will do this for two different initial temperatures. If my code is working correctly, the initial temperature of the box should not matter if we let the simulation run for long enough.  Think about it this way: Imagine that you have two identical coolers, one filled with ice and the other empty. Now, let the coolers sit for a year in your yard. After that year, the coolers will no longer have a different temperature. "
      ],
      "id": "c94283d3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Computational parameters (time step and mesh size)\n",
        "Deltat = 60*15 # 15 minutes in seconds\n",
        "Deltax = 0.05  # 5 cm in meters\n",
        "\n",
        "xmax = int(L/Deltax)\n",
        "ymax = int(W/Deltax)\n",
        "zmax = int(H/Deltax)\n",
        "tmax = int(T/Deltat)\n",
        "\n",
        "xmid = xmax // 2\n",
        "ymid = ymax // 2\n",
        "zmid = zmax // 2\n",
        "\n",
        "t = np.linspace(0,T,tmax)\n",
        "xgrid = np.linspace(0,L,xmax+1)\n",
        "ygrid = np.linspace(0,W,ymax+1)\n",
        "zgrid = np.linspace(0,H,zmax+1)\n",
        "\n",
        "# Initialize the array(s) with a few different initial temperatures.\n",
        "u = np.empty((tmax,xmax,ymax,zmax))\n",
        "uAlt = np.empty((tmax,xmax,ymax,zmax))\n",
        "u_init = T0-DT\n",
        "u.fill(u_init)\n",
        "uAlt_init = (T0+TG)/2\n",
        "uAlt.fill(uAlt_init)"
      ],
      "id": "914a7b9a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Applying the Finite difference method to the boundary condition\n",
        "\n",
        "The boundary condition for conduction/convection states that the gradient of the temperature function at the boundary is proportional to the temperature difference across that boundary. For example on the surface where $x=0$ (or $i=0$), the outward normal direction is in the $-x$ direction:\n",
        "$$\n",
        "\\left. k\\frac{\\partial u}{\\partial x}\\right|_{x=0} = h(u(x=0,y,z,t) - v(x=0,y,z,t))\n",
        "$$\n",
        "I will apply the [finite difference method](https://en.wikipedia.org/wiki/Finite_difference_method) to find the spatial derivatives.\n",
        "$$\n",
        "\\begin{align*}\n",
        "\\frac{\\partial u}{\\partial x} &= \\frac{u^l_{i+1 jk}-u^l_{ijk}}{\\Delta x}   \\\\\n",
        "\\frac{\\partial u}{\\partial y} &= \\frac{u^l_{ij+1 k}-u^l_{ijk}}{\\Delta y}   \\\\\n",
        "\\frac{\\partial u}{\\partial z} &= \\frac{u^l_{ijk+1}-u^l_{ijk}}{\\Delta z}   \\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "Therefore, for $i=0$ (the $x=0$ boundary) we get:\n",
        "$$\n",
        "u^l_{1jk} - u^l_{0jk} = \\frac{h\\Delta x}{k} \\left(u^l_{0jk} - v^l_{jk}\\right)\n",
        "$$\n",
        "Solve for $u^l_{0jk}$:\n",
        "$$\n",
        "u^l_{0jk} = \\frac{u^l_{1jk} + \\beta v^l_{jk}}{1+\\beta}\n",
        "$$\n",
        "\n",
        "where I have defined:\n",
        "$$\n",
        "\\beta = \\frac{h \\Delta x}{k}\n",
        "$$\n",
        "Note that if $\\beta = 0$ boundary has an infinite thermal conductivity and $u^l_{0jk} = u^l_{1jk}$ or $\\frac{\\partial u}{\\partial n} = 0$.  This is the *Neumann Boundary Condition*.  If $\\beta\\rightarrow\\infty$, we find $u^l_{0jk} = v^l_{jk}$ and the temperature at the boundary is equal to the exterior temperature. This is the *Dirichelet Boundary Condition*.\n",
        "\n",
        "Plugging in some numbers, I'll assume that the proportionality constant $\\beta$ for heat exchange with the ground is 10 times larger than the same constant for heat exchange with the air.\n",
        "\n",
        "Let's put this into code and apply the boundary condition to the initial array:"
      ],
      "id": "017a40a5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "beta = h*Deltax/k\n",
        "betaG = 5*beta\n",
        "\n",
        "def applyBC(umat, tl):\n",
        "  t = tl*Deltat\n",
        "  umat[tl, 0, :, :] = (umat[tl, 1, :, :] + beta * vair(T0,DT,t))/(1+beta)\n",
        "  umat[tl, xmax-1, :, :] = (umat[tl, xmax-2, :, :] + beta * vair(T0,DT,t))/(1+beta)\n",
        "  umat[tl, :, 0, :] = (umat[tl, :, 1, :] + beta * vair(T0,DT,t))/(1+beta)\n",
        "  umat[tl, :, ymax-1, :] = (umat[tl, :, ymax-2, :] + beta * vair(T0,DT,t))/(1+beta)\n",
        "  umat[tl, :, :, 0] = (umat[tl, :, :, 1] + betaG * vground(TG,t))/(1+betaG)\n",
        "  umat[tl, :, :, zmax-1] = (umat[tl, :, :, zmax-2] + beta * vair(T0,DT,t))/(1+beta)\n",
        "  \n",
        "  return umat\n",
        "## Apply BCs at t=0 to finish initializing array\n",
        "u = applyBC(u, 0)\n",
        "uAlt = applyBC(uAlt,0)"
      ],
      "id": "e8b1f4a5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Applying the finite difference method to the heat equation: $\\dot{u} = \\alpha\\nabla^2u$\n",
        "I will again apply the [finite difference method](https://en.wikipedia.org/wiki/Finite_difference_method) to find the derivatives. The first derivative in time is:\n",
        "$$\n",
        "\\frac{\\partial u}{\\partial t} = \\frac{u^{l+1}_{ijk} - u^{l}_{ijk}}{\\Delta t} \n",
        "$$\n",
        "\n",
        "Another aspect of this method is that the Laplacian at any point can be calculated through the average of the difference between the nearest neighbors of that point and the point itself:\n",
        "$$\n",
        "\\nabla^2 u(x,y,z,t) = \\frac{u^l_{i+1 jk} + u^l_{i-1 jk} + \n",
        "    u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk}}{(\\Delta x)^2} \n",
        "$$\n",
        "\n",
        "The heat equation becomes:\n",
        "$$\n",
        "u^{l+1}_{ijk} = u^l_{ijk} + \\frac{\\alpha \\Delta t}{\\Delta x^2}\n",
        "    \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} + u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n",
        "$$\n",
        "Basically, this equation gives us a method for finding the temperature after a time step given the temperature at the previous time step.  I will define the dimensionless constant $\\gamma$ as follows:\n",
        "\n",
        "$$\n",
        "\\gamma = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n",
        "$$\n",
        "\n",
        "so we finally obtain:\n",
        "$$\n",
        "u^{l+1}_{ijk} = u^l_{ijk} + \\gamma \\left(u^l_{i+1 jk} + u^l_{i-1 jk} + u^l_{ij+1k} + \n",
        "      u^l_{ij-1k} + u^l_{ijk+1} + u^l_{ijk-1} - 6 u^l_{ijk} \\right)\n",
        "$$\n",
        "\n",
        "Now I will convert this to code:"
      ],
      "id": "3c3defae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gamma = alpha*Deltat/Deltax**2\n",
        "def calcHeatEqn(umat):\n",
        "    tm, xm, ym, zm = umat.shape\n",
        "    # Apply BCs\n",
        "    umat = applyBC(umat, 0)\n",
        "    for l in range(0,tm-1):\n",
        "      for i in range(1, xm-1):\n",
        "        for j in range(1, ym-1):\n",
        "          for k in range(1, zm-1):\n",
        "            umat[l+1,i,j,k] = umat[l,i,j,k] + gamma * (umat[l,i+1,j,k] + \n",
        "                  umat[l,i-1,j,k] + umat[l,i,j+1,k] + umat[l,i,j-1,k] + \n",
        "                  umat[l,i,j,k+1] + umat[l,i,j,k-1] - 6 * umat[l,i,j,k])\n",
        "      umat = applyBC(umat, l+1)\n",
        "    return umat"
      ],
      "id": "3e123a92",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Visualizing the temperature:\n",
        "The grid will probably be too fine to visualize well on a 3d heatmap. So I'll settle for some cross sections. The function `plotheatmaps` will plot heat maps inside the box for a given time in 3 perpendicular planes."
      ],
      "id": "a379b73e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: True\n",
        "\n",
        "def plotheatmaps(umat,l,i,j,k):\n",
        "  Tmin = np.min([u.min(),T0-DT])\n",
        "  Tmax = np.max([u.max(),T0+DT])\n",
        "  \n",
        "  xSlice = umat[l,i,:,:].transpose()\n",
        "  ySlice = umat[l,:,j,:].transpose()\n",
        "  zSlice = umat[l,:,:,k].transpose()\n",
        "  \n",
        "  time = Deltat*l\n",
        "  tMins = time // 60\n",
        "  theMinutes = tMins % 60\n",
        "  \n",
        "  tHours = tMins // 60\n",
        "  theDays = tHours // 24\n",
        "  theHours = tHours % 24\n",
        "  \n",
        "  theTime = str(theDays) + \" days \" + str(theHours) + \" hrs \"  + str(theMinutes) + \" min\"\n",
        "\n",
        "  xC, yC, zC = [Deltax*i, Deltax*j, Deltax*k]\n",
        "  \n",
        "  fig, (ax0,ax1,ax2) = plt.subplots(ncols=3,width_ratios=[ymax,xmax,xmax],\n",
        "              figsize=(8,3))\n",
        "    \n",
        "  fig.suptitle(f\"Heatbox Temp at {theTime} \\n Outdoor Temp = {vair(T0,DT,time):.2f} C \\n Ground Temp = {vground(TG,time):.0f} C\")\n",
        "    \n",
        "  im0 = ax0.pcolormesh(ygrid, zgrid, xSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n",
        "  ax0.set_aspect(1)\n",
        "  ax0.set_title(f\"x = {xC:.3f} m\")\n",
        "  ax0.set_xlabel(\"y\")\n",
        "  ax0.set_ylabel(\"z\")\n",
        "\n",
        "  im1 = ax1.pcolormesh(xgrid, zgrid, ySlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n",
        "  ax1.set_aspect(1)\n",
        "  ax1.set_title(f\"y = {yC:.3f} m\")\n",
        "  ax1.set_xlabel(\"x\")\n",
        "  ax1.set_ylabel(\"z\")\n",
        "  \n",
        "  im2 = ax2.pcolormesh(xgrid, ygrid, zSlice, shading=\"flat\", vmin = Tmin, vmax = Tmax)\n",
        "  ax2.set_aspect(1)\n",
        "  ax2.set_title(f\"z = {zC:.3f} m\")\n",
        "  ax2.set_xlabel(\"x\")\n",
        "  ax2.set_ylabel(\"y\")\n",
        "  \n",
        "  fig.tight_layout()\n",
        "  \n",
        "  cax = fig.add_axes([ax0.get_position().x0,ax0.get_position().y0-0.2,\n",
        "                ax2.get_position().x1 - ax0.get_position().x0, 0.02])\n",
        "  fig.colorbar(im2, cax = cax, orientation='horizontal')"
      ],
      "id": "9cbaab90",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "So the initial condition has the following heatmap:"
      ],
      "id": "cf64d619"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plotheatmaps(u,0,xmid,ymid,zmid)\n",
        "plotheatmaps(uAlt,0,xmid,ymid,zmid)"
      ],
      "id": "484b8a21",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Results {#sec-results}\n",
        "Finally, we will compute the time evolution of the temperature for the two scenarios."
      ],
      "id": "61148257"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = calcHeatEqn(u)\n",
        "uAlt = calcHeatEqn(uAlt)"
      ],
      "id": "f478e5e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Different initial condition comparison\n",
        "I'm going to start by comparing the behavior of the system given different initial conditions for the starting temperature within the box. The hidden code below crunches the average temperatures for the plots in this and the following sections."
      ],
      "id": "b70c9796"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: True\n",
        "\n",
        "## Calculate averages at every time step\n",
        "airTemp = np.zeros(tmax)\n",
        "groundTemp = np.zeros(tmax)\n",
        "boxTemp = np.zeros(tmax)\n",
        "btErr = np.zeros(tmax)\n",
        "boxTempAlt = np.zeros(tmax)\n",
        "btaErr = np.zeros(tmax)\n",
        "boxTempZ = np.zeros((tmax,zmax))\n",
        "btzErr = np.zeros((tmax,zmax))\n",
        "for l in range(tmax):\n",
        "  airTemp[l] = vair(T0,DT,t[l])\n",
        "  groundTemp[l] = vground(TG,t[l])\n",
        "  ul = u[l, :, :, :]\n",
        "  ulAlt = uAlt[l, :, :, :]\n",
        "  boxTemp[l] = np.mean(ul)\n",
        "  boxTempAlt[l] = np.mean(ulAlt)\n",
        "  btErr[l] = np.std(ul)\n",
        "  btaErr[l] = np.std(ulAlt)\n",
        "  for k in range(zmax):\n",
        "    ulk = ul[:,:,k]\n",
        "    boxTempZ[l,k] = np.mean(ulk)\n",
        "    btzErr[l,k] = np.std(ulk)\n",
        "\n",
        "## Calcs for temp in the day\n",
        "stepsInDay = int(oneDay/Deltat)\n",
        "days = int(T/oneDay)\n",
        "day = np.arange(0,days)\n",
        "\n",
        "boxTempDay = np.zeros(days)\n",
        "btdErr = np.zeros(days)\n",
        "boxTempDayAlt = np.zeros(days)\n",
        "btdaErr = np.zeros(days)\n",
        "boxTempDayZ = np.zeros((days,zmax))\n",
        "btdzErr = np.zeros((days,zmax))\n",
        "for d in range(days):\n",
        "    lmin = int(d*stepsInDay)\n",
        "    lmax = int((d+1)*stepsInDay)\n",
        "    ul = u[lmin:lmax, :, :, :]\n",
        "    boxTempDay[d] = np.mean(u[lmin:lmax, :, :, :])\n",
        "    boxTempDayAlt[d] = np.mean(uAlt[lmin:lmax, :, :, :])\n",
        "    btdErr[d] = np.std(u[lmin:lmax, :, :, :])\n",
        "    btdaErr[d] = np.std(uAlt[lmin:lmax, :, :, :])\n",
        "    for k in range(zmax):\n",
        "        boxTempDayZ[d,k] = np.mean(ul[:,:,:,k])\n",
        "        btdzErr[d,k] = np.std(ul[:,:,:,k])"
      ],
      "id": "547e7c50",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As noted previously, after a long enough time, I expect two identical boxes to exhibit the same behavior regardless of their initial conditions--much in the way that the long-term behavior of a Damped-Driven Oscillator is independent of the initial conditions. Let's check that out here:"
      ],
      "id": "4f589b3a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, (ax0, ax1) = plt.subplots(1,2,figsize=(8,4),sharey=True)\n",
        "ax0.plot(t,boxTemp, '-', label=rf\"$T_i=${u_init:.0f}\")\n",
        "ax0.plot(t,boxTempAlt, '--', label=rf\"$T_i=${uAlt_init:.0f}\")\n",
        "ax0.set_xlabel('Time (s)')\n",
        "ax0.set_ylabel('Temperature (deg C)')\n",
        "ax0.legend()\n",
        "\n",
        "ax1.plot(day,boxTempDay, 'o', label=rf\"$T_i=${u_init:.0f}\")\n",
        "ax1.plot(day,boxTempDayAlt, 's', label=rf\"$T_i=${uAlt_init:.0f}\")\n",
        "ax1.set_xlabel('Time (days)')\n",
        "ax1.set_ylabel('Temperature (deg C)')\n",
        "ax1.legend()\n",
        "plt.show()"
      ],
      "id": "e901faa8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "It would seem that the 10 days that I have simulated is long enough for these systems to reach this \"steady state\" solution.\n",
        "\n",
        "### Compare interior temperature to exterior temp\n",
        "I'm going to plot the external (air) temperature and compare it to the average temperature in the box, as well as consider the average temperature in horizontal slices as the change in time."
      ],
      "id": "97359c11"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(6.5,4))\n",
        "plt.plot(t,airTemp,label=\"Air Temp\",ls='dashed',linewidth=0.5)\n",
        "plt.errorbar(t,boxTemp,yerr=btErr, label=\"Avg. Box Temp\",linewidth=2, capsize=2, errorevery=24)\n",
        "plt.xlabel('Time (s)')\n",
        "plt.ylabel('Temperature (deg C)')\n",
        "for k in reversed(range(0,zmax,zmax//5)):\n",
        "    zval = k*Deltax\n",
        "    labString = f\"Avg Temp at z={zval:.2f} m\"\n",
        "    plt.plot(t,boxTempZ[:,k],label=labString, linewidth=1)\n",
        "    \n",
        "plt.plot(t,groundTemp,label=\"Ground Temp\",ls=\"dashed\",linewidth=0.5)\n",
        "plt.legend(loc=\"center left\", bbox_to_anchor=(1.04,0.5))\n",
        "plt.show()"
      ],
      "id": "cbfa4828",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Just to see that this is stabilizing, and to get an idea of how fast this stabilizes, I'm going to find a daily average temperature as above. "
      ],
      "id": "134f2114"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(8,4))\n",
        "plt.errorbar(day,boxTempDay,yerr=btdErr, marker='o', label=\"Avg. Box Temp\",capsize=2,linewidth=2)\n",
        "plt.xlabel('Time (days)')\n",
        "plt.ylabel('Temperature (deg C)')\n",
        "for k in reversed(range(0,zmax,zmax//5)):\n",
        "    zval = k*Deltax\n",
        "    labString = f\"Avg Temp at z={zval:.2f} m\"\n",
        "    plt.plot(day,boxTempDayZ[:,k], marker='o', label=labString) \n",
        "    \n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "3f001ea0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Heatmaps\n",
        "Let's view the middle cross sections every few hours on the last day:"
      ],
      "id": "ebc0d203"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for s in range(lmin,lmax,int(stepsInDay/12)):\n",
        "  plotheatmaps(u,s,xmid,ymid,zmid)"
      ],
      "id": "bcb0ce19",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Summary\n",
        "\n",
        "This is working as a proof of concept. Job 1: Done. But there's more to be done.\n",
        "\n",
        "### Next step\n",
        "As a torture device, this leaves much to be desired. Right now, it's no more effective than a chain-link fence from a temperature perspective. I'll be working on adding in solar radiation in the next post.\n",
        "\n",
        "### My future plans:\n",
        "As I seek to make this model more complex. I plan to do things that will slowly make my boring box look more like a house. Things like:\n",
        "\n",
        "- Making the box house sized and adding an appropriate number of windows.\n",
        "- Add in interior walls. \n",
        "- Add in heating and cooling.\n"
      ],
      "id": "c4e2d73b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/swolf/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}