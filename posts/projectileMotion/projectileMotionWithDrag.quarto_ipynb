{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Ready, Aim, Compute!\"\n",
        "description: \"Physics 1 physics vs. real world physics. Sorry, the world isn't filled with spherical cows in a vacuum\"\n",
        "author: \"Steven Wolf\"\n",
        "date: \"3/6/2025\"\n",
        "number-sections: false\n",
        "categories:\n",
        "  - Python\n",
        "  - Modeling\n",
        "  - Classes\n",
        "  - Motion\n",
        "execute: \n",
        "  messages: false\n",
        "  warning: false\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        ":::: {layout=\"[75, 25]\"}\n",
        "\n",
        "::: {#first-column}\n",
        "I've stalled out a bit on my heat equation modeling project because I've been thinking about ways to make it better. Also, I've been busy with the real world. So I thought I'd adapt something that I've used in class and post it here. Plus, I can't let my students have *_all_* the fun, right? In the standard treatment, we often make approximations that may or may not be valid, and never test these approximations. In fact, that's why we physicists often get made fun of, because we are talking about spherical cows. I like to get my students to think beyond spherical cows and give them tools to examine the limits of these approximations. So I'm going to build the models, and then play around a bit.\n",
        ":::\n",
        "\n",
        "::: {#second-column}\n",
        "[![ ](spherical-cow.png){width=15% fig-align=\"center\"}](https://www.sphericalcowblog.com/spherical-cows)\n",
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "## A typical Physics 1 projectile motion problem\n",
        "I've given this problem (or variations of it) in my physics class for years:\n",
        "\n",
        "> While on a vacation to Kenya, you visit the port city of Mombassa on the Indian \n",
        "> Ocean. On the coast, you find an old Portuguese fort probably built in the 16th \n",
        "> century. Large stone walls rise vertically from the shore to protect the fort \n",
        "> from cannon fire from pirate ships.  You wonder how close a pirate ship would \n",
        "> have to sail to the fort to be in range of the fort's cannon. Of course you \n",
        "> realize that the range depends on the velocity that the cannonball leaves the \n",
        "> cannon, as well as the height of the cliff.\n",
        "\n",
        "Usually, we set up a coordinate system like the picture below:\n",
        "\n",
        "![](systemFig.png){width=50% fig-align=\"center\"}\n",
        "\n",
        "Using this coordinate system, we can determine the equations of motion as follows:\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        " a_x(t) = \\frac{dv_x}{dt} &= 0 \\\\\n",
        " a_y(t) = \\frac{dv_y}{dt} &= -g \\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "These are integrated to find the velocity with the condition: $\\vec{v}_i = (v_i\\cos\\theta, v_i\\sin\\theta) = (v_x(0),v_y(0))$:\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        " v_x(t) = \\frac{dx}{dt} &= v_i \\cos\\theta t \\\\\n",
        " v_y(t) = \\frac{dy}{dt} &= v_i \\sin\\theta t - gt \\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "These are integrated again to find the position with the condition: $\\vec{r}_i = (0,H) = (x(0),y(0))$\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        " x(t) &= v_i \\cos\\theta t \\\\\n",
        " y(t) &= H + v_i\\sin\\theta t - \\frac{1}{2}gt^2 \\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "We are also interested in the time of flight (i.e., How long the projectile is in the air):\n",
        "\n",
        "$$\n",
        "y(T) = 0 = H + v_i \\sin\\theta T - \\frac{1}{2} gT^2 \\implies T = \\frac{v_i\\sin\\theta + \\sqrt{v_i^2 \\sin^2\\theta + 2gH}}{g}\n",
        "$$\n",
        "\n",
        "(Note, since the projectile is launched at $t=0$, we expect the time of flight $T>0$, so I have thrown out the negative solution for $T$ in the equation above.)\n",
        "\n",
        "And the range[^1] of the projectile:\n",
        "$$\n",
        "D = x(T) = v_i\\cos\\theta T = v_i \\cos\\theta \\frac{v_i\\sin\\theta + \\sqrt{v_i^2 \\sin^2\\theta + 2gH}}{g}\n",
        "$$\n",
        "\n",
        "\n",
        "[^1]: No, that's not the \"range equation\" found in standard physics textbooks. And no, I haven't made a mistake. The \"range equation\" in the standard physics text assumes $H=0$, that is, there is no elevation change to be concerned about. We can reduce this if we set $H=0$. In this case, $T = \\frac{2 v_i \\sin\\theta}{g}$ and $D = \\frac{2 v_i^2 \\sin\\theta \\cos\\theta}{g} = \\frac{v_i^2 \\sin(2\\theta)}{g}$, which is the standard physics textbook result, or what the AI will tell you if you google \"range equation physics\".\n",
        "\n",
        "This allows us to give physics students problems, and get them to calculate things. We also say that the motion of the cannonball is *parabolic*, and a bunch of other stuff that only works if we are talking about spherical cows flying around in vacuum. Anyone who has seen a shot tracer of a golf ball will say that these don't look like the parabolas we all drew back in High School Algebra classes. So what's going on?\n",
        "\n",
        "![](shotTracer.png){width=50% fig-align=\"center\"}\n",
        "\n",
        "### Ideal Projectile Motion: Thinking about code\n",
        "At this point, we have fully specified the problem. Any motion is fully specified given the cliff height $H$, launch speed $v_i$, and launch angle $\\theta$. We are done. Computationally, we want to be able to calculate all the important things, and define all of the important functions. I have chosen to use a python *class* to do so. The nice thing about using classes is that you can specify all of the variables for the system, but not have them cluttering the working environment.\n"
      ],
      "id": "39de8bcc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "class idealProjectile:\n",
        "  '''\n",
        "  Does the standard Physics 1 treatment of a projectile on earth for a projectile \n",
        "  fired from an elevated position\n",
        "  Inputs:\n",
        "    vLaunchMag = launch speed in m/s\n",
        "    vLaunchDir = launch angle measured from horizontal in degrees\n",
        "    height = elevation of the position in m\n",
        "  Outputs: (All in SI units)\n",
        "    tof = time of flight in seconds\n",
        "    maxX = range of projectile in m\n",
        "    position = function that calculates vector position as a function of time\n",
        "    velocity = function that calculates vector velocity as a function of time\n",
        "    acceleration = function that calculates vector acceleration as a function of time\n",
        "  '''\n",
        "  def __init__(self, vLaunchMag, vLaunchDir, height):\n",
        "    self.v0 = vLaunchMag\n",
        "    theta = np.pi/180*float(vLaunchDir)\n",
        "    self.theta = theta\n",
        "    self.h = height\n",
        "    self.g = 9.81\n",
        "    g = self.g\n",
        "    v0x = vLaunchMag*np.cos(theta)\n",
        "    v0y = vLaunchMag*np.sin(theta)\n",
        "    self.tof = (v0y + np.sqrt(v0y**2 + 2*g*height))/g\n",
        "    self.maxX = v0x * self.tof\n",
        "\n",
        "  def position(self, t):\n",
        "    v0, theta, g, h = self.v0, self.theta, self.g, self.h\n",
        "    v0x = v0*np.cos(theta)\n",
        "    v0y = v0*np.sin(theta)\n",
        "    x = v0x * t\n",
        "    y = h + v0y*t - 1/2 * g * t**2\n",
        "    return [x,y]\n",
        "  \n",
        "  def velocity(self,t):\n",
        "    v0, theta, g = self.v0, self.theta, self.g\n",
        "    v0x = v0*np.cos(theta)\n",
        "    v0y = v0*np.sin(theta)\n",
        "    vx = v0x\n",
        "    vy = v0y - g*t\n",
        "    return [vx,vy]\n",
        "\n",
        "  def acceleration(self,t):\n",
        "    return [0,-self.g]"
      ],
      "id": "6749570b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Air resistance:  It's a drag.\n",
        "When we model motion in a fluid, for large, fast objects we can write:\n",
        "\n",
        "$$\n",
        "\\vec{F}_{\\text{air}} = -c \\left|\\vec{v}\\right|\\vec{v} = -c \\sqrt{v_x(t)^2+v_y(t)^2} (v_x(t), v_y(t))\n",
        "$$\n",
        "where the coefficient $c$ is a constant that depends on the size and shape of the object moving through air, as well as the density of the fluid. This model can get more complicated, and [wikipedia](https://en.wikipedia.org/wiki/Drag_(physics)) discusses it further at a reasonably intro-level. But I won't bore you here.\n",
        "\n",
        "Including this in our model for projectile motion allows us to generate new equations of motion, and this can be done for all levels of physics.\n",
        "\n",
        "$$\n",
        "\\begin{align*}\n",
        " a_x(t) = \\frac{dv_x}{dt} &= - \\frac{c}{m} \\sqrt{v_x^2+v_y^2} v_x\\\\\n",
        " a_y(t) = \\frac{dv_y}{dt} &= -g - \\frac{c}{m} \\sqrt{v_x^2+v_y^2} v_y\\\\\n",
        "\\end{align*}\n",
        "$$\n",
        "\n",
        "These are integrated to find the velocity with the condition: $\\vec{v}_i = (v_i\\cos\\theta, v_i\\sin\\theta) = (v_x(0),v_y(0))$, and we get...an error.\n",
        "\n",
        "![](error404.jpg){width=30% fig-align=\"center\"}\n",
        "\n",
        "Well, we can integrate these equations if we use, well, I'll let Katherine Johnson's character from the movie _Hidden Figures_ tell you:\n",
        "\n",
        "<div style=\"text-align:center\">\n",
        "<iframe width=\"400\" height=\"315\" allowfullscreen\n",
        "  src=\"https://www.youtube.com/embed/8xPRn9weLYg?si=IgIhM9ozVqNLZxMs\"> \n",
        "</iframe> \n",
        "</div>\n",
        "\n",
        "We won't actually use Euler's method, but instead use the default method in Python's `scipy.integrate.solve_ivp` function - [an application of the Runge-Kutta method](https://doi.org/10.1016/0771-050X(80)90013-3) which is still pretty ancient. (Well, it's older than me!) I won't be going into the details of the method here. \n",
        "\n",
        "The level of the class that I'm teaching determines how I proceed from here. If we have an upper level class, students use the numeric integrator of their choice, be it in Mathematica, Matlab, Python, or something else. In an intro class, I walk through Euler (or Euler-Cromer) integration with them. (And they will have seen a 1D implementation of Euler's method before we tackle this 2D version.)\n",
        "\n",
        "### Thinking about code\n",
        "Once we add the projectile mass $m$, and drag coefficient $c$ to the parameters that we had for the the ideal motion, $H$, $v_i$, and $\\theta$, we have fully specified the problem. Despite the fact that we cannot integrate the equations of motion analytically, we can do so numerically. As before, I have chosen to use a python _class_ to carry this out. Actually, I've created *two* classes to do this.  Let's go into the why for this choice in the next sections.\n",
        "\n",
        "#### A note about integrating differential equations numerically\n",
        "In physics, we use Newton's laws to generate differential equations governing the motion of a system.  Specifically, we get the acceleration, which is the *second derivative* of position. So if we want the position as a function of time for a system, this is a *_2nd order_* differential equation. However, numerical methods are built on solving *_1st order_* differential equations.[^2]\n",
        "\n",
        "[^2]: In general, a $n$th order differential equation has a $n$th derivative of a function as the highest order derivative of a function. So the equation $f'(x) = f(x) + 3(f(x))^2$ is a 1st order differential equation in $f(x)$ because it has that function, as well as the first derivative of that function only. And $f''(x) = f(x) + 3(f'(x))^2$ is a 2nd order differential equation.\n",
        "\n",
        "Let's think about the function $u(t)$ which returns a vector comprised of the position vector combined with the velocity vector.\n",
        "\n",
        "$$\n",
        "u(t) = \\left[x(t), y(t), v_x(t), v_y(t) \\right]\n",
        "$$\n",
        "\n",
        "We can take the time derivative of this function (I'll use a dot to signify differentiation with respect to time) and express it in terms of the velocity and acceleration\n",
        "$$\n",
        "\\dot{u}(t) = \\left[\\dot{x}(t), \\dot{y}(t), \\dot{v}_x(t), \\dot{v}_y(t) \\right] = \\left[v_x(t), v_y(t), a_x(t), a_y(t)\\right]\n",
        "$$\n",
        "\n",
        "`dragEOM` is this function $\\dot{u}(t)$ applied to our projectile system.\n"
      ],
      "id": "866f7dbd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class dragEOM:\n",
        "  '''\n",
        "  Equations of motion for projectile system with turbulent drag fired from an elevated position\n",
        "  Inputs:\n",
        "    vLaunchMag = launch speed in m/s\n",
        "    vLaunchDir = launch angle measured from horizontal in degrees\n",
        "    height = elevation of the position in m\n",
        "    mass = mass of projectile in kg\n",
        "    dragCoef = drag coefficient for system in kg/m\n",
        "  Outputs:\n",
        "    udot = [xdot, ydot, vxdot, vydot]\n",
        "    splash = function that returns y coordinate (needed for integration)\n",
        "  '''\n",
        "  def __init__(self, vLaunchMag, vLaunchDir, height, mass, dragCoef):\n",
        "      self.v0 = vLaunchMag\n",
        "      theta = np.pi/180*float(vLaunchDir)\n",
        "      self.theta = theta\n",
        "      self.h = height\n",
        "      self.g = 9.81\n",
        "      g = self.g\n",
        "      self.coef = dragCoef/mass\n",
        "      v0x = vLaunchMag*np.cos(theta)\n",
        "      v0y = vLaunchMag*np.sin(theta)\n",
        "      self.idealTof = (v0y + np.sqrt(v0y**2 + 2*g*height))/g\n",
        "      self.u0 = [0, height, v0x, v0y]\n",
        "\n",
        "  def __call__(self,t,u):\n",
        "      g, coef = self.g, self.coef\n",
        "      x, y, vx, vy = u\n",
        "      xdot, ydot = vx, vy\n",
        "      vxdot = -coef * np.sqrt(vx**2 + vy**2) * vx\n",
        "      vydot = -g - coef * np.sqrt(vx**2 + vy**2) * vy\n",
        "      udot = [xdot, ydot, vxdot, vydot]\n",
        "      return udot\n",
        "\n",
        "  def splash(self,t,u):\n",
        "      return u[1]\n",
        "\n",
        "  splash.terminal = True"
      ],
      "id": "db66bba2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Getting the motion\n",
        "Now that this is done, we can get the motion for this system using the following class:\n"
      ],
      "id": "f92a1693"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from scipy.integrate import solve_ivp\n",
        "\n",
        "class dragProjectile:\n",
        "  '''\n",
        "  Equations of motion for projectile system with turbulent drag fired from an elevated position\n",
        "  Inputs:\n",
        "    vLaunchMag = launch speed in m/s\n",
        "    vLaunchDir = launch angle measured from horizontal in degrees\n",
        "    height = elevation of the position in m\n",
        "    mass = mass of projectile in kg\n",
        "    dragCoef = drag coefficient for system in kg/m\n",
        "  Outputs:\n",
        "    t = vector of time values where the system is solved\n",
        "    x, y = vectors of position values matching the time vector above\n",
        "    vx, vy = vectors of velocity values matching the time vector above\n",
        "    ax, ay = vectors of acceleration values matching the time vector above\n",
        "    tof = time of flight \n",
        "    maxX = projectile range\n",
        "  '''\n",
        "  def __init__(self, vLaunchMag, vLaunchDir, height, mass, dragCoef):\n",
        "    model = dragEOM(vLaunchMag, vLaunchDir, height, mass, dragCoef)\n",
        "    tMax = 2 * model.idealTof\n",
        "    tVals = np.linspace(0,tMax,100)\n",
        "    u0 = model.u0\n",
        "    sol = solve_ivp(model, t_span=[0,tMax], y0 = u0, t_eval=tVals, events=model.splash, dense_output=True)\n",
        "    self.tof = sol.t_events[0][0]\n",
        "    self.maxX = sol.y_events[0][0][0]\n",
        "    self.t = sol.t\n",
        "    self.x = sol.y[0, :]\n",
        "    self.y = sol.y[1, :]\n",
        "    self.vx = sol.y[2, :]\n",
        "    self.vy = sol.y[3, :]\n",
        "    udot = model(sol.t, sol.y)\n",
        "    self.ax = udot[2]\n",
        "    self.ay = udot[3]"
      ],
      "id": "2bf39956",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Comparing motion with/without air resistance\n",
        "Now that we have these tools built, we can start to visualize this motion. I'll do this using some functions in my `projectile.py` file to make graphs. I will also include the following numerical values:\n",
        "\n",
        "- $H = 200$ m\n",
        "- $v_i = 100$ m/s\n",
        "- $\\theta = 30$ deg\n",
        "- $m = 1$ kg\n",
        "- $c = 0.003$ kg/m\n"
      ],
      "id": "efba101d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from projectile import *\n",
        "\n",
        "H = 200\n",
        "vi = 100\n",
        "theta = 30\n",
        "m = 1\n",
        "c = 0.003"
      ],
      "id": "cf1b837e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "I will visualize this motion in two ways. First, I'll plot each quantity of the motion (position, velocity, acceleration) vs. time. \n"
      ],
      "id": "0f121e40"
    },
    {
      "cell_type": "code",
      "metadata": {
        "width": "75%"
      },
      "source": [
        "#| fig-align: center\n",
        "\n",
        "plotCannonCurves(vi,theta,H,m,c)"
      ],
      "id": "0afdbbc5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now I will plot the trajectory (y-coordinate vs x-coordinate). Note that I have added boxes to this plot indicating the cliff location and the water level to help guide the eye. The plot has also been set up with an equal aspect ratio so that the horizontal and vertical distances are the same. The green curve should more closely match the golf ball tracer than the red parabolic path does.\n"
      ],
      "id": "94c57abe"
    },
    {
      "cell_type": "code",
      "metadata": {
        "width": "75%"
      },
      "source": [
        "#| fig-align: center\n",
        "\n",
        "makeTrajectoryPlot(vi,theta,H,m,c)"
      ],
      "id": "79531827",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Where to go from here\n",
        "Usually, I'll give my students some tasks like finding the maximum range of the projectile, and comparing the model results. I thought that I would do something a little different as it will allow me to compare the model predictions. I will do this using the fractional difference between the two predictions for both the range and the time of flight. Since I used $D$ to denote the range, I will write $D_1$ to denote the range for model 1 (no air resistance) and $D_2$ to denote the range for model 2 (with air resistance). Therefore the quantity below is the fractional difference between the targeting location of the models.\n",
        "\n",
        "$$\n",
        "\\delta_D = \\frac{\\left|D_1 - D_2\\right|}{D_1}\n",
        "$$\n",
        "\n",
        "I will also define a similar quantity related to the time-of-flight.\n",
        "\n",
        "$$\n",
        "\\delta_T = \\frac{\\left|T_2 - T_1\\right|}{T_2}\n",
        "$$\n",
        "\n",
        "Note that I'm using $D_1$ in the denominator of  $\\delta_D$ and $T_2$ in the denominator of $\\delta_T$. This is because these are the larger values for each motion.\n",
        "\n",
        "I will calculate these quantities for a range of launch velocities, masses, and launch angles keeping the cliff height $(H=100 \\,\\text{m})$ and drag coefficient $(c=0.003 \\,\\text{kg/m})$ the same as it was before.\n"
      ],
      "id": "f25bdc33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "import matplotlib.colors as mc\n",
        "import matplotlib.cm as cm\n",
        "\n",
        "launchVelocities = np.linspace(0,200,21)\n",
        "launchAngles = np.linspace(0,85,18)\n",
        "masses = np.logspace(-2,2,19)\n",
        "nv = len(launchVelocities)\n",
        "na = len(launchAngles)\n",
        "nm = len(masses)\n",
        "deltaD = np.empty(shape=(nv,na,nm))\n",
        "deltaT = np.empty(shape=(nv,na,nm))\n",
        "for i in range(nv):\n",
        "  for j in range(na):\n",
        "    for k in range(nm):\n",
        "      lv = launchVelocities[i]\n",
        "      la = launchAngles[j]\n",
        "      mm = masses[k]\n",
        "      m1 = idealProjectile(lv,la,H)\n",
        "      m2 = dragProjectile(lv,la,H,mm,c)\n",
        "      D1 = m1.maxX\n",
        "      D2 = m2.maxX\n",
        "      T1 = m1.tof\n",
        "      T2 = m2.tof\n",
        "      deltaT[i,j,k] = np.abs(T1 - T2)/T2\n",
        "      if D1<1 and D2 <1:\n",
        "        # For small ranges (less than 1 meter from the cliff), just set the \n",
        "        # fractional difference equal to zero\n",
        "        deltaD[i,j,k] = 0\n",
        "      else:\n",
        "        deltaD[i,j,k] = np.abs(D1 - D2)/D1\n",
        "\n",
        "# Set up properties of the color bar \n",
        "cnormD = mc.Normalize(vmin=0,vmax=deltaD.max())\n",
        "cbarD = cm.ScalarMappable(norm=cnormD,cmap='plasma')\n",
        "cnormT = mc.Normalize(vmin=0,vmax=deltaT.max())\n",
        "cbarT = cm.ScalarMappable(norm=cnormT)\n",
        "\n",
        "# Arrange the calculations into multiple grids for making a heatmap/contour plot\n",
        "X1, Y1 = np.meshgrid(launchVelocities, launchAngles)\n",
        "Z1 = deltaD[:, :, nm//2].transpose()\n",
        "ZZ1 = deltaT[:, :, nm//2].transpose()\n",
        "\n",
        "X2, Y2 = np.meshgrid(launchVelocities, masses)\n",
        "Z2 = deltaD[:, na//2, :].transpose()\n",
        "ZZ2 = deltaT[:, na//2, :].transpose()\n",
        "\n",
        "X3, Y3 = np.meshgrid(launchAngles, masses)\n",
        "Z3 = deltaD[nv//2, :, :].transpose()\n",
        "ZZ3 = deltaT[nv//2, :, :].transpose()"
      ],
      "id": "c3ba741b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now, let's examine the model agreement for the range:"
      ],
      "id": "17aea970"
    },
    {
      "cell_type": "code",
      "metadata": {
        "width": "90%"
      },
      "source": [
        "#| code-fold: true\n",
        "#| fig-align: center\n",
        "\n",
        "fig1, ax1 = plt.subplots(1,3,figsize=(7,4))\n",
        "fig1.suptitle(\"Comparing predicted range with/without air resistance\")\n",
        "CS = ax1[0].contourf(X1,Y1,Z1,100,cmap='plasma')\n",
        "ax1[0].set_title(f'Mass = {masses[nm//2]:.2f} kg',size=10)\n",
        "ax1[0].set_xlabel('Launch velocity (m/s)')\n",
        "ax1[0].set_ylabel('Launch angle (deg)')\n",
        "ax1[1].contourf(X2,Y2,Z2,100,cmap='plasma')\n",
        "ax1[1].set_title(f'Launch angle = {launchAngles[na//2]:.0f} deg',size=10)\n",
        "ax1[1].set_xlabel('Launch velocity (m/s)')\n",
        "ax1[1].set_ylabel('Mass (kg)')\n",
        "ax1[1].set_yscale('log')\n",
        "ax1[2].contourf(X3,Y3,Z3,100,cmap='plasma')\n",
        "ax1[2].set_title(f'Launch velocity = {launchVelocities[nv//2]:.0f} m/s',size=10)\n",
        "ax1[2].set_xlabel('Launch angle (deg)')\n",
        "ax1[2].set_ylabel('Mass (kg)')\n",
        "ax1[2].set_yscale('log')\n",
        "fig1.subplots_adjust(bottom=0.3,wspace=0.5,right=0.9)\n",
        "cbar_ax = fig1.add_axes([0.2, 0.15, 0.65, 0.02])\n",
        "fig1.colorbar(cbarD, cax=cbar_ax,label=r'$\\delta_D$',orientation='horizontal')\n",
        "ghLogo = u\"\\uf09b\"\n",
        "liLogo = u\"\\uf08c\"\n",
        "txt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\n",
        "plt.figtext(0.6,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\n",
        "plt.savefig('rangeCalcFracDiff.png')\n",
        "plt.show()"
      ],
      "id": "6858c18d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, I'll examine the model agreement for the time-of-flight:"
      ],
      "id": "945ae52e"
    },
    {
      "cell_type": "code",
      "metadata": {
        "width": "90%"
      },
      "source": [
        "#| code-fold: true\n",
        "#| fig-align: center\n",
        "\n",
        "fig1, ax1 = plt.subplots(1,3,figsize=(7,4))\n",
        "fig1.suptitle(\"Comparing predicted time of flight with/without air resistance\")\n",
        "CS = ax1[0].contourf(X1,Y1,ZZ1,100)\n",
        "ax1[0].set_title(f'Mass = {masses[nm//2]:.2f} kg',size=10)\n",
        "ax1[0].set_xlabel('Launch velocity (m/s)')\n",
        "ax1[0].set_ylabel('Launch angle (deg)')\n",
        "ax1[1].contourf(X2,Y2,ZZ2,100)\n",
        "ax1[1].set_title(f'Launch angle = {launchAngles[na//2]:.0f} deg',size=10)\n",
        "ax1[1].set_xlabel('Launch velocity (m/s)')\n",
        "ax1[1].set_ylabel('Mass (kg)')\n",
        "ax1[1].set_yscale('log')\n",
        "ax1[2].contourf(X3,Y3,ZZ3,100)\n",
        "ax1[2].set_title(f'Launch velocity = {launchVelocities[nv//2]:.0f} m/s',size=10)\n",
        "ax1[2].set_xlabel('Launch angle (deg)')\n",
        "ax1[2].set_ylabel('Mass (kg)')\n",
        "ax1[2].set_yscale('log')\n",
        "fig1.subplots_adjust(bottom=0.3,wspace=0.5,right=0.9)\n",
        "cbar_ax = fig1.add_axes([0.2, 0.15, 0.65, 0.02])\n",
        "fig1.colorbar(cbarT, cax=cbar_ax,label=r'$\\delta_T$',orientation='horizontal')\n",
        "ghLogo = u\"\\uf09b\"\n",
        "liLogo = u\"\\uf08c\"\n",
        "txt = f\"{ghLogo} datawolf04 {liLogo} steven-wolf-253b6625a\"\n",
        "plt.figtext(0.6,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=10)\n",
        "plt.savefig('tofCalcFracDiff.png')\n",
        "plt.show()"
      ],
      "id": "7b61c5ba",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that the color scales for these plots have different ranges. In particular the max $\\delta_T$ value is larger than the max $\\delta_D$ value. Given the initial height, it would seem that the time of flight is much more sensitive to air resistance. In general, areas on the plots above where the color is yellow shows a high level of disagreement between motion in vacuum vs. motion in air. Areas where the color is blue/violet shows a low level of disagreement between the models. Since air resistance is dependent on speed, we would expect that at low speeds, air resistance is less important, especially for the range calculation. Given the fact that gravity/weight is the other force of interest, objects with a larger mass are also less sensitive to air resistance. \n",
        "\n",
        "There is an interesting \"trough\" in the time of flight graphic. You can see that the minimum $\\delta_T$ values aren't along one of the axes as they are for $\\delta_D$. This is because for very slow, or nearly vertical launch trajectories, the range isn't going to be very different as it just doesn't move very fast in the x-direction. Perhaps the best way to think about this is to compare the motion of a gently tossed pebble to a gently tossed feather from the same height. They both land in (about) the same place.  So both have a small difference with the vacuum range.  The time of flight will be different, since the feather stops going up sooner, and falls with an average acceleration much different than $-g$. Yet the motion of the pebble will be much more similar to the vacuum motion since the drag force is much smaller in magnitude than the weight of the pebble.\n",
        "\n",
        "##### Motion of a \"feather\" vs a \"pebble\"\n"
      ],
      "id": "9dba6d44"
    },
    {
      "cell_type": "code",
      "metadata": {
        "width": "75%"
      },
      "source": [
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "vi = 50\n",
        "vdir = 85\n",
        "\n",
        "vacuum = idealProjectile(vi,vdir,H)\n",
        "iTime = np.linspace(0,vacuum.tof,100)\n",
        "[iPosx, iPosy] = vacuum.position(iTime)\n",
        "[iVelx, iVely] = vacuum.velocity(iTime)\n",
        "[iAccx, iAccy] = vacuum.acceleration(iTime)\n",
        "\n",
        "feather = dragProjectile(vi,vdir,H,.1,c)\n",
        "pebble = dragProjectile(vi,vdir,H,10,c)\n",
        "\n",
        "fig, ax = plt.subplots(1,3,figsize=(9,4))\n",
        "fig.suptitle(f'Motion of ideal projectile, \"feather\", and \"pebble\" for \\n'+\n",
        "        f'launch velocity = {vi:.0f} m/s and launch angle = {vdir:.0f} deg')\n",
        "ax[0].axhline(iAccx,label='vacuum')\n",
        "ax[0].plot(feather.t, feather.ax,'r',label='feather')\n",
        "ax[0].plot(pebble.t, pebble.ax,'g',label='pebble')\n",
        "ax[0].set_xlabel('time (s)')\n",
        "ax[0].set_ylabel(r'$a_x$ (m/s^2)')\n",
        "ax[0].legend()\n",
        "ax[1].axhline(iAccy,label='vacuum')\n",
        "ax[1].plot(feather.t, feather.ay,'r',label='feather')\n",
        "ax[1].plot(pebble.t, pebble.ay,'g',label='pebble')\n",
        "ax[1].set_xlabel('time (s)')\n",
        "ax[1].set_ylabel(r'$a_y$ (m/s^2)')\n",
        "ax[0].set_ylim(ax[1].get_ylim())\n",
        "ax[1].legend()\n",
        "ax[2].plot(iPosx,iPosy, label='vacuum')\n",
        "ax[2].plot(feather.x, feather.y,'r', label='feather')\n",
        "ax[2].plot(pebble.x, pebble.y,'g',label='pebble')\n",
        "ax[2].axis('equal')\n",
        "ax[2].set_xlim([0,200])\n",
        "ax[2].set_xlabel(r'$x$ (m)')\n",
        "ax[2].set_ylabel(r'$y$ (m)')\n",
        "ax[2].legend()\n",
        "fig.subplots_adjust(wspace=0.4,bottom=0.2)\n",
        "plt.figtext(0.65,0.01, txt,family=['DejaVu Sans','FontAwesome'],fontsize=9)\n",
        "plt.show()"
      ],
      "id": "2c382543",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/usr/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}